{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/iOS/gesture.png","path":"img/iOS/gesture.png","modified":1,"renderable":0},{"_id":"source/img/java/collection.png","path":"img/java/collection.png","modified":1,"renderable":0},{"_id":"source/img/innerclass/innerclass01.png","path":"img/innerclass/innerclass01.png","modified":1,"renderable":0},{"_id":"source/img/java/hashmap1.jpg","path":"img/java/hashmap1.jpg","modified":1,"renderable":0},{"_id":"source/img/java/hashmap2.png","path":"img/java/hashmap2.png","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_06.png","path":"img/nginx/nginx_06.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_05.png","path":"img/nginx/nginx_05.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_13.png","path":"img/nginx/nginx_13.png","modified":1,"renderable":0},{"_id":"source/img/stack/stack.jpg","path":"img/stack/stack.jpg","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/iOS/layoutSubviews.png","path":"img/iOS/layoutSubviews.png","modified":1,"renderable":0},{"_id":"source/img/iOS/setlayout.png","path":"img/iOS/setlayout.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_04.png","path":"img/nginx/nginx_04.png","modified":1,"renderable":0},{"_id":"source/img/lombok/lombok_01.png","path":"img/lombok/lombok_01.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_10.png","path":"img/nginx/nginx_10.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_12.png","path":"img/nginx/nginx_12.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_09.png","path":"img/nginx/nginx_09.png","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/lombok/lombok_02.png","path":"img/lombok/lombok_02.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_11.png","path":"img/nginx/nginx_11.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_15.png","path":"img/nginx/nginx_15.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_14.png","path":"img/nginx/nginx_14.png","modified":1,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/iOS/uiview.png","path":"img/iOS/uiview.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_02.png","path":"img/nginx/nginx_02.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_03.png","path":"img/nginx/nginx_03.png","modified":1,"renderable":0},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/iOS/pch.png","path":"img/iOS/pch.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_01.png","path":"img/nginx/nginx_01.png","modified":1,"renderable":0},{"_id":"source/img/stack/getMinStack.png","path":"img/stack/getMinStack.png","modified":1,"renderable":0},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_07.png","path":"img/nginx/nginx_07.png","modified":1,"renderable":0},{"_id":"source/img/nginx/nginx_08.png","path":"img/nginx/nginx_08.png","modified":1,"renderable":0},{"_id":"source/img/bookImg/allbooks.jpeg","path":"img/bookImg/allbooks.jpeg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1471543628000},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1471543628000},{"_id":"themes/huxblog/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1471543628000},{"_id":"themes/huxblog/_config.yml","hash":"345b59ba9b07c34bb4602640922d9fe2999a4a35","modified":1472805538000},{"_id":"source/_posts/Java中interface与-interface的区别.md","hash":"2598fdc8ccdcb0ed064fb45321b5b77e1039d966","modified":1477642969000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1472806481000},{"_id":"source/_posts/Java内部类详解.md","hash":"f30eae1d454d314c00fe89150c9142dd22aee9df","modified":1473400949000},{"_id":"source/_posts/Java源码分析-一-HashMap.md","hash":"f0d98242ad6b4b0d370b42d72b7f77948a0c6b22","modified":1479866329000},{"_id":"source/_posts/UIKit学习总结.md","hash":"decb18f807acc59e149e62fef3c3358cbad82f5d","modified":1476063314000},{"_id":"source/_posts/Java源码分析-二-ArrayList.md","hash":"eaf8416a0c45cd4e2374542c77fb9d6931c4290a","modified":1472806954000},{"_id":"source/_posts/Java源码分析-三-HashSet.md","hash":"18533b64d0e361d506fdd983e44a1073dd0dd680","modified":1473400949000},{"_id":"source/_posts/iOS图片视频播放.md","hash":"8a2015cb474e576693de5dae37fef8455e016bb6","modified":1476063314000},{"_id":"source/_posts/iOS（iOS7-）开发中的常用的Tips.md","hash":"482929f1bd9dc3c6091b3e15f46b0d6a353be89f","modified":1476063314000},{"_id":"source/_posts/iOS开发的代码结构.md","hash":"63cef20878af7f27ddb3f1054c17390c72ca7e69","modified":1476063314000},{"_id":"source/_posts/hello-world.md","hash":"d95d6025bd0b0d1d0fa195e54d92c7a3b0703359","modified":1476063578000},{"_id":"source/_posts/使用lombok简化Java代码.md","hash":"8007bc42926d4fff06fae775b6dcbc0f287c7f2a","modified":1476157607000},{"_id":"source/_posts/《深入理解Java虚拟机》读书笔记-一.md","hash":"5210b4367f7efbd9b6197f5665afad7957f90f7d","modified":1479283462000},{"_id":"source/_posts/使用一台Nginx对多台Tomcat实现负载均衡.md","hash":"197147ab988e2841211fb1138cf4eedf8c6be948","modified":1477642759000},{"_id":"source/_posts/《深入理解Java虚拟机》读书笔记（二）.md","hash":"a8d04710e9555dff9ff27113ff383dd87ff121e4","modified":1479284197000},{"_id":"source/_posts/学吉他.md","hash":"d1fdfae028d51a843ff03074519db0b019bf6188","modified":1476063314000},{"_id":"source/_posts/测试文章.md","hash":"b92167f92e46621e95773d1f4c2ea6b474654824","modified":1476063314000},{"_id":"source/_posts/博客说明.md","hash":"fd2be1c7c68263ac55dbbcfd576331419fd8343b","modified":1473403755000},{"_id":"source/_posts/算法-三-常用数据结构的定义.md","hash":"2485e4f9d45c2cd09419e86d3b98c46d6bbf50ba","modified":1476063314000},{"_id":"source/_posts/算法-一-Stack-栈-的实现.md","hash":"80a3105b716eeeeb44fe91a652442efcaf74e10b","modified":1474594550000},{"_id":"source/_posts/深入理解Java虚拟机-二.md","hash":"04e8a8838eb9b9a954d9742f97f5f0c1a024c18b","modified":1479283642000},{"_id":"source/_posts/读书 2.md","hash":"093b8dadf340959b4506a411561bd89ba28e4d1f","modified":1476063314000},{"_id":"source/_posts/算法-二-实现一个getMin功能的栈.md","hash":"439dcbfb0a000ecad5e095de5fb2acdf136b3627","modified":1474594550000},{"_id":"source/archives/index.md","hash":"f30bcd9cd0fbe690c2398f21dbf27e56c0c72499","modified":1471543628000},{"_id":"source/_posts/读书.md","hash":"a49867ba9fc4d12d4492ab8537f236d7edf55cf8","modified":1473403384000},{"_id":"source/about/index.md","hash":"01ed44649770471af064326f5f3610c952730cc9","modified":1473402607000},{"_id":"source/tags/index.md","hash":"0bc541f4c6a0f21bec67b6717ee86226f0eddf39","modified":1471543628000},{"_id":"source/img/avatar.jpg","hash":"4acb0c03fb9dc29b11370be765cbf39019735026","modified":1473400949000},{"_id":"source/img/.DS_Store","hash":"1bef21354b75d04b53f2b67f00146d099c5f920d","modified":1477635144000},{"_id":"source/img/favicon.ico","hash":"0dc38229f66a6961e8bd15c9a6b7068633e99105","modified":1472812304000},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1471543628000},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1471543628000},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1471543628000},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1471543628000},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1471543628000},{"_id":"themes/huxblog/layout/archives.ejs","hash":"f0046e58cc1dd876133be2bf927aed2b1821cb3e","modified":1471543628000},{"_id":"themes/huxblog/layout/index.ejs","hash":"70ac58c46625300a70791e210daf446afa6d1cd4","modified":1471543628000},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"16a4164c3d291131fb66078e8df93b31fe050040","modified":1471543628000},{"_id":"themes/huxblog/layout/layout.ejs","hash":"03e278a3b8bc4503183276b6130ac04a8d5b9865","modified":1471543628000},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1471543628000},{"_id":"themes/huxblog/layout/post.ejs","hash":"a9db023e8fa7277749eb4b0e6683f944aed3707e","modified":1471543628000},{"_id":"themes/huxblog/layout/page.ejs","hash":"3fde0787e883274563f9de5aaeb8130b667e132a","modified":1471543628000},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1471543628000},{"_id":"source/_posts/Java内部类详解/innerclass01.png","hash":"844fb099ae8434bd16dea29cae375b0690721834","modified":1473400949000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1471543628000},{"_id":"source/img/iOS/gesture.png","hash":"e9cb5df8a023b10ea3228695664dee7388fb1011","modified":1476063314000},{"_id":"source/img/java/collection.png","hash":"5238c7b5d8a772f3112003be3036cd99d6001184","modified":1473404385000},{"_id":"source/img/innerclass/innerclass01.png","hash":"844fb099ae8434bd16dea29cae375b0690721834","modified":1473400949000},{"_id":"source/img/java/hashmap1.jpg","hash":"47836575ca6d2d470921fd28747fe912bf8895bc","modified":1479285455000},{"_id":"source/img/java/hashmap2.png","hash":"eec94244213b2d14438e7341021fc4b9b5dd0feb","modified":1479285494000},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1471543628000},{"_id":"source/img/nginx/nginx_06.png","hash":"757a6840a827bf81bbc90d952aa4753d7c890ed3","modified":1477637178000},{"_id":"source/img/nginx/nginx_05.png","hash":"14539589f6da7e78cdc55a0b95cd05f3023f38d9","modified":1477637152000},{"_id":"source/img/nginx/nginx_13.png","hash":"9af3aef09e818bc8737bcf4b7f991f27d061377a","modified":1477641687000},{"_id":"source/img/stack/stack.jpg","hash":"c71a5d7f8932b98c7266a2bd582bcfa244a19a78","modified":1474594550000},{"_id":"source/img/nginx/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1477642743000},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1471543628000},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"4b859c2171054ecba1d70f0eabe09661a9f4f9eb","modified":1471543628000},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"28ad30f151b83619418b2265dc7642ee67175973","modified":1473400949000},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1471543628000},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1471543628000},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1471543628000},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1471543628000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1471543628000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1471543628000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1471543628000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1471543628000},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1471543628000},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1471543628000},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1471543628000},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1471543628000},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1471543628000},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1471543628000},{"_id":"source/img/iOS/layoutSubviews.png","hash":"b5adfcd2ff790f43065963415a29f6e19b83dc61","modified":1476063314000},{"_id":"source/img/iOS/setlayout.png","hash":"39f5211fe0bef287bc22df1d927c01481f44a848","modified":1476063314000},{"_id":"source/img/nginx/nginx_04.png","hash":"4e40e08f9e0823d847f1b273e729b98a82f5cd8c","modified":1477637133000},{"_id":"source/img/lombok/lombok_01.png","hash":"41f725d7b3ca8eac3a8e0e3655520f74dc8d35e8","modified":1476155624000},{"_id":"source/img/nginx/nginx_10.png","hash":"efcacfa22543f335220290744ed7e732e916ccb7","modified":1477641914000},{"_id":"source/img/nginx/nginx_12.png","hash":"562b28f3b76714dc937af5d2a02b62e0fd0c775d","modified":1477641632000},{"_id":"source/img/nginx/nginx_09.png","hash":"980b21c060edb018967e1570fc76a7bcdc47dc97","modified":1477641894000},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1471543628000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1471543628000},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1471543628000},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1471543628000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1471543628000},{"_id":"source/img/lombok/lombok_02.png","hash":"c2ad0d9639f0f231919b2340ad346b04db44fab9","modified":1476155806000},{"_id":"source/img/nginx/nginx_11.png","hash":"be44390247df8b2b5f58b1dbef73dbe3c5975e82","modified":1477639381000},{"_id":"source/img/nginx/nginx_15.png","hash":"34c0e30c3b7a5d0fc3813041640139893ea564bd","modified":1477642740000},{"_id":"source/img/nginx/nginx_14.png","hash":"b0fd1f75b70f2c3e413fb961fc977278c80a893f","modified":1477641375000},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1471543628000},{"_id":"source/img/iOS/uiview.png","hash":"7be9332a77297de9faed756f8904de8346bdd1c0","modified":1476063314000},{"_id":"source/img/nginx/nginx_02.png","hash":"19f848cb88107a9e286726760ee7bd8b46554a5a","modified":1477635320000},{"_id":"source/img/nginx/nginx_03.png","hash":"a0391110c6d5e75c815d247de277458cff423e25","modified":1477635704000},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1471543628000},{"_id":"source/img/iOS/pch.png","hash":"4b04d9ed6ba87669392ea429ea1611842019dbb9","modified":1476063314000},{"_id":"source/img/nginx/nginx_01.png","hash":"b680d4a8b02b75c99a0982f37b5a1686038e212a","modified":1477635059000},{"_id":"source/img/stack/getMinStack.png","hash":"4f313b4c3fab224c1971b1eb821778287f4ad336","modified":1474594550000},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1471543628000},{"_id":"source/img/nginx/nginx_07.png","hash":"3c8dd1e01f97f5fd6362c4674772f1f9be6aaae0","modified":1477635943000},{"_id":"source/img/nginx/nginx_08.png","hash":"40ca2b26c04933216345f179b1deffa37069a592","modified":1477635989000},{"_id":"source/img/bookImg/allbooks.jpeg","hash":"98d94f90211b8d5ba9ac1b20346328d982bc31d5","modified":1473403257000},{"_id":"public/404.html","hash":"84eca40acf601d95f55293862aa13b9ac8ed157e","modified":1479868538053},{"_id":"public/2016/10/09/Java中interface与-interface的区别/index.html","hash":"abeff24b9c0d50f23cccf939ced565ffbe90d076","modified":1479868538067},{"_id":"public/2016/09/02/Java源码分析-三-HashSet/index.html","hash":"f2bdbbc5e017097b76b584bb15da9113f019d9fb","modified":1479868538069},{"_id":"public/2016/09/02/Java源码分析-二-ArrayList/index.html","hash":"1128d64a1d2513a3eaa0bb139e1764d544a4e422","modified":1479868538069},{"_id":"public/2016/09/01/读书/index.html","hash":"83123fae42446028541d3b00b7494a2aefc9031d","modified":1479868538069},{"_id":"public/2016/09/01/博客说明/index.html","hash":"0c1852d4a99f0537f4263c7527257c8229444cce","modified":1479868538069},{"_id":"public/2015/09/13/iOS图片视频播放/index.html","hash":"1fba12a466fccbb1a499b5eedac1e0fa7e4f672d","modified":1479868538069},{"_id":"public/2015/09/05/学吉他/index.html","hash":"76603d277534ae377dffd371c534e689b42deb22","modified":1479868538069},{"_id":"public/2015/09/05/读书 2/index.html","hash":"536e34036dfee441db9330e227a1af7fcff66059","modified":1479868538069},{"_id":"public/2015/09/01/iOS（iOS7-）开发中的常用的Tips/index.html","hash":"985b4e59621622a7efd818f2412f4f49c8e40ab6","modified":1479868538069},{"_id":"public/2015/08/23/测试文章/index.html","hash":"7756435e65e8f9b65ee219663a9009dde356c3e8","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/index.html","hash":"818457fea58cec9ab5a79bbf2737ec2fe7373d97","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/page/2/index.html","hash":"75b2858ccd95e94a716d166f1c73885eeda1fe54","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/page/3/index.html","hash":"5b7e6a663c6643322928cfb0cc0a26bae82b05b9","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2015/index.html","hash":"76c18115815e390629a38af9634cdb01be0a8b8f","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2015/08/index.html","hash":"41c6e9b5ae3626e9311954cd7a0a7d978f1078bd","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2015/09/index.html","hash":"80d548a35757adc38e42f52bd5b0d23692c666db","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2016/index.html","hash":"060d57c358254fff23ad00cdc312c0628697bd2f","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2016/page/2/index.html","hash":"394528dca84490bcd37db150eb719dc3824cc0f6","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2016/09/index.html","hash":"b3a7eae7958ba2fa87ed68716a7a7c8545ede410","modified":1479868538070},{"_id":"public/i_dont_wanna_use_default_archives/2016/10/index.html","hash":"7033ad952bee15d2077b308e521f65950b445048","modified":1479868538070},{"_id":"public/tags/Java/index.html","hash":"af33d475114900f57bc77091a04c59f143a1feea","modified":1479868538070},{"_id":"public/tags/Java内部类/index.html","hash":"74b07ec7ecb6598e7dcff74977e89771eb28f105","modified":1479868538070},{"_id":"public/tags/注解/index.html","hash":"abd258aa869279915194c822b42e7a11b94964ec","modified":1479868538070},{"_id":"public/tags/interface/index.html","hash":"70dc4429941105b0e87706ef21d5cc318b3ad03f","modified":1479868538070},{"_id":"public/tags/iOS/index.html","hash":"dc0f5f31bbd4ee200fa289917b24569bf8137b5a","modified":1479868538070},{"_id":"public/tags/ArrayList/index.html","hash":"c1566dc61d16b9e23c14308840af0393f6e92739","modified":1479868538071},{"_id":"public/tags/HashSet/index.html","hash":"680e9b7d7a05346aacd8768cab23cffaac2ad96a","modified":1479868538071},{"_id":"public/tags/java/index.html","hash":"82f66461340a71078ae94d29fbfcc3a820d7ae7f","modified":1479868538071},{"_id":"public/tags/lombok/index.html","hash":"bf3115ead551ef078987c819a5432ee840ccacff","modified":1479868538071},{"_id":"public/tags/代码优化/index.html","hash":"556b31a2ae010425b4f40d32844c725ab0f158f7","modified":1479868538071},{"_id":"public/tags/深入理解Java虚拟机/index.html","hash":"a052380e4a3535755c768b6509bf88af4ae20bed","modified":1479868538071},{"_id":"public/tags/Nginx/index.html","hash":"35e37bc2efe8e104f18e7d98e7b9f8686adc7160","modified":1479868538071},{"_id":"public/tags/负载均衡/index.html","hash":"6cad0adb54a1cce688de644875178528d97f0196","modified":1479868538071},{"_id":"public/tags/Tomcat/index.html","hash":"0a4c10aa85f42e20a99b61fac6b7078d946a529f","modified":1479868538071},{"_id":"public/tags/算法/index.html","hash":"123194ca1fbb76c24dc91c1b8c9e9b5d95dce3fb","modified":1479868538071},{"_id":"public/tags/Stack/index.html","hash":"ceddfd9936e0e654b42923bb194b41e9f1684efa","modified":1479868538071},{"_id":"public/tags/栈/index.html","hash":"fce5d55efe26b888d6da1835e3b3c7aa8f5286c3","modified":1479868538072},{"_id":"public/tags/数据结构/index.html","hash":"965cc18ec17bc9cc679a4105f583473942f0d780","modified":1479868538072},{"_id":"public/tags/读书/index.html","hash":"40a4f950dbce1408db9b5dfe7bb09dce66e7f319","modified":1479868538072},{"_id":"public/tags/编程书籍/index.html","hash":"aa2ca90feff46dd21675af79b54854c741a312b2","modified":1479868538072},{"_id":"public/archives/index.html","hash":"2a3be6c96383862703dd4fd5817458be8816161e","modified":1479868538072},{"_id":"public/tags/index.html","hash":"1ead153cc1c2681e7a9281ccdd444d9ac740f358","modified":1479868538072},{"_id":"public/2016/10/28/使用一台Nginx对多台Tomcat实现负载均衡/index.html","hash":"38edb5a6217bb63a50b939b1ce14295a33ff97d8","modified":1479868538072},{"_id":"public/2016/10/09/使用lombok简化Java代码/index.html","hash":"1b2cda8f7d23358d023fa11ae6ccf47d7410fe38","modified":1479868538072},{"_id":"public/2016/09/25/《深入理解Java虚拟机》读书笔记-一/index.html","hash":"a76f02b133ad3decffb76b04145b2d89e9602b08","modified":1479868538072},{"_id":"public/2016/09/12/算法-三-常用数据结构的定义/index.html","hash":"949c0ac3a4487eee41f6180d4d7d3488b08c10c3","modified":1479868538072},{"_id":"public/2016/09/10/算法-二-实现一个getMin功能的栈/index.html","hash":"8b701937c87c70194a2b744a47c937e73ccb3bf9","modified":1479868538072},{"_id":"public/2016/09/10/算法-一-Stack-栈-的实现/index.html","hash":"776960b90f5a226d5f744499180e5549ae381a65","modified":1479868538072},{"_id":"public/2016/09/03/Java内部类详解/index.html","hash":"4040f6c796845fcf3c750fb152dcb9911d17ed94","modified":1479868538072},{"_id":"public/2016/09/02/Java源码分析-一-HashMap/index.html","hash":"fc4faea5705b76968d7a67964066142388ce666a","modified":1479868538072},{"_id":"public/2015/09/02/iOS开发的代码结构/index.html","hash":"a5b89092b02421352d47fb4fb2909247996276ad","modified":1479868538072},{"_id":"public/2015/08/30/UIKit学习总结/index.html","hash":"94aa6e55902e831995b7d2e59a03ca120484dac4","modified":1479868538072},{"_id":"public/2015/08/20/hello-world/index.html","hash":"6997348b79e9497a3a15c7d61a198957a85413cb","modified":1479868538072},{"_id":"public/about/index.html","hash":"a2cc2cdf038356eccd3e86fe2408d392f59998e4","modified":1479868538072},{"_id":"public/index.html","hash":"937001e9054282f4508bf151b20aac1ebe36289b","modified":1479868538073},{"_id":"public/page/2/index.html","hash":"cc5ca0be97f6d52f291ce809b4426c2ca0f53dd3","modified":1479868538073},{"_id":"public/page/3/index.html","hash":"fa2427b64a0f954a10cf9c243bdd20793b67c11c","modified":1479868538073},{"_id":"public/2016/11/16/深入理解Java虚拟机-二/index.html","hash":"1fb87e014f08b7d4f865be738e969362ebb116c6","modified":1479868538094},{"_id":"public/i_dont_wanna_use_default_archives/2016/09/page/2/index.html","hash":"0986dd7cee20e13493068bbd6a076f147f09617a","modified":1479868538094},{"_id":"public/i_dont_wanna_use_default_archives/2016/11/index.html","hash":"d174fd540c6166787c5c8f254650a0d62680511b","modified":1479868538094},{"_id":"public/tags/Java虚拟机/index.html","hash":"997b8a6412acd79f3ebde6402d9f143833835092","modified":1479868538094},{"_id":"public/2016/09/26/《深入理解Java虚拟机》读书笔记（二）/index.html","hash":"ff96dfcdbee71f062cea1f0ba22badbebbb5712c","modified":1479868538094},{"_id":"public/img/favicon.ico","hash":"0dc38229f66a6961e8bd15c9a6b7068633e99105","modified":1479868538104},{"_id":"public/img/avatar.jpg","hash":"4acb0c03fb9dc29b11370be765cbf39019735026","modified":1479868538104},{"_id":"public/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1479868538104},{"_id":"public/img/iOS/gesture.png","hash":"e9cb5df8a023b10ea3228695664dee7388fb1011","modified":1479868538104},{"_id":"public/img/java/collection.png","hash":"5238c7b5d8a772f3112003be3036cd99d6001184","modified":1479868538104},{"_id":"public/img/innerclass/innerclass01.png","hash":"844fb099ae8434bd16dea29cae375b0690721834","modified":1479868538104},{"_id":"public/img/nginx/nginx_06.png","hash":"757a6840a827bf81bbc90d952aa4753d7c890ed3","modified":1479868538104},{"_id":"public/img/nginx/nginx_05.png","hash":"14539589f6da7e78cdc55a0b95cd05f3023f38d9","modified":1479868538104},{"_id":"public/img/nginx/nginx_13.png","hash":"9af3aef09e818bc8737bcf4b7f991f27d061377a","modified":1479868538105},{"_id":"public/img/stack/stack.jpg","hash":"c71a5d7f8932b98c7266a2bd582bcfa244a19a78","modified":1479868538105},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1479868538105},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1479868538105},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1479868538105},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1479868538105},{"_id":"public/2016/09/03/Java内部类详解/innerclass01.png","hash":"844fb099ae8434bd16dea29cae375b0690721834","modified":1479868538105},{"_id":"public/img/java/hashmap1.jpg","hash":"47836575ca6d2d470921fd28747fe912bf8895bc","modified":1479868538105},{"_id":"public/img/java/hashmap2.png","hash":"eec94244213b2d14438e7341021fc4b9b5dd0feb","modified":1479868538105},{"_id":"public/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1479868538431},{"_id":"public/img/iOS/setlayout.png","hash":"39f5211fe0bef287bc22df1d927c01481f44a848","modified":1479868538431},{"_id":"public/img/nginx/nginx_04.png","hash":"4e40e08f9e0823d847f1b273e729b98a82f5cd8c","modified":1479868538435},{"_id":"public/img/lombok/lombok_01.png","hash":"41f725d7b3ca8eac3a8e0e3655520f74dc8d35e8","modified":1479868538435},{"_id":"public/img/iOS/layoutSubviews.png","hash":"b5adfcd2ff790f43065963415a29f6e19b83dc61","modified":1479868538435},{"_id":"public/img/nginx/nginx_10.png","hash":"efcacfa22543f335220290744ed7e732e916ccb7","modified":1479868538435},{"_id":"public/img/nginx/nginx_12.png","hash":"562b28f3b76714dc937af5d2a02b62e0fd0c775d","modified":1479868538435},{"_id":"public/img/nginx/nginx_09.png","hash":"980b21c060edb018967e1570fc76a7bcdc47dc97","modified":1479868538435},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1479868538435},{"_id":"public/css/highlight.css","hash":"8bc5e670b028eda8097f58bdc85269c5124c2951","modified":1479868538440},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1479868538440},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1479868538440},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1479868538440},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1479868538440},{"_id":"public/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1479868538440},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1479868538441},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1479868538441},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1479868538441},{"_id":"public/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1479868538441},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1479868538441},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1479868538441},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1479868538441},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1479868538441},{"_id":"public/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1479868538441},{"_id":"public/img/lombok/lombok_02.png","hash":"c2ad0d9639f0f231919b2340ad346b04db44fab9","modified":1479868538442},{"_id":"public/img/nginx/nginx_11.png","hash":"be44390247df8b2b5f58b1dbef73dbe3c5975e82","modified":1479868538442},{"_id":"public/img/nginx/nginx_15.png","hash":"34c0e30c3b7a5d0fc3813041640139893ea564bd","modified":1479868538442},{"_id":"public/img/nginx/nginx_14.png","hash":"b0fd1f75b70f2c3e413fb961fc977278c80a893f","modified":1479868538442},{"_id":"public/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1479868538449},{"_id":"public/img/iOS/uiview.png","hash":"7be9332a77297de9faed756f8904de8346bdd1c0","modified":1479868538449},{"_id":"public/img/nginx/nginx_02.png","hash":"19f848cb88107a9e286726760ee7bd8b46554a5a","modified":1479868538450},{"_id":"public/img/nginx/nginx_03.png","hash":"a0391110c6d5e75c815d247de277458cff423e25","modified":1479868538450},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1479868538454},{"_id":"public/img/stack/getMinStack.png","hash":"4f313b4c3fab224c1971b1eb821778287f4ad336","modified":1479868538454},{"_id":"public/img/iOS/pch.png","hash":"4b04d9ed6ba87669392ea429ea1611842019dbb9","modified":1479868538454},{"_id":"public/img/nginx/nginx_01.png","hash":"b680d4a8b02b75c99a0982f37b5a1686038e212a","modified":1479868538455},{"_id":"public/img/nginx/nginx_08.png","hash":"40ca2b26c04933216345f179b1deffa37069a592","modified":1479868538504},{"_id":"public/img/nginx/nginx_07.png","hash":"3c8dd1e01f97f5fd6362c4674772f1f9be6aaae0","modified":1479868538504},{"_id":"public/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1479868538544},{"_id":"public/img/bookImg/allbooks.jpeg","hash":"98d94f90211b8d5ba9ac1b20346328d982bc31d5","modified":1479868538550}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2016-09-02T09:46:56.000Z","updated":"2016-08-18T18:07:08.000Z","path":"404.html","title":"","comments":1,"_id":"civubimjr000007fydapmxr4z","content":"","excerpt":"","more":""},{"layout":"archives","title":"Archives","description":"Hey, this is Archives.","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Hey, this is Archives.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2016-09-02T09:46:56.000Z","updated":"2016-08-18T18:07:08.000Z","path":"archives/index.html","comments":1,"_id":"civubimlk000207fya82l26ie","content":"","excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2016-09-02T09:46:57.000Z","updated":"2016-08-18T18:07:08.000Z","path":"tags/index.html","comments":1,"_id":"civubimln000407fyr4kwi2kv","content":"","excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wirte Code, Wirte Life.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>Talk is cheap. Show me the code. -Linus Torvalds\n\n2013年11月来京，开始了北漂生活，从开始的朦朦胧胧到现在略有目标，匠心便是人生的追求。成为一名\"手艺人\"也许是最好的目标。\n\n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wirte Code, Wirte Life.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>Talk is cheap. Show me the code. -Linus Torvalds\n\n2013年11月来京，开始了北漂生活，从开始的朦朦胧胧到现在略有目标，匠心便是人生的追求。成为一名\"手艺人\"也许是最好的目标。\n\n\n\n","updated":"2016-09-09T06:30:07.000Z","path":"about/index.html","_id":"civubimlu000707fyu162alw6","content":"<blockquote>\n<p>Talk is cheap. Show me the code. -Linus Torvalds</p>\n</blockquote>\n<p>2013年11月来京，开始了北漂生活，从开始的朦朦胧胧到现在略有目标，匠心便是人生的追求。成为一名”手艺人”也许是最好的目标。</p>\n","excerpt":"","more":"<blockquote>\n<p>Talk is cheap. Show me the code. -Linus Torvalds</p>\n</blockquote>\n<p>2013年11月来京，开始了北漂生活，从开始的朦朦胧胧到现在略有目标，匠心便是人生的追求。成为一名”手艺人”也许是最好的目标。</p>\n"}],"Post":[{"title":"Java内部类详解","date":"2016-09-03T01:27:47.000Z","_content":"\n## 0.什么是内部类\n> 可以将一个类的定义放在另一个类的内部，这就是内部类。-《Java编程思想》\n\n**让我们先来看一段代码**\n \n```\n    public class InnerClassTest {\n    \t\n    \tpublic class InnerClass{\n    \t\tpublic void innerMethod(){\n    \t\t\tSystem.out.println(\"this is a inner class method\");\n    \t\t}\n    \t}\n    \tpublic static void main(String[] args) {\n    \t\t\n    \t\tInnerClassTest innerClassTest = new InnerClassTest();\n    \t\tInnerClass innerClass = innerClassTest.new InnerClass();\n    \t\tinnerClass.innerMethod();\t\n    \t}\n    \n    }\n```\n \n 上面的代码简单展示了内部类的定义和使用，\n 我们可以查看编译后的文件\n ![](/img/innerclass/innerclass01.png)\n## 1.内部类的种类\n######一般内部类可分为四种：\n* 成员内部类\n* 局部内部类\n* 嵌套内部类\n* 匿名内部类\n\n","source":"_posts/Java内部类详解.md","raw":"---\ntitle: Java内部类详解\ndate: 2016-09-03 09:27:47\ntags:\n\t- Java\n\t- Java内部类\t\n---\n\n## 0.什么是内部类\n> 可以将一个类的定义放在另一个类的内部，这就是内部类。-《Java编程思想》\n\n**让我们先来看一段代码**\n \n```\n    public class InnerClassTest {\n    \t\n    \tpublic class InnerClass{\n    \t\tpublic void innerMethod(){\n    \t\t\tSystem.out.println(\"this is a inner class method\");\n    \t\t}\n    \t}\n    \tpublic static void main(String[] args) {\n    \t\t\n    \t\tInnerClassTest innerClassTest = new InnerClassTest();\n    \t\tInnerClass innerClass = innerClassTest.new InnerClass();\n    \t\tinnerClass.innerMethod();\t\n    \t}\n    \n    }\n```\n \n 上面的代码简单展示了内部类的定义和使用，\n 我们可以查看编译后的文件\n ![](/img/innerclass/innerclass01.png)\n## 1.内部类的种类\n######一般内部类可分为四种：\n* 成员内部类\n* 局部内部类\n* 嵌套内部类\n* 匿名内部类\n\n","slug":"Java内部类详解","published":1,"updated":"2016-09-09T06:02:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlh000107fy7lj7j2of","content":"<h2 id=\"0-什么是内部类\"><a href=\"#0-什么是内部类\" class=\"headerlink\" title=\"0.什么是内部类\"></a>0.什么是内部类</h2><blockquote>\n<p>可以将一个类的定义放在另一个类的内部，这就是内部类。-《Java编程思想》</p>\n</blockquote>\n<p><strong>让我们先来看一段代码</strong></p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">InnerClassTest</span> &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerMethod</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\tSystem.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"this is a inner class method\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) </span>&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tInnerClassTest innerClassTest = <span class=\"keyword\">new</span> InnerClassTest();</div><div class=\"line\">\t\tInnerClass innerClass = innerClassTest.new InnerClass();</div><div class=\"line\">\t\tinnerClass.innerMethod();\t</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 上面的代码简单展示了内部类的定义和使用，<br> 我们可以查看编译后的文件<br> <img src=\"/img/innerclass/innerclass01.png\" alt=\"\"></p>\n<h2 id=\"1-内部类的种类\"><a href=\"#1-内部类的种类\" class=\"headerlink\" title=\"1.内部类的种类\"></a>1.内部类的种类</h2><p>######一般内部类可分为四种：</p>\n<ul>\n<li>成员内部类</li>\n<li>局部内部类</li>\n<li>嵌套内部类</li>\n<li>匿名内部类</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"0-什么是内部类\"><a href=\"#0-什么是内部类\" class=\"headerlink\" title=\"0.什么是内部类\"></a>0.什么是内部类</h2><blockquote>\n<p>可以将一个类的定义放在另一个类的内部，这就是内部类。-《Java编程思想》</p>\n</blockquote>\n<p><strong>让我们先来看一段代码</strong></p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">InnerClassTest</span> &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span>&#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerMethod</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\tSystem.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"this is a inner class method\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) </span>&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tInnerClassTest innerClassTest = <span class=\"keyword\">new</span> InnerClassTest();</div><div class=\"line\">\t\tInnerClass innerClass = innerClassTest.new InnerClass();</div><div class=\"line\">\t\tinnerClass.innerMethod();\t</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 上面的代码简单展示了内部类的定义和使用，<br> 我们可以查看编译后的文件<br> <img src=\"/img/innerclass/innerclass01.png\" alt=\"\"></p>\n<h2 id=\"1-内部类的种类\"><a href=\"#1-内部类的种类\" class=\"headerlink\" title=\"1.内部类的种类\"></a>1.内部类的种类</h2><p>######一般内部类可分为四种：</p>\n<ul>\n<li>成员内部类</li>\n<li>局部内部类</li>\n<li>嵌套内部类</li>\n<li>匿名内部类</li>\n</ul>\n"},{"title":"Java中interface与@interface的区别","date":"2016-10-09T12:54:45.000Z","_content":"\n### interface与@interface的区别\n\ninterface为接口申明\n\n@interface为注解申明","source":"_posts/Java中interface与-interface的区别.md","raw":"---\ntitle: Java中interface与@interface的区别\ndate: 2016-10-09 20:54:45\ntags:\n\t- Java\n\t- 注解\n\t- interface\n---\n\n### interface与@interface的区别\n\ninterface为接口申明\n\n@interface为注解申明","slug":"Java中interface与-interface的区别","published":1,"updated":"2016-10-28T08:22:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlm000307fy61firte0","content":"<h3 id=\"interface与-interface的区别\"><a href=\"#interface与-interface的区别\" class=\"headerlink\" title=\"interface与@interface的区别\"></a>interface与@interface的区别</h3><p>interface为接口申明</p>\n<p>@interface为注解申明</p>\n","excerpt":"","more":"<h3 id=\"interface与-interface的区别\"><a href=\"#interface与-interface的区别\" class=\"headerlink\" title=\"interface与@interface的区别\"></a>interface与@interface的区别</h3><p>interface为接口申明</p>\n<p>@interface为注解申明</p>\n"},{"title":"UIKit学习总结","date":"2015-08-30T14:30:50.000Z","_content":"\n### UIKit  应该是iOS开发中最重的工具包了吧。\n##### 0.关于UIKit中比较重要的类\n\n&nbsp;&nbsp;&nbsp;&nbsp;一定要去官网[UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/index.html#//apple_ref/doc/uid/TP40006955)找最权威的资料。其树形结构已经很直观告诉其中类之间的关系\n\n##### 1.UIWindow\n\n&nbsp;&nbsp;&nbsp;&nbsp;之所以将这个类放在第一位是因为在每个iOS项目的AppDelegate文件中有这么一个成员变量。而且我们还会个它设置一个rootViewController\n\n``` bash\n    self.window.rootViewController = xxViewController\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;而这个window就是指的当前设备的屏幕。就是把viewController中管理的页面数据加载到设备上去。\n\n##### 2.UIViewController\n\n&nbsp;&nbsp;&nbsp;&nbsp;大家都知道iOS开发算是把MVC模式用到了极致，viewController就是管理view的控制器,我们可以在controller中构建页面样式，加载页面数据，做这个页面展示需要做的所有工作，然后把控制器交给window(设备)就好。当然根控制器只能有一个但是我们可以通过控制器之间的切换来示不同的页面。\n\n&nbsp;&nbsp;&nbsp;&nbsp;常见的viewController\n\n ![](/images)\n\n&nbsp;&nbsp;&nbsp;&nbsp;其中红色的框中的controller为常用的视图控制器，当然也可以不是用UIViewController的这个子控制器，直接使用UIViewController然后在其中添加各种view.(其实各种控制器只是默认在在UIViewController中加好了对应的view，实现了对应协议的方法而已）\n\n##### 2.UIView\n&nbsp;&nbsp;&nbsp;&nbsp;图上已经标出几个比较常用的view\n  ![](/img/iOS/uiview.png)\n\n##### 3.UIGestureRecognizer\n&nbsp;&nbsp;&nbsp;&nbsp;关于手势识别的view\n   ![](/img/iOS/gesture.png)\n","source":"_posts/UIKit学习总结.md","raw":"title: UIKit学习总结\ndate: 2015-08-30 22:30:50\ntags: iOS\n---\n\n### UIKit  应该是iOS开发中最重的工具包了吧。\n##### 0.关于UIKit中比较重要的类\n\n&nbsp;&nbsp;&nbsp;&nbsp;一定要去官网[UIKit Framework Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/index.html#//apple_ref/doc/uid/TP40006955)找最权威的资料。其树形结构已经很直观告诉其中类之间的关系\n\n##### 1.UIWindow\n\n&nbsp;&nbsp;&nbsp;&nbsp;之所以将这个类放在第一位是因为在每个iOS项目的AppDelegate文件中有这么一个成员变量。而且我们还会个它设置一个rootViewController\n\n``` bash\n    self.window.rootViewController = xxViewController\n```\n\n&nbsp;&nbsp;&nbsp;&nbsp;而这个window就是指的当前设备的屏幕。就是把viewController中管理的页面数据加载到设备上去。\n\n##### 2.UIViewController\n\n&nbsp;&nbsp;&nbsp;&nbsp;大家都知道iOS开发算是把MVC模式用到了极致，viewController就是管理view的控制器,我们可以在controller中构建页面样式，加载页面数据，做这个页面展示需要做的所有工作，然后把控制器交给window(设备)就好。当然根控制器只能有一个但是我们可以通过控制器之间的切换来示不同的页面。\n\n&nbsp;&nbsp;&nbsp;&nbsp;常见的viewController\n\n ![](/images)\n\n&nbsp;&nbsp;&nbsp;&nbsp;其中红色的框中的controller为常用的视图控制器，当然也可以不是用UIViewController的这个子控制器，直接使用UIViewController然后在其中添加各种view.(其实各种控制器只是默认在在UIViewController中加好了对应的view，实现了对应协议的方法而已）\n\n##### 2.UIView\n&nbsp;&nbsp;&nbsp;&nbsp;图上已经标出几个比较常用的view\n  ![](/img/iOS/uiview.png)\n\n##### 3.UIGestureRecognizer\n&nbsp;&nbsp;&nbsp;&nbsp;关于手势识别的view\n   ![](/img/iOS/gesture.png)\n","slug":"UIKit学习总结","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlt000607fy4kg2ewvg","content":"<h3 id=\"UIKit-应该是iOS开发中最重的工具包了吧。\"><a href=\"#UIKit-应该是iOS开发中最重的工具包了吧。\" class=\"headerlink\" title=\"UIKit  应该是iOS开发中最重的工具包了吧。\"></a>UIKit  应该是iOS开发中最重的工具包了吧。</h3><h5 id=\"0-关于UIKit中比较重要的类\"><a href=\"#0-关于UIKit中比较重要的类\" class=\"headerlink\" title=\"0.关于UIKit中比较重要的类\"></a>0.关于UIKit中比较重要的类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;一定要去官网<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/index.html#//apple_ref/doc/uid/TP40006955\" target=\"_blank\" rel=\"external\">UIKit Framework Reference</a>找最权威的资料。其树形结构已经很直观告诉其中类之间的关系</p>\n<h5 id=\"1-UIWindow\"><a href=\"#1-UIWindow\" class=\"headerlink\" title=\"1.UIWindow\"></a>1.UIWindow</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;之所以将这个类放在第一位是因为在每个iOS项目的AppDelegate文件中有这么一个成员变量。而且我们还会个它设置一个rootViewController</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.window.rootViewController = xxViewController</div></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而这个window就是指的当前设备的屏幕。就是把viewController中管理的页面数据加载到设备上去。</p>\n<h5 id=\"2-UIViewController\"><a href=\"#2-UIViewController\" class=\"headerlink\" title=\"2.UIViewController\"></a>2.UIViewController</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;大家都知道iOS开发算是把MVC模式用到了极致，viewController就是管理view的控制器,我们可以在controller中构建页面样式，加载页面数据，做这个页面展示需要做的所有工作，然后把控制器交给window(设备)就好。当然根控制器只能有一个但是我们可以通过控制器之间的切换来示不同的页面。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;常见的viewController</p>\n<p> <img src=\"/images\" alt=\"\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其中红色的框中的controller为常用的视图控制器，当然也可以不是用UIViewController的这个子控制器，直接使用UIViewController然后在其中添加各种view.(其实各种控制器只是默认在在UIViewController中加好了对应的view，实现了对应协议的方法而已）</p>\n<h5 id=\"2-UIView\"><a href=\"#2-UIView\" class=\"headerlink\" title=\"2.UIView\"></a>2.UIView</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;图上已经标出几个比较常用的view<br>  <img src=\"/img/iOS/uiview.png\" alt=\"\"></p>\n<h5 id=\"3-UIGestureRecognizer\"><a href=\"#3-UIGestureRecognizer\" class=\"headerlink\" title=\"3.UIGestureRecognizer\"></a>3.UIGestureRecognizer</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;关于手势识别的view<br>   <img src=\"/img/iOS/gesture.png\" alt=\"\"></p>\n","excerpt":"","more":"<h3 id=\"UIKit-应该是iOS开发中最重的工具包了吧。\"><a href=\"#UIKit-应该是iOS开发中最重的工具包了吧。\" class=\"headerlink\" title=\"UIKit  应该是iOS开发中最重的工具包了吧。\"></a>UIKit  应该是iOS开发中最重的工具包了吧。</h3><h5 id=\"0-关于UIKit中比较重要的类\"><a href=\"#0-关于UIKit中比较重要的类\" class=\"headerlink\" title=\"0.关于UIKit中比较重要的类\"></a>0.关于UIKit中比较重要的类</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;一定要去官网<a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKit_Framework/index.html#//apple_ref/doc/uid/TP40006955\">UIKit Framework Reference</a>找最权威的资料。其树形结构已经很直观告诉其中类之间的关系</p>\n<h5 id=\"1-UIWindow\"><a href=\"#1-UIWindow\" class=\"headerlink\" title=\"1.UIWindow\"></a>1.UIWindow</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;之所以将这个类放在第一位是因为在每个iOS项目的AppDelegate文件中有这么一个成员变量。而且我们还会个它设置一个rootViewController</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.window.rootViewController = xxViewController</div></pre></td></tr></table></figure>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;而这个window就是指的当前设备的屏幕。就是把viewController中管理的页面数据加载到设备上去。</p>\n<h5 id=\"2-UIViewController\"><a href=\"#2-UIViewController\" class=\"headerlink\" title=\"2.UIViewController\"></a>2.UIViewController</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;大家都知道iOS开发算是把MVC模式用到了极致，viewController就是管理view的控制器,我们可以在controller中构建页面样式，加载页面数据，做这个页面展示需要做的所有工作，然后把控制器交给window(设备)就好。当然根控制器只能有一个但是我们可以通过控制器之间的切换来示不同的页面。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;常见的viewController</p>\n<p> <img src=\"/images\" alt=\"\"></p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其中红色的框中的controller为常用的视图控制器，当然也可以不是用UIViewController的这个子控制器，直接使用UIViewController然后在其中添加各种view.(其实各种控制器只是默认在在UIViewController中加好了对应的view，实现了对应协议的方法而已）</p>\n<h5 id=\"2-UIView\"><a href=\"#2-UIView\" class=\"headerlink\" title=\"2.UIView\"></a>2.UIView</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;图上已经标出几个比较常用的view<br>  <img src=\"/img/iOS/uiview.png\" alt=\"\"></p>\n<h5 id=\"3-UIGestureRecognizer\"><a href=\"#3-UIGestureRecognizer\" class=\"headerlink\" title=\"3.UIGestureRecognizer\"></a>3.UIGestureRecognizer</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;关于手势识别的view<br>   <img src=\"/img/iOS/gesture.png\" alt=\"\"></p>\n"},{"title":"Java源码分析(一)-HashMap","date":"2016-09-02T08:55:34.000Z","_content":"\n参考文章：[ java源码分析 ---- HashMap源码分析 及其 实现原理分析](http://blog.csdn.net/pandajava/article/details/42391733)\n\nHashMap 在java集合中来说算是比较重要的一个类了。其源码也是在面试过程中经常被问的一道面试题。之前自己也大略的看过，现在抱着一起学习的态度，分析一下HashMap的源码。\n\n### 0. 所处位置\n学过Java集合的人都应该看过张图(《Java编程思想》关于容器类库的简介图)\n ![](/img/java/collection.png)\n\n### 1. HashMap的数据结构\n数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。\n数组\n数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；\n链表\n链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。\n哈希表\n那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。\n　　哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：\n\n\n\n\n　　从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。\n比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。\n　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。\n　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。\n    /**\n     * The table, resized as necessary. Length MUST Always be a power of two.\n     */\n    transient Entry[] table;\n\n### 2. HashMap源码分析\n HashMap继承自AbstractMap，实现了Map接口（这些内容可以参考《Java集合类》）。来看类的定义。\n \n```\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable\n```\n    Map接口定义了所有Map子类必须实现的方法。Map接口中还定义了一个内部接口Entry。\n\n    AbstractMap也实现了Map接口，并且提供了两个实现Entry的内部类：SimpleEntry和SimpleImmutableEntry。\n\n    定义了接口，接口中又有内部接口，然后有搞了个抽象类实现接口，抽象类里面又搞了两个内部类实现接口的内部接口，有没有点绕，为什么搞成这样呢？先不管了，先看HashMap吧。\n\n    HashMap中定义的属性（应该都能看明白，不过还是解释一下）：\n    \n```\n  /**\n       * 默认的初始容量，必须是2的幂。\n       */\n      static final int DEFAULT_INITIAL_CAPACITY = 16;\n      /**\n       * 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）\n       */\n      static final int MAXIMUM_CAPACITY = 1 << 30;\n      /**\n      * 默认装载因子，这个后面会做解释\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n     /**\n      * 存储数据的Entry数组，长度是2的幂。看到数组的内容了，接着看数组中存的内容就明白为什么博文开头先复习数据结构了\n      */\n     transient Entry[] table;\n     /**\n      * map中保存的键值对的数量\n      */\n     transient int size;\n     /**\n      * 需要调整大小的极限值（容量*装载因子）\n      */\n     int threshold;\n     /**\n      *装载因子\n      */\n     final float loadFactor;\n    /**\n      * map结构被改变的次数\n      */\n     transient volatile int modCount;\n\n```\n接着是HashMap的构造方法。\n    \n```\n/**\n     *使用默认的容量及装载因子构造一个空的HashMap\n     */\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);//计算下次需要调整大小的极限值\n        table = new Entry[DEFAULT_INITIAL_CAPACITY];    //根据默认容量（16）初始化table\n        init();\n    }\n/**\n     * 根据给定的初始容量的装载因子创建一个空的HashMap\n     * 初始容量小于0或装载因子小于等于0将报异常 \n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)//调整最大容量\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        int capacity = 1;\n        //设置capacity为大于initialCapacity且是2的幂的最小值\n        while (capacity < initialCapacity)  // 假设initialCapacity的值为30 则capacity的值 最终问2的5次方 32 。\n            capacity <<= 1;                 //也就是说hashMap中entry[] 的初始化大小是32 而非30。\n        this.loadFactor = loadFactor;\n        threshold = (int)(capacity * loadFactor);\n        table = new Entry[capacity];\n        init();\n    }\n/**\n     *根据指定容量创建一个空的HashMap\n     */\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);//调用上面的构造方法，容量为指定的容量，装载因子是默认值\n    }\n/**\n     *通过传入的map创建一个HashMap，容量为默认容量（16）和(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，装载因子为默认值\n     */\n    public HashMap(Map<? extends K, ? extends V> m) {\n        //调用构造方法 传入相关参数 并完成初始化\n        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);\n       \n        putAllForCreate(m);\n    }  \n```\n上面的构造方法中调用到了init()方法，最后一个方法还调用了\n\n```\nputAllForCreate(Map<? extends K, ? extends V> m)。\n```\ninit方法是一个空方法，里面没有任何内容。（其作用为何？）\nputAllForCreate看方法名就是创建的时候将传入的map全部放入新创建的对象中。该方法中还涉及到其他方法，将在后面介绍。\n\n```\nprivate void putAllForCreate(Map<? extends K, ? extends V> m) {  \n      for (<strong>Iterator<? extends Map.Entry<? extends K, ? extends V>> i =<u> m.entrySet().iterator()</u>; i.hasNext();</strong> ) {  \n          <strong>Map.Entry<? extends K, ? extends V> e = i.next();</strong>  \n          <u>putForCreate(e.getKey(), e.getValue());</u>  \n      }  \n  }\n  \n``` \n  \n先看初始化table时均使用了Entry，这是HashMap的一个内部类，实现了Map接口的内部接口Entry。下面给出Map.Entry接口及HashMap.Entry类的内容。Map.Entry接口定义的方法\n    \n```\n K getKey();//获取Key\n V getValue();//获取Value\n V setValue();//设置Value，至于具体返回什么要看具体实现\n boolean equals(Object o);//定义equals方法用于判断两个Entry是否相同\n int hashCode();//定义获取hashCode的方法\n\n```\n HashMap.Entry类的具体实现\n\n```\n  static class Entry<K,V> implements Map.Entry<K,V> {\n          final K key;\n          V value;\n          Entry<K,V> next;//对下一个节点的引用（看到链表的内容，结合定义的Entry数组，是不是想到了哈希表的拉链法实现？！）\n          final int hash;//哈希值\n  \n          Entry(int h, K k, V v, Entry<K,V> n) {\n              value = v;\n              next = n;\n             key = k;\n             hash = h;\n         }\n \n         public final K getKey() {\n             return key;\n         }\n \n         public final V getValue() {\n             return value;\n         }\n \n         public final V setValue(V newValue) {\n             V oldValue = value;\n            value = newValue;\n             return oldValue;//返回的是之前的Value\n         }\n \n         public final boolean equals(Object o) {\n             if (!(o instanceof Map.Entry))//先判断类型是否一致\n                    return false;\n             Map.Entry e = (Map.Entry)o;\n             Object k1 = getKey();\n             Object k2 = e.getKey();\n             // Key相等且Value相等则两个Entry相等\n             if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n                 Object v1 = getValue();\n                 Object v2 = e.getValue();\n                 if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                     return true;\n             }\n             return false;\n         }\n         // hashCode是Key的hashCode和Value的hashCode的异或的结果\n         public final int hashCode() {\n             return (key==null   ? 0 : key.hashCode()) ^\n                   (value==null ? 0 : value.hashCode());\n         }\n         // 重写toString方法，是输出更清晰\n         public final String toString() {\n             return getKey() + \"=\" + getValue();\n        }\n \n        /**\n          *当调用put(k,v)方法存入键值对时，如果k已经存在，则该方法被调用（为什么没有内容？）\n          */\n        void recordAccess(HashMap<K,V> m) {\n        }\n\n        /**\n          * 当Entry被从HashMap中移除时被调用（为什么没有内容？）\n          */\n         void recordRemoval(HashMap<K,V> m) {\n         }\n     }\n```\n看完属性和构造方法，接着看HashMap中的其他方法，一个个分析，从最常用的put和get说起吧。\nput()该方法 返回与 key 关联的旧值；如果key 没有任何映射关系，则返回null。\n     \n```\n  public V put(K key, V value) {\n          if (key == null)\n              return putForNullKey(value);\n\n          int hash = hash(key.hashCode());\n          int i = indexFor(hash, table.length);  //获取应该存放的索引值\n\n          for (Entry<K,V> e = table[i]; e != null; e = e.next) {  //校验key值之前是否存在，存在则替换并返回先前的值\n             Object k;\n             if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                 V oldValue = e.value;\n                 e.value = value;\n                 e.recordAccess(this);\n                 return oldValue;\n             }\n         }\n\n         // 该key之前不存在 则 执行 添加操作\n         modCount++;\n         addEntry(hash, key, value, i);   //四个参数 hash值  key  value  i索引\n         return null;\n     }\n    当存入的key是null的时候将调用putForNUllKey方法，暂时将这段逻辑放一边，看key不为null的情况。\n\n```\n先调用了hash(int h)方法获取了一个hash值。\n    \n```\n static int hash(int h) {\n         // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n         // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n         return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n```\n这个方法的主要作用是防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占4个字节，即32位。根据这32位值进行移位、异或运算得到一个值。\n\n```\n static int indexFor(int h, int length) {\n         return h & (length-1);\n     }\n```\nindexFor返回hash值和table数组长度减1的与运算结果，获取索引位置。\n为什么使用的是length-1？因为这样可以保证结果的最大值是length-1，不会产生数组越界问题。获取索引位置之后做了什么？探测table[i]所在的链表，所发现key值与传入的key值相同的对象，则替换并返回oldValue。（key值之前存在，替换并且返回旧值）若找不到，则通过addEntry(hash,key,value,i)添加新的对象。 （key值之前不存在，添加addEntry方法 ，并返回null）\n\n来看addEntry(hash,key,value,i)方法。\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n         Entry<K,V> e = table[bucketIndex];   //bucketIndex位置的元素先保存起来（新加的entry要占据这个位置）\n         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);//将新的值存到bucketIndex处，该值的next指向 刚刚保存的e元素\n         //检测是不是需要扩充容量 （2倍2倍的扩容）\n          if (size++ >= threshold)   // threshold默认值 是  16 * 0.75 = 12             resize(2 * table.length);\n  }\n```\n这就是在一个链表头部插入一个节点的过程。获取table[i]的对象e，将table[i]的对象修改为新增对象，让新增对象的next指向e。之后判断size是否到达了需要扩充table数组容量的界限并让size自增1，如果达到了则调用resize(int capacity)方法将数组容量拓展为原来的两倍。\n\n```\n void resize(int newCapacity) {\n          Entry[] oldTable = table;\n          int oldCapacity = oldTable.length;\n          // 这个if块表明，如果容量已经到达允许的最大值，即MAXIMUN_CAPACITY，则不再拓展容量，而将装载拓展的界限值设为计算机允许的最大值。\n         // 不会再触发resize方法，而是不断的向map中添加内容，即table数组中的链表可以不断变长，但数组长度不再改变\n         if (oldCapacity == MAXIMUM_CAPACITY) {  //MAXIMUM_CAPACITY  1073741824 [0x40000000]\n             threshold = Integer.MAX_VALUE;\n             return;\n          }\n         // 创建新数组，容量为指定的容量\n         Entry[] newTable = new Entry[newCapacity];\n         transfer(newTable);\n         table = newTable;\n         // 设置下一次需要调整数组大小的界限\n         threshold = (int)(newCapacity * loadFactor);\n     }\n```\n 结合上面给出的注释，调整数组容量的内容仅剩下将原table中的内容复制到newTable中并将newTable赋值给给table变量。即上面代码中的“transfer(newTable);table = newTable;”。\n来看transfer(Entry[] newTable)方法。\n\n```\n  void transfer(Entry[] newTable) {\n          // 保留原数组的引用到src中，\n          Entry[] src = table;\n          // 新容量使新数组的长度\n          int newCapacity = newTable.length;\n          // 遍历原数组\n         for (int j = 0; j < src.length; j++) {\n              // 获取元素e （此处的e是单链表的头结点）\n              Entry<K,V> e = src[j];\n             if (e != null) {\n                 // 将原数组中的元素置为null\n                 src[j] = null;\n                 // 遍历原数组中j位置指向的链表\n                 do {\n                     Entry<K,V> next = e.next;\n                     // 根据新的容量计算e在新数组中的位置\n                     int i = indexFor(e.hash, newCapacity);\n                     // 将e插入到newTable[i]指向的链表的头部\n                     e.next = newTable[i];\n                     newTable[i] = e;\n                    e = next;\n                 } while (e != null);\n             }\n         }\n     }\n```\n\n这样处理效果 原来的 单链表如果 顺序是  （头） a b c d e  （尾）通过  transfer方法之后的顺序是  (头)  e  d c  b a （尾）  因为后插入的在 链表的头部。从上面的代码可以看出，HashMap之所以不能保持元素的顺序有以下几点原因：\n\n    第一，插入元素的时候对元素进行哈希处理，不同元素分配到table的不同位置；\n    第二，容量拓展的时候又进行了hash处理；\n    第三，复制原表内容的时候链表被倒置。\n\n一个put方法带出了这么多内容，接着看看putAll吧。\n\n```\n  public void putAll(Map<? extends K, ? extends V> m) {\n          int numKeysToBeAdded = m.size();\n          if (numKeysToBeAdded == 0)\n              return;\n          // 为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)>threshold???\n         if (numKeysToBeAdded > threshold) {\n              int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);\n              if (targetCapacity > MAXIMUM_CAPACITY)\n                 targetCapacity = MAXIMUM_CAPACITY;\n             int newCapacity = table.length;\n             while (newCapacity < targetCapacity)\n                 newCapacity <<= 1;\n             if (newCapacity > table.length)\n                 resize(newCapacity);\n         }\n \n         for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n            Map.Entry<? extends K, ? extends V> e = i.next();\n             put(e.getKey(), e.getValue());\n         }\n     }\n```\n\n先回答上面的问题：为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)>threshold \n这是一种保守的做法，明显地，我们应该在(numKeysToBeAdded+table.length)>threshold的时候去拓展容量，但是考虑到将被添加的元素可能会有Key与原本存在的Key相同的情况，所以采用保守的做法，避免拓展到过大的容量。 接着是遍历m中的内容，然后调用put方法将元素添加到table数组中。遍历的时候涉及到了entrySet方法，这个方法定义在Map接口中，HashMap中也有实现，后面会解释HashMap的这个方法，其它Map的实现暂不解释。\n\n\t下面介绍在put方法中被调用到的putForNullKey方法。\n\n```\n\n private V putForNullKey(V value) {\n         for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n             if (e.key == null) {\n                 V oldValue = e.value;\n                 e.value = value;\n                 e.recordAccess(this);\n                  return oldValue;\n             }\n         }\n         modCount++;\n         addEntry(0, null, value, 0); // null 的 hash值是0 。 索引位置 index也是 0\n        return null;\n     }\n```\n\n这是一个私有方法，在put方法中被调用。它首先遍历table数组，如果找到key为null的元素，则替换元素值并返回oldValue；否则通过addEntry方法添加元素，之后返回null。还记得上面构造方法中调用到的putAllForCreate吗？一口气将put操作的方法看完吧。\n\n```\n private void putAllForCreate(Map<? extends K, ? extends V> m) {\n         for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n             Map.Entry<? extends K, ? extends V> e = i.next();\n             putForCreate(e.getKey(), e.getValue());\n         }\n     }\n```\n先将遍历的过程放在一边，因为它同样涉及到了entrySet()方法。剩下的代码很简单，只是调用putForCreate方法逐个元素加入。\n\n```\n private void putForCreate(K key, V value) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          int i = indexFor(hash, table.length);\n          for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n              Object k;\n              if (e.hash == hash &&\n                  ((k = e.key) == key || (key != null && key.equals(k)))) {\n                  e.value = value;\n                  return;\n             }\n         }\n         createEntry(hash, key, value, i);\n     }\n```\n     \n 该方法先计算需要添加的元素的hash值和在table数组中的索引i。接着遍历table[i]的链表，若有元素的key值与传入key值相等，则替换value，       结束方法。若不存在key值相同的元素，则调用createEntry创建并添加元素。\n\n```\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n          Entry<K,V> e = table[bucketIndex];\n         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n         size++;\n     }\n```\n\n这个方法的内容就不解释了，上面都解释过。 至此所有put相关操作都解释完毕了。put之外，另一个常用的操作就是get，下面就来看get方法。\n\n```\n public V get(Object key) {\n          if (key == null)\n              return getForNullKey();\n          int hash = hash(key.hashCode());\n          for (Entry<K,V> e = table[indexFor(hash, table.length)];e != null; e = e.next) {\n              Object k;\n              if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n                 return e.value;\n         }\n         return null;\n     }\n ```\n     \n 该方法分为key为null和不为null两块。先看不为null的情况。先获取key的hash值，之后通过hash值及table.length获取key对应的table数组的索引，遍历索引的链表，所找到key相同的元素，则返回元素的value，否者返回null。不为null的情况调用了getForNullKey()方法。\n\n1 private V getForNullKey() {\n2         for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n3             if (e.key == null)\n4                 return e.value;\n5         }\n6         return null;\n7     }\n    这是一个私有方法，只在get中被调用。该方法判断table[0]中的链表是否包含key为null的元素，包含则返回value，不包含则返回null。为什么是遍历table[0]的链表？因为key为null的时候获得的hash值都是0。\n添加（put）和获取（get）都结束了，接着看如何判断一个元素是否存在。\nHashMap没有提供判断元素是否存在的方法，只提供了判断Key是否存在及Value是否存在的方法，分别是containsKey(Object key)、containsValue(Object value)。\ncontainsKey(Object key)方法很简单，只是判断getEntry(key)的结果是否为null，是则返回false，否返回true。\n\n```\n public boolean containsKey(Object key) {\n          return getEntry(key) != null;\n      }\n  final Entry<K,V> getEntry(Object key) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) {\n              Object k;\n             if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))\n                 return e;\n         }\n         return null;\n     }\n```\ngetEntry(Object key)也没什么内容，只是根据key对应的hash值计算在table数组中的索引位置，然后遍历该链表判断是否存在相同的key值。\n\n```\n\n  public boolean containsValue(Object value) {\n      if (value == null)\n              return containsNullValue();\n  \n      Entry[] tab = table;\n          for (int i = 0; i < tab.length ; i++)\n              for (Entry e = tab[i] ; e != null ; e = e.next)\n                  if (value.equals(e.value))\n                      return true;\n     return false;\n     }\n private boolean containsNullValue() {\n     Entry[] tab = table;\n         for (int i = 0; i < tab.length ; i++)\n             for (Entry e = tab[i] ; e != null ; e = e.next)\n                 if (e.value == null)\n                     return true;\n     return false;\n     }\n```\n\n判断一个value是否存在比判断key是否存在还要简单，就是遍历所有元素判断是否有相等的值。这里分为两种情况处理，value为null何不为null的情况，但内容差不多，只是判断相等的方式不同。这个判断是否存在必须遍历所有元素，是一个双重循环的过程，因此是比较耗时的操作。接着看HashMap中“删除”相关的操作，有remove(Object key)和clear()两个方法。\n\n    remove(Object key)\n\n```\npublic V remove(Object key) {\n         Entry<K,V> e = removeEntryForKey(key);\n         return (e == null ? null : e.value);\n     }\n```\n\n看这个方法，removeEntryKey(key)的返回结果应该是被移除的元素，如果不存在这个元素则返回为null。remove方法根据removeEntryKey返回的结果e是否为null返回null或e.value。\n\n    removeEntryForKey(Object key)\n```\n  final Entry<K,V> removeEntryForKey(Object key) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          int i = indexFor(hash, table.length);\n          Entry<K,V> prev = table[i];\n          Entry<K,V> e = prev;\n  \n          while (e != null) {\n              Entry<K,V> next = e.next;\n              Object k;\n             if (e.hash == hash &&\n                 ((k = e.key) == key || (key != null && key.equals(k)))) {\n                 modCount++;\n                 size--;\n                 if (prev == e)\n                     table[i] = next;\n                 else\n                     prev.next = next;\n                 e.recordRemoval(this);\n                 return e;\n             }\n             prev = e;\n             e = next;\n         }\n \n         return e;\n     }\n\n```\n    上面的这个过程就是先找到table数组中对应的索引，接着就类似于一般的链表的删除操作，而且是单向链表删除节点，很简单。在C语言中就是修改指针，这个例子中就是将要删除节点的前一节点的next指向删除被删除节点的next即可。\n\nclear()\n\n```\n public void clear() {\n         modCount++;\n         Entry[] tab = table;\n         for (int i = 0; i < tab.length; i++)\n             tab[i] = null;\n         size = 0;\n    }\n```\n\nclear()方法删除HashMap中所有的元素，这里就不用一个个删除节点了，而是直接将table数组内容都置空，这样所有的链表都已经无法访问，Java的垃圾回收机制会去处理这些链表。table数组置空后修改size为0。这里为什么不直接操作table而是通过tab呢？希望有知道的大侠指点一二。主要方法看的差不多了，接着看一个上面提到了好几次但是都搁在一边没有分析的方法：entrySet()。 \n\nentrySet()\n\n```\n\tpublic Set<Map.Entry<K,V>> entrySet() {\n     return entrySet0();\n   }\n \n    private Set<Map.Entry<K,V>> entrySet0() {\n         Set<Map.Entry<K,V>> es = entrySet;\n         return es != null ? es : (entrySet = new EntrySet());\n    }\n```\n\n为什么会有这样的方法，只是调用了一下entrySet0，而且entrySet0的名称看着就很奇怪。再看entrySet0方法中为什么不直接return entrySet!=null?entrySet:(entrySet = new EntrySet)呢？上面的疑问还没解开，但是先看entrySet这个属性吧，在文章开头的属性定义中并没有给出这个属性，下面先看一下它的定义：\n\n```\nprivate transient Set<Map.Entry<K,V>> entrySet = null;\n\n```\n它是一个内容为Map.Entry<K,V>的Set。看看在哪些地方往里面添加了元素。 为什么上面的那句话我要把它标成红色？因为这是一个陷阱，在看代码的时候我就陷进去了。仔细看EntrySet这个类。\n\n```\n\nprivate final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n         public Iterator<Map.Entry<K,V>> iterator() {\n             return new EntryIterator();\n         }\n         public boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                 return false;\n             Map.Entry<K,V> e = (Map.Entry<K,V>) o;\n             Entry<K,V> candidate = getEntry(e.getKey());\n             return candidate != null && candidate.equals(e);\n         }\n         public boolean remove(Object o) {\n             return removeMapping(o) != null;\n         }\n         public int size() {\n             return size;\n         }\n         public void clear() {\n             HashMap.this.clear();\n         }\n }\n\n```\n看到了什么？这个类根本就没属性，它只是个代理。因为它内部类，可以访问外部类的内容，debug的时候能看到的属性都是继承或者外部类的属性，输出的时候其实也是调用到了父类的toString方法将HashMap中的内容输出了。\n\n    keySet()\n\n1 public Set<K> keySet() {\n2         Set<K> ks = keySet;\n3         return (ks != null ? ks : (keySet = new KeySet()));\n4     }\n    是不是和entrySet0()方法很像！\n\n 1 private final class KeySet extends AbstractSet<K> {\n 2         public Iterator<K> iterator() {\n 3             return newKeyIterator();\n 4         }\n 5         public int size() {\n 6             return size;\n 7         }\n 8         public boolean contains(Object o) {\n 9             return containsKey(o);\n10         }\n11         public boolean remove(Object o) {\n12             return HashMap.this.removeEntryForKey(o) != null;\n13         }\n14         public void clear() {\n15             HashMap.this.clear();\n16         }\n17     }\n复制代码\n    同样是个代理类，contains、remove、clear方法都是调用的HashMap的方法。 \n\n \n\n    values()\n\n 1 public Collection<V> values() {\n 2         Collection<V> vs = values;\n 3         return (vs != null ? vs : (values = new Values()));\n 4     }\n 5 \n 6     private final class Values extends AbstractCollection<V> {\n 7         public Iterator<V> iterator() {\n 8             return newValueIterator();\n 9         }\n10         public int size() {\n11             return size;\n12         }\n13         public boolean contains(Object o) {\n14             return containsValue(o);\n15         }\n16         public void clear() {\n17             HashMap.this.clear();\n18         }\n19     }\n    values()方法也一样是代理。只是Values类继承自AbstractCollention类，而不是AbstractSet。\n\n--------------------------------------------------------------------------------------------------------------------\n\n1. HashMap概述：\n\n　　HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\n\n2. HashMap的数据结构：\n\n　　在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。\n\n\n\n　　从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：\n\n/**\n * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\n\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    final int hash;\n    ……\n}\n　　可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。\n\n3.    HashMap的存取实现：\n\n  1) 存储：\n\npublic V put(K key, V value) {\n    // HashMap允许存放null键和null值。\n    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。\n    if (key == null)\n        return putForNullKey(value);\n    // 根据key的hashCode重新计算hash值。\n    int hash = hash(key.hashCode());\n    // 搜索指定hash值所对应table中的索引。\n    int i = indexFor(hash, table.length);\n    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    // 如果i索引处的Entry为null，表明此处还没有Entry。\n    // modCount记录HashMap中修改结构的次数\n    modCount++;\n    // 将key、value添加到i索引处。\n    addEntry(hash, key, value, i);\n    return null;\n}\n　　从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。\n\n　　addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    // 获取指定 bucketIndex 索引处的 Entry \n    Entry<K,V> e = table[bucketIndex];\n    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry\n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n    // 如果 Map 中的 key-value 对的数量超过了极限\n    if (size++ >= threshold)\n    // 把 table 对象的长度扩充到原来的2倍。\n        resize(2 * table.length);\n}\n　　当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。\n\n　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。\n\nstatic int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n　　我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。\n\n　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：\n\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n　　这个方法非常巧妙，它通过 h & (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：\n\nint capacity = 1;\n    while (capacity < initialCapacity)\n        capacity <<= 1;\n　　这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。\n\n　　当length总是 2 的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n　　这看上去很简单，其实比较有玄机的，我们举个例子来说明：\n\n　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&运算后的结果如下：\n\n       h & (table.length-1)                     hash                             table.length-1\n\n       8 & (15-1)：                                 0100                   &              1110                   =                0100\n\n       9 & (15-1)：                                 0101                   &              1110                   =                0100\n\n      -----------------------------------------------------------------------------------------------------------------------\n\n       8 & (16-1)：                                 0100                   &              1111                   =                0100\n\n       9 & (16-1)：                                 0101                   &              1111                   =                0101\n\n      -----------------------------------------------------------------------------------------------------------------------\n\n　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！\n\n　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。\n\n　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。\n\n　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。\n\n  2) 读取：\n\npublic V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    int hash = hash(key.hashCode());\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n        e != null;\n        e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n            return e.value;\n    }\n    return null;\n}\n　　有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。\n\n  3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n4. HashMap的resize（rehash）：\n\n　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。\n\n　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。\n\nHashMap扩容的代码如下所示：\n\n//HashMap数组扩容\n          void resize(int newCapacity) {\n                Entry[] oldTable = table;\n                int oldCapacity = oldTable.length;\n                //如果当前的数组长度已经达到最大值，则不在进行调整\n                if (oldCapacity == MAXIMUM_CAPACITY) {\n                    threshold = Integer.MAX_VALUE;\n                    return;\n                }\n                //根据传入参数的长度定义新的数组\n                Entry[] newTable = new Entry[newCapacity];\n                //按照新的规则，将旧数组中的元素转移到新数组中\n                transfer(newTable);\n                table = newTable;\n                //更新临界值\n                threshold = (int)(newCapacity * loadFactor);\n            }\n\n          //旧数组中元素往新数组中迁移\n            void transfer(Entry[] newTable) {\n                //旧数组\n                Entry[] src = table;\n                //新数组长度\n                int newCapacity = newTable.length;\n                //遍历旧数组\n                for (int j = 0; j < src.length; j++) {\n                    Entry<K,V> e = src[j];\n                    if (e != null) {\n                        src[j] = null;\n                        do {\n                            Entry<K,V> next = e.next;\n                            int i = indexFor(e.hash, newCapacity);\n                            e.next = newTable[i];\n                            newTable[i] = e;\n                            e = next;\n                        } while (e != null);\n                    }\n                }\n            }\n5.HashMap的性能参数：\n\nHashMap 包含如下几个构造器：\n\n   HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。\n   HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。\n   HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。    initialCapacity：HashMap的最大容量，即为底层数组的长度。 loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。\n　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。\n\n　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：\n\nthreshold = (int)(capacity * loadFactor);  \n　　结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：\n\nif (size++ >= threshold)   \n    resize(2 * table.length); \n6.Fail-Fast机制：\n\n　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）\n\n　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。\n\nHashIterator() {\n    expectedModCount = modCount;\n    if (size > 0) { // advance to first entry\n    Entry[] t = table;\n    while (index < t.length && (next = t[index++]) == null)\n        ;\n    }\n}\n　　在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：\n\n　　注意到modCount声明为volatile，保证线程之间修改的可见性。\n\n    （volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。\n\nfinal Entry<K,V> nextEntry() {   \n    if (modCount != expectedModCount)   \n        throw new ConcurrentModificationException();\n在HashMap的API中指出：\n\n　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。\n\n　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。","source":"_posts/Java源码分析-一-HashMap.md","raw":"---\ntitle: Java源码分析(一)-HashMap\ndate: 2016-09-02 16:55:34\ntags:\n - Java\n\n---\n\n参考文章：[ java源码分析 ---- HashMap源码分析 及其 实现原理分析](http://blog.csdn.net/pandajava/article/details/42391733)\n\nHashMap 在java集合中来说算是比较重要的一个类了。其源码也是在面试过程中经常被问的一道面试题。之前自己也大略的看过，现在抱着一起学习的态度，分析一下HashMap的源码。\n\n### 0. 所处位置\n学过Java集合的人都应该看过张图(《Java编程思想》关于容器类库的简介图)\n ![](/img/java/collection.png)\n\n### 1. HashMap的数据结构\n数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。\n数组\n数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；\n链表\n链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。\n哈希表\n那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。\n　　哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：\n\n\n\n\n　　从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。\n比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。\n　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。\n　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。\n    /**\n     * The table, resized as necessary. Length MUST Always be a power of two.\n     */\n    transient Entry[] table;\n\n### 2. HashMap源码分析\n HashMap继承自AbstractMap，实现了Map接口（这些内容可以参考《Java集合类》）。来看类的定义。\n \n```\npublic class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable\n```\n    Map接口定义了所有Map子类必须实现的方法。Map接口中还定义了一个内部接口Entry。\n\n    AbstractMap也实现了Map接口，并且提供了两个实现Entry的内部类：SimpleEntry和SimpleImmutableEntry。\n\n    定义了接口，接口中又有内部接口，然后有搞了个抽象类实现接口，抽象类里面又搞了两个内部类实现接口的内部接口，有没有点绕，为什么搞成这样呢？先不管了，先看HashMap吧。\n\n    HashMap中定义的属性（应该都能看明白，不过还是解释一下）：\n    \n```\n  /**\n       * 默认的初始容量，必须是2的幂。\n       */\n      static final int DEFAULT_INITIAL_CAPACITY = 16;\n      /**\n       * 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）\n       */\n      static final int MAXIMUM_CAPACITY = 1 << 30;\n      /**\n      * 默认装载因子，这个后面会做解释\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n     /**\n      * 存储数据的Entry数组，长度是2的幂。看到数组的内容了，接着看数组中存的内容就明白为什么博文开头先复习数据结构了\n      */\n     transient Entry[] table;\n     /**\n      * map中保存的键值对的数量\n      */\n     transient int size;\n     /**\n      * 需要调整大小的极限值（容量*装载因子）\n      */\n     int threshold;\n     /**\n      *装载因子\n      */\n     final float loadFactor;\n    /**\n      * map结构被改变的次数\n      */\n     transient volatile int modCount;\n\n```\n接着是HashMap的构造方法。\n    \n```\n/**\n     *使用默认的容量及装载因子构造一个空的HashMap\n     */\n    public HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);//计算下次需要调整大小的极限值\n        table = new Entry[DEFAULT_INITIAL_CAPACITY];    //根据默认容量（16）初始化table\n        init();\n    }\n/**\n     * 根据给定的初始容量的装载因子创建一个空的HashMap\n     * 初始容量小于0或装载因子小于等于0将报异常 \n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)//调整最大容量\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        int capacity = 1;\n        //设置capacity为大于initialCapacity且是2的幂的最小值\n        while (capacity < initialCapacity)  // 假设initialCapacity的值为30 则capacity的值 最终问2的5次方 32 。\n            capacity <<= 1;                 //也就是说hashMap中entry[] 的初始化大小是32 而非30。\n        this.loadFactor = loadFactor;\n        threshold = (int)(capacity * loadFactor);\n        table = new Entry[capacity];\n        init();\n    }\n/**\n     *根据指定容量创建一个空的HashMap\n     */\n    public HashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);//调用上面的构造方法，容量为指定的容量，装载因子是默认值\n    }\n/**\n     *通过传入的map创建一个HashMap，容量为默认容量（16）和(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，装载因子为默认值\n     */\n    public HashMap(Map<? extends K, ? extends V> m) {\n        //调用构造方法 传入相关参数 并完成初始化\n        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);\n       \n        putAllForCreate(m);\n    }  \n```\n上面的构造方法中调用到了init()方法，最后一个方法还调用了\n\n```\nputAllForCreate(Map<? extends K, ? extends V> m)。\n```\ninit方法是一个空方法，里面没有任何内容。（其作用为何？）\nputAllForCreate看方法名就是创建的时候将传入的map全部放入新创建的对象中。该方法中还涉及到其他方法，将在后面介绍。\n\n```\nprivate void putAllForCreate(Map<? extends K, ? extends V> m) {  \n      for (<strong>Iterator<? extends Map.Entry<? extends K, ? extends V>> i =<u> m.entrySet().iterator()</u>; i.hasNext();</strong> ) {  \n          <strong>Map.Entry<? extends K, ? extends V> e = i.next();</strong>  \n          <u>putForCreate(e.getKey(), e.getValue());</u>  \n      }  \n  }\n  \n``` \n  \n先看初始化table时均使用了Entry，这是HashMap的一个内部类，实现了Map接口的内部接口Entry。下面给出Map.Entry接口及HashMap.Entry类的内容。Map.Entry接口定义的方法\n    \n```\n K getKey();//获取Key\n V getValue();//获取Value\n V setValue();//设置Value，至于具体返回什么要看具体实现\n boolean equals(Object o);//定义equals方法用于判断两个Entry是否相同\n int hashCode();//定义获取hashCode的方法\n\n```\n HashMap.Entry类的具体实现\n\n```\n  static class Entry<K,V> implements Map.Entry<K,V> {\n          final K key;\n          V value;\n          Entry<K,V> next;//对下一个节点的引用（看到链表的内容，结合定义的Entry数组，是不是想到了哈希表的拉链法实现？！）\n          final int hash;//哈希值\n  \n          Entry(int h, K k, V v, Entry<K,V> n) {\n              value = v;\n              next = n;\n             key = k;\n             hash = h;\n         }\n \n         public final K getKey() {\n             return key;\n         }\n \n         public final V getValue() {\n             return value;\n         }\n \n         public final V setValue(V newValue) {\n             V oldValue = value;\n            value = newValue;\n             return oldValue;//返回的是之前的Value\n         }\n \n         public final boolean equals(Object o) {\n             if (!(o instanceof Map.Entry))//先判断类型是否一致\n                    return false;\n             Map.Entry e = (Map.Entry)o;\n             Object k1 = getKey();\n             Object k2 = e.getKey();\n             // Key相等且Value相等则两个Entry相等\n             if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n                 Object v1 = getValue();\n                 Object v2 = e.getValue();\n                 if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                     return true;\n             }\n             return false;\n         }\n         // hashCode是Key的hashCode和Value的hashCode的异或的结果\n         public final int hashCode() {\n             return (key==null   ? 0 : key.hashCode()) ^\n                   (value==null ? 0 : value.hashCode());\n         }\n         // 重写toString方法，是输出更清晰\n         public final String toString() {\n             return getKey() + \"=\" + getValue();\n        }\n \n        /**\n          *当调用put(k,v)方法存入键值对时，如果k已经存在，则该方法被调用（为什么没有内容？）\n          */\n        void recordAccess(HashMap<K,V> m) {\n        }\n\n        /**\n          * 当Entry被从HashMap中移除时被调用（为什么没有内容？）\n          */\n         void recordRemoval(HashMap<K,V> m) {\n         }\n     }\n```\n看完属性和构造方法，接着看HashMap中的其他方法，一个个分析，从最常用的put和get说起吧。\nput()该方法 返回与 key 关联的旧值；如果key 没有任何映射关系，则返回null。\n     \n```\n  public V put(K key, V value) {\n          if (key == null)\n              return putForNullKey(value);\n\n          int hash = hash(key.hashCode());\n          int i = indexFor(hash, table.length);  //获取应该存放的索引值\n\n          for (Entry<K,V> e = table[i]; e != null; e = e.next) {  //校验key值之前是否存在，存在则替换并返回先前的值\n             Object k;\n             if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                 V oldValue = e.value;\n                 e.value = value;\n                 e.recordAccess(this);\n                 return oldValue;\n             }\n         }\n\n         // 该key之前不存在 则 执行 添加操作\n         modCount++;\n         addEntry(hash, key, value, i);   //四个参数 hash值  key  value  i索引\n         return null;\n     }\n    当存入的key是null的时候将调用putForNUllKey方法，暂时将这段逻辑放一边，看key不为null的情况。\n\n```\n先调用了hash(int h)方法获取了一个hash值。\n    \n```\n static int hash(int h) {\n         // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n         // number of collisions (approximately 8 at default load factor).\n        h ^= (h >>> 20) ^ (h >>> 12);\n         return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n```\n这个方法的主要作用是防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占4个字节，即32位。根据这32位值进行移位、异或运算得到一个值。\n\n```\n static int indexFor(int h, int length) {\n         return h & (length-1);\n     }\n```\nindexFor返回hash值和table数组长度减1的与运算结果，获取索引位置。\n为什么使用的是length-1？因为这样可以保证结果的最大值是length-1，不会产生数组越界问题。获取索引位置之后做了什么？探测table[i]所在的链表，所发现key值与传入的key值相同的对象，则替换并返回oldValue。（key值之前存在，替换并且返回旧值）若找不到，则通过addEntry(hash,key,value,i)添加新的对象。 （key值之前不存在，添加addEntry方法 ，并返回null）\n\n来看addEntry(hash,key,value,i)方法。\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n         Entry<K,V> e = table[bucketIndex];   //bucketIndex位置的元素先保存起来（新加的entry要占据这个位置）\n         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);//将新的值存到bucketIndex处，该值的next指向 刚刚保存的e元素\n         //检测是不是需要扩充容量 （2倍2倍的扩容）\n          if (size++ >= threshold)   // threshold默认值 是  16 * 0.75 = 12             resize(2 * table.length);\n  }\n```\n这就是在一个链表头部插入一个节点的过程。获取table[i]的对象e，将table[i]的对象修改为新增对象，让新增对象的next指向e。之后判断size是否到达了需要扩充table数组容量的界限并让size自增1，如果达到了则调用resize(int capacity)方法将数组容量拓展为原来的两倍。\n\n```\n void resize(int newCapacity) {\n          Entry[] oldTable = table;\n          int oldCapacity = oldTable.length;\n          // 这个if块表明，如果容量已经到达允许的最大值，即MAXIMUN_CAPACITY，则不再拓展容量，而将装载拓展的界限值设为计算机允许的最大值。\n         // 不会再触发resize方法，而是不断的向map中添加内容，即table数组中的链表可以不断变长，但数组长度不再改变\n         if (oldCapacity == MAXIMUM_CAPACITY) {  //MAXIMUM_CAPACITY  1073741824 [0x40000000]\n             threshold = Integer.MAX_VALUE;\n             return;\n          }\n         // 创建新数组，容量为指定的容量\n         Entry[] newTable = new Entry[newCapacity];\n         transfer(newTable);\n         table = newTable;\n         // 设置下一次需要调整数组大小的界限\n         threshold = (int)(newCapacity * loadFactor);\n     }\n```\n 结合上面给出的注释，调整数组容量的内容仅剩下将原table中的内容复制到newTable中并将newTable赋值给给table变量。即上面代码中的“transfer(newTable);table = newTable;”。\n来看transfer(Entry[] newTable)方法。\n\n```\n  void transfer(Entry[] newTable) {\n          // 保留原数组的引用到src中，\n          Entry[] src = table;\n          // 新容量使新数组的长度\n          int newCapacity = newTable.length;\n          // 遍历原数组\n         for (int j = 0; j < src.length; j++) {\n              // 获取元素e （此处的e是单链表的头结点）\n              Entry<K,V> e = src[j];\n             if (e != null) {\n                 // 将原数组中的元素置为null\n                 src[j] = null;\n                 // 遍历原数组中j位置指向的链表\n                 do {\n                     Entry<K,V> next = e.next;\n                     // 根据新的容量计算e在新数组中的位置\n                     int i = indexFor(e.hash, newCapacity);\n                     // 将e插入到newTable[i]指向的链表的头部\n                     e.next = newTable[i];\n                     newTable[i] = e;\n                    e = next;\n                 } while (e != null);\n             }\n         }\n     }\n```\n\n这样处理效果 原来的 单链表如果 顺序是  （头） a b c d e  （尾）通过  transfer方法之后的顺序是  (头)  e  d c  b a （尾）  因为后插入的在 链表的头部。从上面的代码可以看出，HashMap之所以不能保持元素的顺序有以下几点原因：\n\n    第一，插入元素的时候对元素进行哈希处理，不同元素分配到table的不同位置；\n    第二，容量拓展的时候又进行了hash处理；\n    第三，复制原表内容的时候链表被倒置。\n\n一个put方法带出了这么多内容，接着看看putAll吧。\n\n```\n  public void putAll(Map<? extends K, ? extends V> m) {\n          int numKeysToBeAdded = m.size();\n          if (numKeysToBeAdded == 0)\n              return;\n          // 为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)>threshold???\n         if (numKeysToBeAdded > threshold) {\n              int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);\n              if (targetCapacity > MAXIMUM_CAPACITY)\n                 targetCapacity = MAXIMUM_CAPACITY;\n             int newCapacity = table.length;\n             while (newCapacity < targetCapacity)\n                 newCapacity <<= 1;\n             if (newCapacity > table.length)\n                 resize(newCapacity);\n         }\n \n         for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n            Map.Entry<? extends K, ? extends V> e = i.next();\n             put(e.getKey(), e.getValue());\n         }\n     }\n```\n\n先回答上面的问题：为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)>threshold \n这是一种保守的做法，明显地，我们应该在(numKeysToBeAdded+table.length)>threshold的时候去拓展容量，但是考虑到将被添加的元素可能会有Key与原本存在的Key相同的情况，所以采用保守的做法，避免拓展到过大的容量。 接着是遍历m中的内容，然后调用put方法将元素添加到table数组中。遍历的时候涉及到了entrySet方法，这个方法定义在Map接口中，HashMap中也有实现，后面会解释HashMap的这个方法，其它Map的实现暂不解释。\n\n\t下面介绍在put方法中被调用到的putForNullKey方法。\n\n```\n\n private V putForNullKey(V value) {\n         for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n             if (e.key == null) {\n                 V oldValue = e.value;\n                 e.value = value;\n                 e.recordAccess(this);\n                  return oldValue;\n             }\n         }\n         modCount++;\n         addEntry(0, null, value, 0); // null 的 hash值是0 。 索引位置 index也是 0\n        return null;\n     }\n```\n\n这是一个私有方法，在put方法中被调用。它首先遍历table数组，如果找到key为null的元素，则替换元素值并返回oldValue；否则通过addEntry方法添加元素，之后返回null。还记得上面构造方法中调用到的putAllForCreate吗？一口气将put操作的方法看完吧。\n\n```\n private void putAllForCreate(Map<? extends K, ? extends V> m) {\n         for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n             Map.Entry<? extends K, ? extends V> e = i.next();\n             putForCreate(e.getKey(), e.getValue());\n         }\n     }\n```\n先将遍历的过程放在一边，因为它同样涉及到了entrySet()方法。剩下的代码很简单，只是调用putForCreate方法逐个元素加入。\n\n```\n private void putForCreate(K key, V value) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          int i = indexFor(hash, table.length);\n          for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n              Object k;\n              if (e.hash == hash &&\n                  ((k = e.key) == key || (key != null && key.equals(k)))) {\n                  e.value = value;\n                  return;\n             }\n         }\n         createEntry(hash, key, value, i);\n     }\n```\n     \n 该方法先计算需要添加的元素的hash值和在table数组中的索引i。接着遍历table[i]的链表，若有元素的key值与传入key值相等，则替换value，       结束方法。若不存在key值相同的元素，则调用createEntry创建并添加元素。\n\n```\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n          Entry<K,V> e = table[bucketIndex];\n         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n         size++;\n     }\n```\n\n这个方法的内容就不解释了，上面都解释过。 至此所有put相关操作都解释完毕了。put之外，另一个常用的操作就是get，下面就来看get方法。\n\n```\n public V get(Object key) {\n          if (key == null)\n              return getForNullKey();\n          int hash = hash(key.hashCode());\n          for (Entry<K,V> e = table[indexFor(hash, table.length)];e != null; e = e.next) {\n              Object k;\n              if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n                 return e.value;\n         }\n         return null;\n     }\n ```\n     \n 该方法分为key为null和不为null两块。先看不为null的情况。先获取key的hash值，之后通过hash值及table.length获取key对应的table数组的索引，遍历索引的链表，所找到key相同的元素，则返回元素的value，否者返回null。不为null的情况调用了getForNullKey()方法。\n\n1 private V getForNullKey() {\n2         for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n3             if (e.key == null)\n4                 return e.value;\n5         }\n6         return null;\n7     }\n    这是一个私有方法，只在get中被调用。该方法判断table[0]中的链表是否包含key为null的元素，包含则返回value，不包含则返回null。为什么是遍历table[0]的链表？因为key为null的时候获得的hash值都是0。\n添加（put）和获取（get）都结束了，接着看如何判断一个元素是否存在。\nHashMap没有提供判断元素是否存在的方法，只提供了判断Key是否存在及Value是否存在的方法，分别是containsKey(Object key)、containsValue(Object value)。\ncontainsKey(Object key)方法很简单，只是判断getEntry(key)的结果是否为null，是则返回false，否返回true。\n\n```\n public boolean containsKey(Object key) {\n          return getEntry(key) != null;\n      }\n  final Entry<K,V> getEntry(Object key) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) {\n              Object k;\n             if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))\n                 return e;\n         }\n         return null;\n     }\n```\ngetEntry(Object key)也没什么内容，只是根据key对应的hash值计算在table数组中的索引位置，然后遍历该链表判断是否存在相同的key值。\n\n```\n\n  public boolean containsValue(Object value) {\n      if (value == null)\n              return containsNullValue();\n  \n      Entry[] tab = table;\n          for (int i = 0; i < tab.length ; i++)\n              for (Entry e = tab[i] ; e != null ; e = e.next)\n                  if (value.equals(e.value))\n                      return true;\n     return false;\n     }\n private boolean containsNullValue() {\n     Entry[] tab = table;\n         for (int i = 0; i < tab.length ; i++)\n             for (Entry e = tab[i] ; e != null ; e = e.next)\n                 if (e.value == null)\n                     return true;\n     return false;\n     }\n```\n\n判断一个value是否存在比判断key是否存在还要简单，就是遍历所有元素判断是否有相等的值。这里分为两种情况处理，value为null何不为null的情况，但内容差不多，只是判断相等的方式不同。这个判断是否存在必须遍历所有元素，是一个双重循环的过程，因此是比较耗时的操作。接着看HashMap中“删除”相关的操作，有remove(Object key)和clear()两个方法。\n\n    remove(Object key)\n\n```\npublic V remove(Object key) {\n         Entry<K,V> e = removeEntryForKey(key);\n         return (e == null ? null : e.value);\n     }\n```\n\n看这个方法，removeEntryKey(key)的返回结果应该是被移除的元素，如果不存在这个元素则返回为null。remove方法根据removeEntryKey返回的结果e是否为null返回null或e.value。\n\n    removeEntryForKey(Object key)\n```\n  final Entry<K,V> removeEntryForKey(Object key) {\n          int hash = (key == null) ? 0 : hash(key.hashCode());\n          int i = indexFor(hash, table.length);\n          Entry<K,V> prev = table[i];\n          Entry<K,V> e = prev;\n  \n          while (e != null) {\n              Entry<K,V> next = e.next;\n              Object k;\n             if (e.hash == hash &&\n                 ((k = e.key) == key || (key != null && key.equals(k)))) {\n                 modCount++;\n                 size--;\n                 if (prev == e)\n                     table[i] = next;\n                 else\n                     prev.next = next;\n                 e.recordRemoval(this);\n                 return e;\n             }\n             prev = e;\n             e = next;\n         }\n \n         return e;\n     }\n\n```\n    上面的这个过程就是先找到table数组中对应的索引，接着就类似于一般的链表的删除操作，而且是单向链表删除节点，很简单。在C语言中就是修改指针，这个例子中就是将要删除节点的前一节点的next指向删除被删除节点的next即可。\n\nclear()\n\n```\n public void clear() {\n         modCount++;\n         Entry[] tab = table;\n         for (int i = 0; i < tab.length; i++)\n             tab[i] = null;\n         size = 0;\n    }\n```\n\nclear()方法删除HashMap中所有的元素，这里就不用一个个删除节点了，而是直接将table数组内容都置空，这样所有的链表都已经无法访问，Java的垃圾回收机制会去处理这些链表。table数组置空后修改size为0。这里为什么不直接操作table而是通过tab呢？希望有知道的大侠指点一二。主要方法看的差不多了，接着看一个上面提到了好几次但是都搁在一边没有分析的方法：entrySet()。 \n\nentrySet()\n\n```\n\tpublic Set<Map.Entry<K,V>> entrySet() {\n     return entrySet0();\n   }\n \n    private Set<Map.Entry<K,V>> entrySet0() {\n         Set<Map.Entry<K,V>> es = entrySet;\n         return es != null ? es : (entrySet = new EntrySet());\n    }\n```\n\n为什么会有这样的方法，只是调用了一下entrySet0，而且entrySet0的名称看着就很奇怪。再看entrySet0方法中为什么不直接return entrySet!=null?entrySet:(entrySet = new EntrySet)呢？上面的疑问还没解开，但是先看entrySet这个属性吧，在文章开头的属性定义中并没有给出这个属性，下面先看一下它的定义：\n\n```\nprivate transient Set<Map.Entry<K,V>> entrySet = null;\n\n```\n它是一个内容为Map.Entry<K,V>的Set。看看在哪些地方往里面添加了元素。 为什么上面的那句话我要把它标成红色？因为这是一个陷阱，在看代码的时候我就陷进去了。仔细看EntrySet这个类。\n\n```\n\nprivate final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n         public Iterator<Map.Entry<K,V>> iterator() {\n             return new EntryIterator();\n         }\n         public boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                 return false;\n             Map.Entry<K,V> e = (Map.Entry<K,V>) o;\n             Entry<K,V> candidate = getEntry(e.getKey());\n             return candidate != null && candidate.equals(e);\n         }\n         public boolean remove(Object o) {\n             return removeMapping(o) != null;\n         }\n         public int size() {\n             return size;\n         }\n         public void clear() {\n             HashMap.this.clear();\n         }\n }\n\n```\n看到了什么？这个类根本就没属性，它只是个代理。因为它内部类，可以访问外部类的内容，debug的时候能看到的属性都是继承或者外部类的属性，输出的时候其实也是调用到了父类的toString方法将HashMap中的内容输出了。\n\n    keySet()\n\n1 public Set<K> keySet() {\n2         Set<K> ks = keySet;\n3         return (ks != null ? ks : (keySet = new KeySet()));\n4     }\n    是不是和entrySet0()方法很像！\n\n 1 private final class KeySet extends AbstractSet<K> {\n 2         public Iterator<K> iterator() {\n 3             return newKeyIterator();\n 4         }\n 5         public int size() {\n 6             return size;\n 7         }\n 8         public boolean contains(Object o) {\n 9             return containsKey(o);\n10         }\n11         public boolean remove(Object o) {\n12             return HashMap.this.removeEntryForKey(o) != null;\n13         }\n14         public void clear() {\n15             HashMap.this.clear();\n16         }\n17     }\n复制代码\n    同样是个代理类，contains、remove、clear方法都是调用的HashMap的方法。 \n\n \n\n    values()\n\n 1 public Collection<V> values() {\n 2         Collection<V> vs = values;\n 3         return (vs != null ? vs : (values = new Values()));\n 4     }\n 5 \n 6     private final class Values extends AbstractCollection<V> {\n 7         public Iterator<V> iterator() {\n 8             return newValueIterator();\n 9         }\n10         public int size() {\n11             return size;\n12         }\n13         public boolean contains(Object o) {\n14             return containsValue(o);\n15         }\n16         public void clear() {\n17             HashMap.this.clear();\n18         }\n19     }\n    values()方法也一样是代理。只是Values类继承自AbstractCollention类，而不是AbstractSet。\n\n--------------------------------------------------------------------------------------------------------------------\n\n1. HashMap概述：\n\n　　HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\n\n2. HashMap的数据结构：\n\n　　在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。\n\n\n\n　　从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：\n\n/**\n * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\n\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    final int hash;\n    ……\n}\n　　可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。\n\n3.    HashMap的存取实现：\n\n  1) 存储：\n\npublic V put(K key, V value) {\n    // HashMap允许存放null键和null值。\n    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。\n    if (key == null)\n        return putForNullKey(value);\n    // 根据key的hashCode重新计算hash值。\n    int hash = hash(key.hashCode());\n    // 搜索指定hash值所对应table中的索引。\n    int i = indexFor(hash, table.length);\n    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    // 如果i索引处的Entry为null，表明此处还没有Entry。\n    // modCount记录HashMap中修改结构的次数\n    modCount++;\n    // 将key、value添加到i索引处。\n    addEntry(hash, key, value, i);\n    return null;\n}\n　　从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。\n\n　　addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    // 获取指定 bucketIndex 索引处的 Entry \n    Entry<K,V> e = table[bucketIndex];\n    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry\n    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);\n    // 如果 Map 中的 key-value 对的数量超过了极限\n    if (size++ >= threshold)\n    // 把 table 对象的长度扩充到原来的2倍。\n        resize(2 * table.length);\n}\n　　当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。\n\n　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。\n\nstatic int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n　　我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。\n\n　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：\n\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n　　这个方法非常巧妙，它通过 h & (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：\n\nint capacity = 1;\n    while (capacity < initialCapacity)\n        capacity <<= 1;\n　　这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。\n\n　　当length总是 2 的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n　　这看上去很简单，其实比较有玄机的，我们举个例子来说明：\n\n　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&运算后的结果如下：\n\n       h & (table.length-1)                     hash                             table.length-1\n\n       8 & (15-1)：                                 0100                   &              1110                   =                0100\n\n       9 & (15-1)：                                 0101                   &              1110                   =                0100\n\n      -----------------------------------------------------------------------------------------------------------------------\n\n       8 & (16-1)：                                 0100                   &              1111                   =                0100\n\n       9 & (16-1)：                                 0101                   &              1111                   =                0101\n\n      -----------------------------------------------------------------------------------------------------------------------\n\n　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！\n\n　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。\n\n　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。\n\n　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。\n\n  2) 读取：\n\npublic V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    int hash = hash(key.hashCode());\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n        e != null;\n        e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n            return e.value;\n    }\n    return null;\n}\n　　有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。\n\n  3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n4. HashMap的resize（rehash）：\n\n　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。\n\n　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。\n\nHashMap扩容的代码如下所示：\n\n//HashMap数组扩容\n          void resize(int newCapacity) {\n                Entry[] oldTable = table;\n                int oldCapacity = oldTable.length;\n                //如果当前的数组长度已经达到最大值，则不在进行调整\n                if (oldCapacity == MAXIMUM_CAPACITY) {\n                    threshold = Integer.MAX_VALUE;\n                    return;\n                }\n                //根据传入参数的长度定义新的数组\n                Entry[] newTable = new Entry[newCapacity];\n                //按照新的规则，将旧数组中的元素转移到新数组中\n                transfer(newTable);\n                table = newTable;\n                //更新临界值\n                threshold = (int)(newCapacity * loadFactor);\n            }\n\n          //旧数组中元素往新数组中迁移\n            void transfer(Entry[] newTable) {\n                //旧数组\n                Entry[] src = table;\n                //新数组长度\n                int newCapacity = newTable.length;\n                //遍历旧数组\n                for (int j = 0; j < src.length; j++) {\n                    Entry<K,V> e = src[j];\n                    if (e != null) {\n                        src[j] = null;\n                        do {\n                            Entry<K,V> next = e.next;\n                            int i = indexFor(e.hash, newCapacity);\n                            e.next = newTable[i];\n                            newTable[i] = e;\n                            e = next;\n                        } while (e != null);\n                    }\n                }\n            }\n5.HashMap的性能参数：\n\nHashMap 包含如下几个构造器：\n\n   HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。\n   HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。\n   HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。    initialCapacity：HashMap的最大容量，即为底层数组的长度。 loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。\n　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。\n\n　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：\n\nthreshold = (int)(capacity * loadFactor);  \n　　结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：\n\nif (size++ >= threshold)   \n    resize(2 * table.length); \n6.Fail-Fast机制：\n\n　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）\n\n　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。\n\nHashIterator() {\n    expectedModCount = modCount;\n    if (size > 0) { // advance to first entry\n    Entry[] t = table;\n    while (index < t.length && (next = t[index++]) == null)\n        ;\n    }\n}\n　　在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：\n\n　　注意到modCount声明为volatile，保证线程之间修改的可见性。\n\n    （volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。\n\nfinal Entry<K,V> nextEntry() {   \n    if (modCount != expectedModCount)   \n        throw new ConcurrentModificationException();\n在HashMap的API中指出：\n\n　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。\n\n　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。","slug":"Java源码分析-一-HashMap","published":1,"updated":"2016-11-23T01:58:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlv000807fykofdtazn","content":"<p>参考文章：<a href=\"http://blog.csdn.net/pandajava/article/details/42391733\" target=\"_blank\" rel=\"external\"> java源码分析 —- HashMap源码分析 及其 实现原理分析</a></p>\n<p>HashMap 在java集合中来说算是比较重要的一个类了。其源码也是在面试过程中经常被问的一道面试题。之前自己也大略的看过，现在抱着一起学习的态度，分析一下HashMap的源码。</p>\n<h3 id=\"0-所处位置\"><a href=\"#0-所处位置\" class=\"headerlink\" title=\"0. 所处位置\"></a>0. 所处位置</h3><p>学过Java集合的人都应该看过张图(《Java编程思想》关于容器类库的简介图)<br> <img src=\"/img/java/collection.png\" alt=\"\"></p>\n<h3 id=\"1-HashMap的数据结构\"><a href=\"#1-HashMap的数据结构\" class=\"headerlink\" title=\"1. HashMap的数据结构\"></a>1. HashMap的数据结构</h3><p>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。<br>数组<br>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；<br>链表<br>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。<br>哈希表<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。<br>　　哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：</p>\n<p>　　从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。<br>比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。<br>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。<br>　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。<br>    /**</p>\n<pre><code> * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\n</code></pre><h3 id=\"2-HashMap源码分析\"><a href=\"#2-HashMap源码分析\" class=\"headerlink\" title=\"2. HashMap源码分析\"></a>2. HashMap源码分析</h3><p> HashMap继承自AbstractMap，实现了Map接口（这些内容可以参考《Java集合类》）。来看类的定义。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap&lt;K</span>,<span class=\"title\">V&gt;</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap&lt;K</span>,<span class=\"title\">V&gt;</span> <span class=\"title\">implements</span> <span class=\"title\">Map&lt;K</span>,<span class=\"title\">V&gt;</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></div></pre></td></tr></table></figure>\n<pre><code>Map接口定义了所有Map子类必须实现的方法。Map接口中还定义了一个内部接口Entry。\n\nAbstractMap也实现了Map接口，并且提供了两个实现Entry的内部类：SimpleEntry和SimpleImmutableEntry。\n\n定义了接口，接口中又有内部接口，然后有搞了个抽象类实现接口，抽象类里面又搞了两个内部类实现接口的内部接口，有没有点绕，为什么搞成这样呢？先不管了，先看HashMap吧。\n\nHashMap中定义的属性（应该都能看明白，不过还是解释一下）：\n</code></pre><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     * 默认的初始容量，必须是2的幂。</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">    * 默认装载因子，这个后面会做解释</div><div class=\"line\">   */</div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75</span>f;</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 存储数据的Entry数组，长度是2的幂。看到数组的内容了，接着看数组中存的内容就明白为什么博文开头先复习数据结构了</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">transient</span> Entry[] table;</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * map中保存的键值对的数量</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> <span class=\"keyword\">size</span>;</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    * 需要调整大小的极限值（容量*装载因子）</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">int</span> threshold;</div><div class=\"line\">   <span class=\"comment\">/**</span></div><div class=\"line\">    *装载因子</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">    * map结构被改变的次数</div><div class=\"line\">    */</div><div class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> modCount;</div></pre></td></tr></table></figure>\n<p>接着是HashMap的构造方法。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     *使用默认的容量及装载因子构造一个空的HashMap</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class=\"line\">        threshold = (<span class=\"built_in\">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);<span class=\"comment\">//计算下次需要调整大小的极限值</span></div><div class=\"line\">        table = <span class=\"keyword\">new</span> Entry[DEFAULT_INITIAL_CAPACITY];    <span class=\"comment\">//根据默认容量（16）初始化table</span></div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     * 根据给定的初始容量的装载因子创建一个空的HashMap</div><div class=\"line\">     * 初始容量小于0或装载因子小于等于0将报异常 </div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(<span class=\"built_in\">int</span> initialCapacity, <span class=\"built_in\">float</span> loadFactor) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</div><div class=\"line\">                                               initialCapacity);</div><div class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<span class=\"comment\">//调整最大容量</span></div><div class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</div><div class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</div><div class=\"line\">                                               loadFactor);</div><div class=\"line\">        <span class=\"built_in\">int</span> capacity = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//设置capacity为大于initialCapacity且是2的幂的最小值</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)  <span class=\"comment\">// 假设initialCapacity的值为30 则capacity的值 最终问2的5次方 32 。</span></div><div class=\"line\">            capacity &lt;&lt;= <span class=\"number\">1</span>;                 <span class=\"comment\">//也就是说hashMap中entry[] 的初始化大小是32 而非30。</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</div><div class=\"line\">        threshold = (<span class=\"built_in\">int</span>)(capacity * loadFactor);</div><div class=\"line\">        table = <span class=\"keyword\">new</span> Entry[capacity];</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     *根据指定容量创建一个空的HashMap</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(<span class=\"built_in\">int</span> initialCapacity) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<span class=\"comment\">//调用上面的构造方法，容量为指定的容量，装载因子是默认值</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     *通过传入的map创建一个HashMap，容量为默认容量（16）和(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，装载因子为默认值</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class=\"line\">        <span class=\"comment\">//调用构造方法 传入相关参数 并完成初始化</span></div><div class=\"line\">        <span class=\"keyword\">this</span>(Math.<span class=\"built_in\">max</span>((<span class=\"built_in\">int</span>) (m.<span class=\"built_in\">size</span>() / DEFAULT_LOAD_FACTOR) + <span class=\"number\">1</span>,DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class=\"line\">       </div><div class=\"line\">        putAllForCreate(m);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面的构造方法中调用到了init()方法，最后一个方法还调用了</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">putAllForCreate(<span class=\"built_in\">Map</span>&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m)。</div></pre></td></tr></table></figure>\n<p>init方法是一个空方法，里面没有任何内容。（其作用为何？）<br>putAllForCreate看方法名就是创建的时候将传入的map全部放入新创建的对象中。该方法中还涉及到其他方法，将在后面介绍。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private <span class=\"keyword\">void</span> putAllForCreate(<span class=\"built_in\">Map</span>&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m) &#123;  </div><div class=\"line\">      <span class=\"keyword\">for</span> (&lt;strong&gt;<span class=\"built_in\">Iterator</span>&lt;? <span class=\"keyword\">extends</span> <span class=\"built_in\">Map</span>.Entry&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt;&gt; i =&lt;u&gt; m.entrySet().iterator()&lt;/u&gt;; i.hasNext();&lt;/strong&gt; ) &#123;  </div><div class=\"line\">          &lt;strong&gt;<span class=\"built_in\">Map</span>.Entry&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; e = i.next();&lt;/strong&gt;  </div><div class=\"line\">          &lt;u&gt;putForCreate(e.getKey(), e.getValue());&lt;/u&gt;  </div><div class=\"line\">      &#125;  </div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">``` </div><div class=\"line\">  </div><div class=\"line\">先看初始化table时均使用了Entry，这是HashMap的一个内部类，实现了<span class=\"built_in\">Map</span>接口的内部接口Entry。下面给出<span class=\"built_in\">Map</span>.Entry接口及HashMap.Entry类的内容。<span class=\"built_in\">Map</span>.Entry接口定义的方法</div></pre></td></tr></table></figure>\n<p> K getKey();//获取Key<br> V getValue();//获取Value<br> V setValue();//设置Value，至于具体返回什么要看具体实现<br> boolean equals(Object o);//定义equals方法用于判断两个Entry是否相同<br> int hashCode();//定义获取hashCode的方法</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">HashMap.<span class=\"keyword\">Entry</span>类的具体实现</div></pre></td></tr></table></figure>\n<p>  static class Entry<k,v> implements Map.Entry<k,v> {<br>          final K key;<br>          V value;<br>          Entry<k,v> next;//对下一个节点的引用（看到链表的内容，结合定义的Entry数组，是不是想到了哈希表的拉链法实现？！）<br>          final int hash;//哈希值</k,v></k,v></k,v></p>\n<pre><code>     Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {\n         value = v;\n         next = n;\n        key = k;\n        hash = h;\n    }\n\n    public final K getKey() {\n        return key;\n    }\n\n    public final V getValue() {\n        return value;\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n       value = newValue;\n        return oldValue;//返回的是之前的Value\n    }\n\n    public final boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))//先判断类型是否一致\n               return false;\n        Map.Entry e = (Map.Entry)o;\n        Object k1 = getKey();\n        Object k2 = e.getKey();\n        // Key相等且Value相等则两个Entry相等\n        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {\n            Object v1 = getValue();\n            Object v2 = e.getValue();\n            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n    // hashCode是Key的hashCode和Value的hashCode的异或的结果\n    public final int hashCode() {\n        return (key==null   ? 0 : key.hashCode()) ^\n              (value==null ? 0 : value.hashCode());\n    }\n    // 重写toString方法，是输出更清晰\n    public final String toString() {\n        return getKey() + &quot;=&quot; + getValue();\n   }\n\n   /**\n     *当调用put(k,v)方法存入键值对时，如果k已经存在，则该方法被调用（为什么没有内容？）\n     */\n   void recordAccess(HashMap&lt;K,V&gt; m) {\n   }\n\n   /**\n     * 当Entry被从HashMap中移除时被调用（为什么没有内容？）\n     */\n    void recordRemoval(HashMap&lt;K,V&gt; m) {\n    }\n}\n</code></pre><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">看完属性和构造方法，接着看HashMap中的其他方法，一个个分析，从最常用的<span class=\"built_in\">put</span>和<span class=\"built_in\">get</span>说起吧。</div><div class=\"line\"><span class=\"built_in\">put</span>()该方法 返回与 <span class=\"built_in\">key</span> 关联的旧值；如果<span class=\"built_in\">key</span> 没有任何映射关系，则返回null。</div></pre></td></tr></table></figure>\n<p>  public V put(K key, V value) {<br>          if (key == null)<br>              return putForNullKey(value);</p>\n<pre><code>      int hash = hash(key.hashCode());\n      int i = indexFor(hash, table.length);  //获取应该存放的索引值\n\n      for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {  //校验key值之前是否存在，存在则替换并返回先前的值\n         Object k;\n         if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n             V oldValue = e.value;\n             e.value = value;\n             e.recordAccess(this);\n             return oldValue;\n         }\n     }\n\n     // 该key之前不存在 则 执行 添加操作\n     modCount++;\n     addEntry(hash, key, value, i);   //四个参数 hash值  key  value  i索引\n     return null;\n }\n当存入的key是null的时候将调用putForNUllKey方法，暂时将这段逻辑放一边，看key不为null的情况。\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">先调用了<span class=\"built_in\">hash</span>(int h)方法获取了一个<span class=\"built_in\">hash</span>值。</div></pre></td></tr></table></figure>\n<p> static int hash(int h) {<br>         // This function ensures that hashCodes that differ only by<br>        // constant multiples at each bit position have a bounded<br>         // number of collisions (approximately 8 at default load factor).<br>        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>         return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>    }<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">这个方法的主要作用是防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占<span class=\"number\">4</span>个字节，即<span class=\"number\">32</span>位。根据这<span class=\"number\">32</span>位值进行移位、异或运算得到一个值。</div></pre></td></tr></table></figure></p>\n<p> static int indexFor(int h, int length) {<br>         return h &amp; (length-1);<br>     }<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">indexFor返回hash值和table数组长度减<span class=\"number\">1</span>的与运算结果，获取索引位置。</div><div class=\"line\">为什么使用的是length<span class=\"number\">-1</span>？因为这样可以保证结果的最大值是length<span class=\"number\">-1</span>，不会产生数组越界问题。获取索引位置之后做了什么？探测table[i]所在的链表，所发现<span class=\"type\">key</span>值与传入的<span class=\"type\">key</span>值相同的对象，则替换并返回oldValue。（<span class=\"type\">key</span>值之前存在，替换并且返回旧值）若找不到，则通过addEntry(hash,<span class=\"type\">key</span>,value,i)添加新的对象。 （<span class=\"type\">key</span>值之前不存在，添加addEntry方法 ，并返回null）</div><div class=\"line\"></div><div class=\"line\">来看addEntry(hash,<span class=\"type\">key</span>,value,i)方法。</div></pre></td></tr></table></figure></p>\n<p>void addEntry(int hash, K key, V value, int bucketIndex) {<br>         Entry<k,v> e = table[bucketIndex];   //bucketIndex位置的元素先保存起来（新加的entry要占据这个位置）<br>         table[bucketIndex] = new Entry<k,v>(hash, key, value, e);//将新的值存到bucketIndex处，该值的next指向 刚刚保存的e元素<br>         //检测是不是需要扩充容量 （2倍2倍的扩容）<br>          if (size++ &gt;= threshold)   // threshold默认值 是  16 <em> 0.75 = 12             resize(2 </em> table.length);<br>  }<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">这就是在一个链表头部插入一个节点的过程。获取<span class=\"keyword\">table</span>[i]的对象e，将<span class=\"keyword\">table</span>[i]的对象修改为新增对象，让新增对象的next指向e。之后判断size是否到达了需要扩充<span class=\"keyword\">table</span>数组容量的界限并让size自增1，如果达到了则调用resize(int <span class=\"comment\">capacity)</span>方法将数组容量拓展为原来的两倍。</div></pre></td></tr></table></figure></k,v></k,v></p>\n<p> void resize(int newCapacity) {<br>          Entry[] oldTable = table;<br>          int oldCapacity = oldTable.length;<br>          // 这个if块表明，如果容量已经到达允许的最大值，即MAXIMUN_CAPACITY，则不再拓展容量，而将装载拓展的界限值设为计算机允许的最大值。<br>         // 不会再触发resize方法，而是不断的向map中添加内容，即table数组中的链表可以不断变长，但数组长度不再改变<br>         if (oldCapacity == MAXIMUM_CAPACITY) {  //MAXIMUM_CAPACITY  1073741824 [0x40000000]<br>             threshold = Integer.MAX_VALUE;<br>             return;<br>          }<br>         // 创建新数组，容量为指定的容量<br>         Entry[] newTable = new Entry[newCapacity];<br>         transfer(newTable);<br>         table = newTable;<br>         // 设置下一次需要调整数组大小的界限<br>         threshold = (int)(newCapacity * loadFactor);<br>     }<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 结合上面给出的注释，调整数组容量的内容仅剩下将原<span class=\"keyword\">table</span>中的内容复制到newTable中并将newTable赋值给给<span class=\"keyword\">table</span>变量。即上面代码中的“transfer(newTable);<span class=\"keyword\">table</span> <span class=\"comment\">= newTable</span>;”。</div><div class=\"line\">来看transfer(Entry[] newTable)方法。</div></pre></td></tr></table></figure></p>\n<p>  void transfer(Entry[] newTable) {<br>          // 保留原数组的引用到src中，<br>          Entry[] src = table;<br>          // 新容量使新数组的长度<br>          int newCapacity = newTable.length;<br>          // 遍历原数组<br>         for (int j = 0; j &lt; src.length; j++) {<br>              // 获取元素e （此处的e是单链表的头结点）<br>              Entry<k,v> e = src[j];<br>             if (e != null) {<br>                 // 将原数组中的元素置为null<br>                 src[j] = null;<br>                 // 遍历原数组中j位置指向的链表<br>                 do {<br>                     Entry<k,v> next = e.next;<br>                     // 根据新的容量计算e在新数组中的位置<br>                     int i = indexFor(e.hash, newCapacity);<br>                     // 将e插入到newTable[i]指向的链表的头部<br>                     e.next = newTable[i];<br>                     newTable[i] = e;<br>                    e = next;<br>                 } while (e != null);<br>             }<br>         }<br>     }<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这样处理效果 原来的 单链表如果 顺序是  （头） <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d e  （尾）通过  transfer方法之后的顺序是  (头)  e  d c  <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">a</span> （尾）  因为后插入的在 链表的头部。从上面的代码可以看出，HashMap之所以不能保持元素的顺序有以下几点原因：</div><div class=\"line\"></div><div class=\"line\">    第一，插入元素的时候对元素进行哈希处理，不同元素分配到table的不同位置；</div><div class=\"line\">    第二，容量拓展的时候又进行了hash处理；</div><div class=\"line\">    第三，复制原表内容的时候链表被倒置。</div><div class=\"line\"></div><div class=\"line\">一个put方法带出了这么多内容，接着看看putAll吧。</div></pre></td></tr></table></figure></k,v></k,v></p>\n<p>  public void putAll(Map&lt;? extends K, ? extends V&gt; m) {<br>          int numKeysToBeAdded = m.size();<br>          if (numKeysToBeAdded == 0)<br>              return;<br>          // 为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)&gt;threshold???<br>         if (numKeysToBeAdded &gt; threshold) {<br>              int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);<br>              if (targetCapacity &gt; MAXIMUM_CAPACITY)<br>                 targetCapacity = MAXIMUM_CAPACITY;<br>             int newCapacity = table.length;<br>             while (newCapacity &lt; targetCapacity)<br>                 newCapacity &lt;&lt;= 1;<br>             if (newCapacity &gt; table.length)<br>                 resize(newCapacity);<br>         }</p>\n<pre><code>    for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {\n       Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();\n        put(e.getKey(), e.getValue());\n    }\n}\n</code></pre><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">先回答上面的问题：为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+<span class=\"keyword\">table</span>.length)&gt;threshold </div><div class=\"line\">这是一种保守的做法，明显地，我们应该在(numKeysToBeAdded+<span class=\"keyword\">table</span>.length)&gt;threshold的时候去拓展容量，但是考虑到将被添加的元素可能会有Key与原本存在的Key相同的情况，所以采用保守的做法，避免拓展到过大的容量。 接着是遍历m中的内容，然后调用put方法将元素添加到<span class=\"keyword\">table</span>数组中。遍历的时候涉及到了entrySet方法，这个方法定义在Map接口中，HashMap中也有实现，后面会解释HashMap的这个方法，其它Map的实现暂不解释。</div><div class=\"line\"></div><div class=\"line\">\t下面介绍在put方法中被调用到的putForNullKey方法。</div></pre></td></tr></table></figure>\n<p> private V putForNullKey(V value) {<br>         for (Entry<k,v> e = table[0]; e != null; e = e.next) {<br>             if (e.key == null) {<br>                 V oldValue = e.value;<br>                 e.value = value;<br>                 e.recordAccess(this);<br>                  return oldValue;<br>             }<br>         }<br>         modCount++;<br>         addEntry(0, null, value, 0); // null 的 hash值是0 。 索引位置 index也是 0<br>        return null;<br>     }<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这是一个私有方法，在<span class=\"built_in\">put</span>方法中被调用。它首先遍历table数组，如果找到key为<span class=\"literal\">null</span>的元素，则替换元素值并返回oldValue；否则通过addEntry方法添加元素，之后返回<span class=\"literal\">null</span>。还记得上面构造方法中调用到的putAllForCreate吗？一口气将<span class=\"built_in\">put</span>操作的方法看完吧。</div></pre></td></tr></table></figure></k,v></p>\n<p> private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {<br>         for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {<br>             Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();<br>             putForCreate(e.getKey(), e.getValue());<br>         }<br>     }<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">先将遍历的过程放在一边，因为它同样涉及到了entrySet()方法。剩下的代码很简单，只是调用putForCreate方法逐个元素加入。</div></pre></td></tr></table></figure></p>\n<p> private void putForCreate(K key, V value) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          int i = indexFor(hash, table.length);<br>          for (Entry<k,v> e = table[i]; e != null; e = e.next) {<br>              Object k;<br>              if (e.hash == hash &amp;&amp;<br>                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {<br>                  e.value = value;<br>                  return;<br>             }<br>         }<br>         createEntry(hash, key, value, i);<br>     }<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">该方法先计算需要添加的元素的hash值和在table数组中的索引i。接着遍历table[i]的链表，若有元素的<span class=\"built_in\">key</span>值与传入<span class=\"built_in\">key</span>值相等，则替换<span class=\"built_in\">value</span>，       结束方法。若不存在<span class=\"built_in\">key</span>值相同的元素，则调用createEntry创建并添加元素。</div></pre></td></tr></table></figure></k,v></p>\n<p>void createEntry(int hash, K key, V value, int bucketIndex) {<br>          Entry<k,v> e = table[bucketIndex];<br>         table[bucketIndex] = new Entry<k,v>(hash, key, value, e);<br>         size++;<br>     }<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这个方法的内容就不解释了，上面都解释过。 至此所有<span class=\"keyword\">put</span>相关操作都解释完毕了。<span class=\"keyword\">put</span>之外，另一个常用的操作就是<span class=\"keyword\">get</span>，下面就来看<span class=\"keyword\">get</span>方法。</div></pre></td></tr></table></figure></k,v></k,v></p>\n<p> public V get(Object key) {<br>          if (key == null)<br>              return getForNullKey();<br>          int hash = hash(key.hashCode());<br>          for (Entry<k,v> e = table[indexFor(hash, table.length)];e != null; e = e.next) {<br>              Object k;<br>              if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br>                 return e.value;<br>         }<br>         return null;<br>     }<br> <figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">     </div><div class=\"line\"> 该方法分为<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>和不为<span class=\"keyword\">null</span>两块。先看不为<span class=\"keyword\">null</span>的情况。先获取<span class=\"built_in\">key</span>的hash值，之后通过hash值及table.length获取<span class=\"built_in\">key</span>对应的table数组的索引，遍历索引的链表，所找到<span class=\"built_in\">key</span>相同的元素，则返回元素的value，否者返回<span class=\"keyword\">null</span>。不为<span class=\"keyword\">null</span>的情况调用了getForNullKey()方法。</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">private</span> V getForNullKey() &#123;</div><div class=\"line\"><span class=\"number\">2</span>         <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\"><span class=\"number\">3</span>             <span class=\"keyword\">if</span> (e.<span class=\"built_in\">key</span> == <span class=\"keyword\">null</span>)</div><div class=\"line\"><span class=\"number\">4</span>                 <span class=\"keyword\">return</span> e.value;</div><div class=\"line\"><span class=\"number\">5</span>         &#125;</div><div class=\"line\"><span class=\"number\">6</span>         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">7</span>     &#125;</div><div class=\"line\">    这是一个私有方法，只在<span class=\"built_in\">get</span>中被调用。该方法判断table[<span class=\"number\">0</span>]中的链表是否包含<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>的元素，包含则返回value，不包含则返回<span class=\"keyword\">null</span>。为什么是遍历table[<span class=\"number\">0</span>]的链表？因为<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>的时候获得的hash值都是<span class=\"number\">0</span>。</div><div class=\"line\">添加（put）和获取（<span class=\"built_in\">get</span>）都结束了，接着看如何判断一个元素是否存在。</div><div class=\"line\"><span class=\"keyword\">HashMap</span>没有提供判断元素是否存在的方法，只提供了判断Key是否存在及Value是否存在的方法，分别是containsKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)、containsValue(<span class=\"keyword\">Object</span> value)。</div><div class=\"line\">containsKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)方法很简单，只是判断getEntry(<span class=\"built_in\">key</span>)的结果是否为<span class=\"keyword\">null</span>，是则返回<span class=\"keyword\">false</span>，否返回<span class=\"keyword\">true</span>。</div></pre></td></tr></table></figure></k,v></p>\n<p> public boolean containsKey(Object key) {<br>          return getEntry(key) != null;<br>      }<br>  final Entry<k,v> getEntry(Object key) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          for (Entry<k,v> e = table[indexFor(hash, table.length)]; e != null;e = e.next) {<br>              Object k;<br>             if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                 return e;<br>         }<br>         return null;<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getEntry(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)也没什么内容，只是根据<span class=\"built_in\">key</span>对应的hash值计算在table数组中的索引位置，然后遍历该链表判断是否存在相同的<span class=\"built_in\">key</span>值。</div></pre></td></tr></table></figure></k,v></k,v></p>\n<p>  public boolean containsValue(Object value) {<br>      if (value == null)<br>              return containsNullValue();</p>\n<pre><code> Entry[] tab = table;\n     for (int i = 0; i &lt; tab.length ; i++)\n         for (Entry e = tab[i] ; e != null ; e = e.next)\n             if (value.equals(e.value))\n                 return true;\nreturn false;\n}\n</code></pre><p> private boolean containsNullValue() {<br>     Entry[] tab = table;<br>         for (int i = 0; i &lt; tab.length ; i++)<br>             for (Entry e = tab[i] ; e != null ; e = e.next)<br>                 if (e.value == null)<br>                     return true;<br>     return false;<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">判断一个value是否存在比判断<span class=\"built_in\">key</span>是否存在还要简单，就是遍历所有元素判断是否有相等的值。这里分为两种情况处理，value为<span class=\"keyword\">null</span>何不为<span class=\"keyword\">null</span>的情况，但内容差不多，只是判断相等的方式不同。这个判断是否存在必须遍历所有元素，是一个双重循环的过程，因此是比较耗时的操作。接着看<span class=\"keyword\">HashMap</span>中“删除”相关的操作，有remove(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)和<span class=\"built_in\">clear</span>()两个方法。</div><div class=\"line\"></div><div class=\"line\">    remove(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)</div></pre></td></tr></table></figure></p>\n<p>public V remove(Object key) {<br>         Entry<k,v> e = removeEntryForKey(key);<br>         return (e == null ? null : e.value);<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">看这个方法，removeEntryKey(<span class=\"built_in\">key</span>)的返回结果应该是被移除的元素，如果不存在这个元素则返回为<span class=\"keyword\">null</span>。remove方法根据removeEntryKey返回的结果e是否为<span class=\"keyword\">null</span>返回<span class=\"keyword\">null</span>或e.value。</div><div class=\"line\"></div><div class=\"line\">    removeEntryForKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)</div></pre></td></tr></table></figure></k,v></p>\n<p>  final Entry<k,v> removeEntryForKey(Object key) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          int i = indexFor(hash, table.length);<br>          Entry<k,v> prev = table[i];<br>          Entry<k,v> e = prev;</k,v></k,v></k,v></p>\n<pre><code>     while (e != null) {\n         Entry&lt;K,V&gt; next = e.next;\n         Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {\n            modCount++;\n            size--;\n            if (prev == e)\n                table[i] = next;\n            else\n                prev.next = next;\n            e.recordRemoval(this);\n            return e;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return e;\n}\n</code></pre><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    上面的这个过程就是先找到<span class=\"built_in\">table</span>数组中对应的索引，接着就类似于一般的链表的删除操作，而且是单向链表删除节点，很简单。在C语言中就是修改指针，这个例子中就是将要删除节点的前一节点的<span class=\"built_in\">next</span>指向删除被删除节点的<span class=\"built_in\">next</span>即可。</div><div class=\"line\"></div><div class=\"line\">clear()</div></pre></td></tr></table></figure>\n<p> public void clear() {<br>         modCount++;<br>         Entry[] tab = table;<br>         for (int i = 0; i &lt; tab.length; i++)<br>             tab[i] = null;<br>         size = 0;<br>    }<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">clear</span><span class=\"params\">()</span></span>方法删除HashMap中所有的元素，这里就不用一个个删除节点了，而是直接将table数组内容都置空，这样所有的链表都已经无法访问，Java的垃圾回收机制会去处理这些链表。table数组置空后修改size为<span class=\"number\">0</span>。这里为什么不直接操作table而是通过tab呢？希望有知道的大侠指点一二。主要方法看的差不多了，接着看一个上面提到了好几次但是都搁在一边没有分析的方法：entrySet()。 </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">entrySet</span><span class=\"params\">()</span></span></div></pre></td></tr></table></figure></p>\n<pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {\n return entrySet0();\n</code></pre><p>   }</p>\n<pre><code>private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {\n     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;\n     return es != null ? es : (entrySet = new EntrySet());\n}\n</code></pre><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">为什么会有这样的方法，只是调用了一下entrySet0，而且entrySet0的名称看着就很奇怪。再看entrySet0方法中为什么不直接<span class=\"keyword\">return</span> entrySet!=<span class=\"literal\">null</span>?entrySet:(entrySet = <span class=\"keyword\">new</span> EntrySet)呢？上面的疑问还没解开，但是先看entrySet这个属性吧，在文章开头的属性定义中并没有给出这个属性，下面先看一下它的定义：</div></pre></td></tr></table></figure>\n<p>private transient Set<map.entry<k,v>&gt; entrySet = null;</map.entry<k,v></p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">它是一个内容为<span class=\"keyword\">Map</span>.Entry&lt;<span class=\"keyword\">K</span>,V&gt;的<span class=\"keyword\">Set</span>。看看在哪些地方往里面添加了元素。 为什么上面的那句话我要把它标成红色？因为这是一个陷阱，在看代码的时候我就陷进去了。仔细看EntrySet这个类。</div></pre></td></tr></table></figure>\n<p>private final class EntrySet extends AbstractSet<map.entry<k,v>&gt; {<br>         public Iterator<map.entry<k,v>&gt; iterator() {<br>             return new EntryIterator();<br>         }<br>         public boolean contains(Object o) {<br>            if (!(o instanceof Map.Entry))<br>                 return false;<br>             Map.Entry<k,v> e = (Map.Entry<k,v>) o;<br>             Entry<k,v> candidate = getEntry(e.getKey());<br>             return candidate != null &amp;&amp; candidate.equals(e);<br>         }<br>         public boolean remove(Object o) {<br>             return removeMapping(o) != null;<br>         }<br>         public int size() {<br>             return size;<br>         }<br>         public void clear() {<br>             HashMap.this.clear();<br>         }<br> }</k,v></k,v></k,v></map.entry<k,v></map.entry<k,v></p>\n<p>```<br>看到了什么？这个类根本就没属性，它只是个代理。因为它内部类，可以访问外部类的内容，debug的时候能看到的属性都是继承或者外部类的属性，输出的时候其实也是调用到了父类的toString方法将HashMap中的内容输出了。</p>\n<pre><code>keySet()\n</code></pre><p>1 public Set<k> keySet() {<br>2         Set<k> ks = keySet;<br>3         return (ks != null ? ks : (keySet = new KeySet()));<br>4     }<br>    是不是和entrySet0()方法很像！</k></k></p>\n<p> 1 private final class KeySet extends AbstractSet<k> {<br> 2         public Iterator<k> iterator() {<br> 3             return newKeyIterator();<br> 4         }<br> 5         public int size() {<br> 6             return size;<br> 7         }<br> 8         public boolean contains(Object o) {<br> 9             return containsKey(o);<br>10         }<br>11         public boolean remove(Object o) {<br>12             return HashMap.this.removeEntryForKey(o) != null;<br>13         }<br>14         public void clear() {<br>15             HashMap.this.clear();<br>16         }<br>17     }<br>复制代码<br>    同样是个代理类，contains、remove、clear方法都是调用的HashMap的方法。 </k></k></p>\n<pre><code>values()\n</code></pre><p> 1 public Collection<v> values() {<br> 2         Collection<v> vs = values;<br> 3         return (vs != null ? vs : (values = new Values()));<br> 4     }<br> 5<br> 6     private final class Values extends AbstractCollection<v> {<br> 7         public Iterator<v> iterator() {<br> 8             return newValueIterator();<br> 9         }<br>10         public int size() {<br>11             return size;<br>12         }<br>13         public boolean contains(Object o) {<br>14             return containsValue(o);<br>15         }<br>16         public void clear() {<br>17             HashMap.this.clear();<br>18         }<br>19     }<br>    values()方法也一样是代理。只是Values类继承自AbstractCollention类，而不是AbstractSet。</v></v></v></v></p>\n<hr>\n<ol>\n<li>HashMap概述：</li>\n</ol>\n<p>　　HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<ol>\n<li>HashMap的数据结构：</li>\n</ol>\n<p>　　在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。</p>\n<p>　　从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：</p>\n<p>/**</p>\n<ul>\n<li>The table, resized as necessary. Length MUST Always be a power of two.<br>*/<br>transient Entry[] table;</li>\n</ul>\n<p>static class Entry<k,v> implements Map.Entry<k,v> {<br>    final K key;<br>    V value;<br>    Entry<k,v> next;<br>    final int hash;<br>    ……<br>}<br>　　可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</k,v></k,v></k,v></p>\n<ol>\n<li><p>HashMap的存取实现：</p>\n<p>1) 存储：</p>\n</li>\n</ol>\n<p>public V put(K key, V value) {<br>    // HashMap允许存放null键和null值。<br>    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。<br>    if (key == null)<br>        return putForNullKey(value);<br>    // 根据key的hashCode重新计算hash值。<br>    int hash = hash(key.hashCode());<br>    // 搜索指定hash值所对应table中的索引。<br>    int i = indexFor(hash, table.length);<br>    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。<br>    for (Entry<k,v> e = table[i]; e != null; e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(this);<br>            return oldValue;<br>        }<br>    }<br>    // 如果i索引处的Entry为null，表明此处还没有Entry。<br>    // modCount记录HashMap中修改结构的次数<br>    modCount++;<br>    // 将key、value添加到i索引处。<br>    addEntry(hash, key, value, i);<br>    return null;<br>}<br>　　从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</k,v></p>\n<p>　　addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：</p>\n<p>void addEntry(int hash, K key, V value, int bucketIndex) {<br>    // 获取指定 bucketIndex 索引处的 Entry<br>    Entry<k,v> e = table[bucketIndex];<br>    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry<br>    table[bucketIndex] = new Entry<k,v>(hash, key, value, e);<br>    // 如果 Map 中的 key-value 对的数量超过了极限<br>    if (size++ &gt;= threshold)<br>    // 把 table 对象的长度扩充到原来的2倍。<br>        resize(2 * table.length);<br>}<br>　　当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</k,v></k,v></p>\n<p>　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>\n<p>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>　　我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>\n<p>　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>\n<p>static int indexFor(int h, int length) {<br>    return h &amp; (length-1);<br>}<br>　　这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：</p>\n<p>int capacity = 1;<br>    while (capacity &lt; initialCapacity)<br>        capacity &lt;&lt;= 1;<br>　　这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。</p>\n<p>　　当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>\n<p>　　这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>\n<p>　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：</p>\n<pre><code> h &amp; (table.length-1)                     hash                             table.length-1\n\n 8 &amp; (15-1)：                                 0100                   &amp;              1110                   =                0100\n\n 9 &amp; (15-1)：                                 0101                   &amp;              1110                   =                0100\n\n-----------------------------------------------------------------------------------------------------------------------\n\n 8 &amp; (16-1)：                                 0100                   &amp;              1111                   =                0100\n\n 9 &amp; (16-1)：                                 0101                   &amp;              1111                   =                0101\n\n-----------------------------------------------------------------------------------------------------------------------\n</code></pre><p>　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&amp;”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&amp;”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！</p>\n<p>　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>\n<p>　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>\n<p>　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>\n<p>  2) 读取：</p>\n<p>public V get(Object key) {<br>    if (key == null)<br>        return getForNullKey();<br>    int hash = hash(key.hashCode());<br>    for (Entry<k,v> e = table[indexFor(hash, table.length)];<br>        e != null;<br>        e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br>            return e.value;<br>    }<br>    return null;<br>}<br>　　有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</k,v></p>\n<p>  3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>\n<ol>\n<li>HashMap的resize（rehash）：</li>\n</ol>\n<p>　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>\n<p>　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>\n<p>HashMap扩容的代码如下所示：</p>\n<p>//HashMap数组扩容<br>          void resize(int newCapacity) {<br>                Entry[] oldTable = table;<br>                int oldCapacity = oldTable.length;<br>                //如果当前的数组长度已经达到最大值，则不在进行调整<br>                if (oldCapacity == MAXIMUM_CAPACITY) {<br>                    threshold = Integer.MAX_VALUE;<br>                    return;<br>                }<br>                //根据传入参数的长度定义新的数组<br>                Entry[] newTable = new Entry[newCapacity];<br>                //按照新的规则，将旧数组中的元素转移到新数组中<br>                transfer(newTable);<br>                table = newTable;<br>                //更新临界值<br>                threshold = (int)(newCapacity * loadFactor);<br>            }</p>\n<pre><code>//旧数组中元素往新数组中迁移\n  void transfer(Entry[] newTable) {\n      //旧数组\n      Entry[] src = table;\n      //新数组长度\n      int newCapacity = newTable.length;\n      //遍历旧数组\n      for (int j = 0; j &lt; src.length; j++) {\n          Entry&lt;K,V&gt; e = src[j];\n          if (e != null) {\n              src[j] = null;\n              do {\n                  Entry&lt;K,V&gt; next = e.next;\n                  int i = indexFor(e.hash, newCapacity);\n                  e.next = newTable[i];\n                  newTable[i] = e;\n                  e = next;\n              } while (e != null);\n          }\n      }\n  }\n</code></pre><p>5.HashMap的性能参数：</p>\n<p>HashMap 包含如下几个构造器：</p>\n<p>   HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。<br>   HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。<br>   HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。    initialCapacity：HashMap的最大容量，即为底层数组的长度。 loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。<br>　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</p>\n<p>　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：</p>\n<p>threshold = (int)(capacity * loadFactor);<br>　　结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：</p>\n<p>if (size++ &gt;= threshold)<br>    resize(2 * table.length);<br>6.Fail-Fast机制：</p>\n<p>　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）</p>\n<p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>\n<p>HashIterator() {<br>    expectedModCount = modCount;<br>    if (size &gt; 0) { // advance to first entry<br>    Entry[] t = table;<br>    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)<br>        ;<br>    }<br>}<br>　　在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>\n<p>　　注意到modCount声明为volatile，保证线程之间修改的可见性。</p>\n<pre><code>（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。\n</code></pre><p>final Entry<k,v> nextEntry() {<br>    if (modCount != expectedModCount)<br>        throw new ConcurrentModificationException();<br>在HashMap的API中指出：</k,v></p>\n<p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p>\n<p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>\n","excerpt":"","more":"<p>参考文章：<a href=\"http://blog.csdn.net/pandajava/article/details/42391733\"> java源码分析 —- HashMap源码分析 及其 实现原理分析</a></p>\n<p>HashMap 在java集合中来说算是比较重要的一个类了。其源码也是在面试过程中经常被问的一道面试题。之前自己也大略的看过，现在抱着一起学习的态度，分析一下HashMap的源码。</p>\n<h3 id=\"0-所处位置\"><a href=\"#0-所处位置\" class=\"headerlink\" title=\"0. 所处位置\"></a>0. 所处位置</h3><p>学过Java集合的人都应该看过张图(《Java编程思想》关于容器类库的简介图)<br> <img src=\"/img/java/collection.png\" alt=\"\"></p>\n<h3 id=\"1-HashMap的数据结构\"><a href=\"#1-HashMap的数据结构\" class=\"headerlink\" title=\"1. HashMap的数据结构\"></a>1. HashMap的数据结构</h3><p>数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。<br>数组<br>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；<br>链表<br>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。<br>哈希表<br>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。<br>　　哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图：</p>\n<p>　　从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。<br>比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。<br>　　HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。<br>　　首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。<br>    /**</p>\n<pre><code> * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\n</code></pre><h3 id=\"2-HashMap源码分析\"><a href=\"#2-HashMap源码分析\" class=\"headerlink\" title=\"2. HashMap源码分析\"></a>2. HashMap源码分析</h3><p> HashMap继承自AbstractMap，实现了Map接口（这些内容可以参考《Java集合类》）。来看类的定义。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap&lt;K</span>,<span class=\"title\">V&gt;</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap&lt;K</span>,<span class=\"title\">V&gt;</span> <span class=\"title\">implements</span> <span class=\"title\">Map&lt;K</span>,<span class=\"title\">V&gt;</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></div></pre></td></tr></table></figure>\n<pre><code>Map接口定义了所有Map子类必须实现的方法。Map接口中还定义了一个内部接口Entry。\n\nAbstractMap也实现了Map接口，并且提供了两个实现Entry的内部类：SimpleEntry和SimpleImmutableEntry。\n\n定义了接口，接口中又有内部接口，然后有搞了个抽象类实现接口，抽象类里面又搞了两个内部类实现接口的内部接口，有没有点绕，为什么搞成这样呢？先不管了，先看HashMap吧。\n\nHashMap中定义的属性（应该都能看明白，不过还是解释一下）：\n</code></pre><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * 默认的初始容量，必须是2的幂。</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">    * 默认装载因子，这个后面会做解释</div><div class=\"line\">   */</span></div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75</span>f;</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 存储数据的Entry数组，长度是2的幂。看到数组的内容了，接着看数组中存的内容就明白为什么博文开头先复习数据结构了</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">transient</span> Entry[] table;</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * map中保存的键值对的数量</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> <span class=\"keyword\">size</span>;</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    * 需要调整大小的极限值（容量*装载因子）</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">int</span> threshold;</div><div class=\"line\">   <span class=\"comment\">/**</div><div class=\"line\">    *装载因子</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">    * map结构被改变的次数</div><div class=\"line\">    */</span></div><div class=\"line\">   <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> modCount;</div></pre></td></tr></table></figure>\n<p>接着是HashMap的构造方法。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     *使用默认的容量及装载因子构造一个空的HashMap</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class=\"line\">        threshold = (<span class=\"built_in\">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);<span class=\"comment\">//计算下次需要调整大小的极限值</span></div><div class=\"line\">        table = <span class=\"keyword\">new</span> Entry[DEFAULT_INITIAL_CAPACITY];    <span class=\"comment\">//根据默认容量（16）初始化table</span></div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     * 根据给定的初始容量的装载因子创建一个空的HashMap</div><div class=\"line\">     * 初始容量小于0或装载因子小于等于0将报异常 </div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(<span class=\"built_in\">int</span> initialCapacity, <span class=\"built_in\">float</span> loadFactor) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</div><div class=\"line\">                                               initialCapacity);</div><div class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<span class=\"comment\">//调整最大容量</span></div><div class=\"line\">            initialCapacity = MAXIMUM_CAPACITY;</div><div class=\"line\">        <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</div><div class=\"line\">                                               loadFactor);</div><div class=\"line\">        <span class=\"built_in\">int</span> capacity = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//设置capacity为大于initialCapacity且是2的幂的最小值</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)  <span class=\"comment\">// 假设initialCapacity的值为30 则capacity的值 最终问2的5次方 32 。</span></div><div class=\"line\">            capacity &lt;&lt;= <span class=\"number\">1</span>;                 <span class=\"comment\">//也就是说hashMap中entry[] 的初始化大小是32 而非30。</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loadFactor = loadFactor;</div><div class=\"line\">        threshold = (<span class=\"built_in\">int</span>)(capacity * loadFactor);</div><div class=\"line\">        table = <span class=\"keyword\">new</span> Entry[capacity];</div><div class=\"line\">        init();</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     *根据指定容量创建一个空的HashMap</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(<span class=\"built_in\">int</span> initialCapacity) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<span class=\"comment\">//调用上面的构造方法，容量为指定的容量，装载因子是默认值</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">     *通过传入的map创建一个HashMap，容量为默认容量（16）和(map.zise()/DEFAULT_LOAD_FACTORY)+1的较大者，装载因子为默认值</div><div class=\"line\">     */</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">HashMap</span>(Map&lt;? extends K, ? extends V&gt; m) &#123;</div><div class=\"line\">        <span class=\"comment\">//调用构造方法 传入相关参数 并完成初始化</span></div><div class=\"line\">        <span class=\"keyword\">this</span>(Math.<span class=\"built_in\">max</span>((<span class=\"built_in\">int</span>) (m.<span class=\"built_in\">size</span>() / DEFAULT_LOAD_FACTOR) + <span class=\"number\">1</span>,DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class=\"line\">       </div><div class=\"line\">        putAllForCreate(m);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>上面的构造方法中调用到了init()方法，最后一个方法还调用了</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">putAllForCreate(<span class=\"built_in\">Map</span>&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m)。</div></pre></td></tr></table></figure>\n<p>init方法是一个空方法，里面没有任何内容。（其作用为何？）<br>putAllForCreate看方法名就是创建的时候将传入的map全部放入新创建的对象中。该方法中还涉及到其他方法，将在后面介绍。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private <span class=\"keyword\">void</span> putAllForCreate(<span class=\"built_in\">Map</span>&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; m) &#123;  </div><div class=\"line\">      <span class=\"keyword\">for</span> (&lt;strong&gt;<span class=\"built_in\">Iterator</span>&lt;? <span class=\"keyword\">extends</span> <span class=\"built_in\">Map</span>.Entry&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt;&gt; i =&lt;u&gt; m.entrySet().iterator()&lt;/u&gt;; i.hasNext();&lt;/strong&gt; ) &#123;  </div><div class=\"line\">          &lt;strong&gt;<span class=\"built_in\">Map</span>.Entry&lt;? <span class=\"keyword\">extends</span> K, ? <span class=\"keyword\">extends</span> V&gt; e = i.next();&lt;/strong&gt;  </div><div class=\"line\">          &lt;u&gt;putForCreate(e.getKey(), e.getValue());&lt;/u&gt;  </div><div class=\"line\">      &#125;  </div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">``` </div><div class=\"line\">  </div><div class=\"line\">先看初始化table时均使用了Entry，这是HashMap的一个内部类，实现了<span class=\"built_in\">Map</span>接口的内部接口Entry。下面给出<span class=\"built_in\">Map</span>.Entry接口及HashMap.Entry类的内容。<span class=\"built_in\">Map</span>.Entry接口定义的方法</div></pre></td></tr></table></figure>\n<p> K getKey();//获取Key<br> V getValue();//获取Value<br> V setValue();//设置Value，至于具体返回什么要看具体实现<br> boolean equals(Object o);//定义equals方法用于判断两个Entry是否相同<br> int hashCode();//定义获取hashCode的方法</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">HashMap.<span class=\"keyword\">Entry</span>类的具体实现</div></pre></td></tr></table></figure>\n<p>  static class Entry<K,V> implements Map.Entry<K,V> {<br>          final K key;<br>          V value;<br>          Entry<K,V> next;//对下一个节点的引用（看到链表的内容，结合定义的Entry数组，是不是想到了哈希表的拉链法实现？！）<br>          final int hash;//哈希值</p>\n<pre><code>     Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {\n         value = v;\n         next = n;\n        key = k;\n        hash = h;\n    }\n\n    public final K getKey() {\n        return key;\n    }\n\n    public final V getValue() {\n        return value;\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n       value = newValue;\n        return oldValue;//返回的是之前的Value\n    }\n\n    public final boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))//先判断类型是否一致\n               return false;\n        Map.Entry e = (Map.Entry)o;\n        Object k1 = getKey();\n        Object k2 = e.getKey();\n        // Key相等且Value相等则两个Entry相等\n        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {\n            Object v1 = getValue();\n            Object v2 = e.getValue();\n            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n    // hashCode是Key的hashCode和Value的hashCode的异或的结果\n    public final int hashCode() {\n        return (key==null   ? 0 : key.hashCode()) ^\n              (value==null ? 0 : value.hashCode());\n    }\n    // 重写toString方法，是输出更清晰\n    public final String toString() {\n        return getKey() + &quot;=&quot; + getValue();\n   }\n\n   /**\n     *当调用put(k,v)方法存入键值对时，如果k已经存在，则该方法被调用（为什么没有内容？）\n     */\n   void recordAccess(HashMap&lt;K,V&gt; m) {\n   }\n\n   /**\n     * 当Entry被从HashMap中移除时被调用（为什么没有内容？）\n     */\n    void recordRemoval(HashMap&lt;K,V&gt; m) {\n    }\n}\n</code></pre><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">看完属性和构造方法，接着看HashMap中的其他方法，一个个分析，从最常用的<span class=\"built_in\">put</span>和<span class=\"built_in\">get</span>说起吧。</div><div class=\"line\"><span class=\"built_in\">put</span>()该方法 返回与 <span class=\"built_in\">key</span> 关联的旧值；如果<span class=\"built_in\">key</span> 没有任何映射关系，则返回null。</div></pre></td></tr></table></figure>\n<p>  public V put(K key, V value) {<br>          if (key == null)<br>              return putForNullKey(value);</p>\n<pre><code>      int hash = hash(key.hashCode());\n      int i = indexFor(hash, table.length);  //获取应该存放的索引值\n\n      for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {  //校验key值之前是否存在，存在则替换并返回先前的值\n         Object k;\n         if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n             V oldValue = e.value;\n             e.value = value;\n             e.recordAccess(this);\n             return oldValue;\n         }\n     }\n\n     // 该key之前不存在 则 执行 添加操作\n     modCount++;\n     addEntry(hash, key, value, i);   //四个参数 hash值  key  value  i索引\n     return null;\n }\n当存入的key是null的时候将调用putForNUllKey方法，暂时将这段逻辑放一边，看key不为null的情况。\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">先调用了<span class=\"built_in\">hash</span>(int h)方法获取了一个<span class=\"built_in\">hash</span>值。</div></pre></td></tr></table></figure>\n<p> static int hash(int h) {<br>         // This function ensures that hashCodes that differ only by<br>        // constant multiples at each bit position have a bounded<br>         // number of collisions (approximately 8 at default load factor).<br>        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>         return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>    }<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">这个方法的主要作用是防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占<span class=\"number\">4</span>个字节，即<span class=\"number\">32</span>位。根据这<span class=\"number\">32</span>位值进行移位、异或运算得到一个值。</div></pre></td></tr></table></figure></p>\n<p> static int indexFor(int h, int length) {<br>         return h &amp; (length-1);<br>     }<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">indexFor返回hash值和table数组长度减<span class=\"number\">1</span>的与运算结果，获取索引位置。</div><div class=\"line\">为什么使用的是length<span class=\"number\">-1</span>？因为这样可以保证结果的最大值是length<span class=\"number\">-1</span>，不会产生数组越界问题。获取索引位置之后做了什么？探测table[i]所在的链表，所发现<span class=\"type\">key</span>值与传入的<span class=\"type\">key</span>值相同的对象，则替换并返回oldValue。（<span class=\"type\">key</span>值之前存在，替换并且返回旧值）若找不到，则通过addEntry(hash,<span class=\"type\">key</span>,value,i)添加新的对象。 （<span class=\"type\">key</span>值之前不存在，添加addEntry方法 ，并返回null）</div><div class=\"line\"></div><div class=\"line\">来看addEntry(hash,<span class=\"type\">key</span>,value,i)方法。</div></pre></td></tr></table></figure></p>\n<p>void addEntry(int hash, K key, V value, int bucketIndex) {<br>         Entry<K,V> e = table[bucketIndex];   //bucketIndex位置的元素先保存起来（新加的entry要占据这个位置）<br>         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);//将新的值存到bucketIndex处，该值的next指向 刚刚保存的e元素<br>         //检测是不是需要扩充容量 （2倍2倍的扩容）<br>          if (size++ &gt;= threshold)   // threshold默认值 是  16 <em> 0.75 = 12             resize(2 </em> table.length);<br>  }<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">这就是在一个链表头部插入一个节点的过程。获取<span class=\"keyword\">table</span>[i]的对象e，将<span class=\"keyword\">table</span>[i]的对象修改为新增对象，让新增对象的next指向e。之后判断size是否到达了需要扩充<span class=\"keyword\">table</span>数组容量的界限并让size自增1，如果达到了则调用resize(int <span class=\"comment\">capacity)</span>方法将数组容量拓展为原来的两倍。</div></pre></td></tr></table></figure></p>\n<p> void resize(int newCapacity) {<br>          Entry[] oldTable = table;<br>          int oldCapacity = oldTable.length;<br>          // 这个if块表明，如果容量已经到达允许的最大值，即MAXIMUN_CAPACITY，则不再拓展容量，而将装载拓展的界限值设为计算机允许的最大值。<br>         // 不会再触发resize方法，而是不断的向map中添加内容，即table数组中的链表可以不断变长，但数组长度不再改变<br>         if (oldCapacity == MAXIMUM_CAPACITY) {  //MAXIMUM_CAPACITY  1073741824 [0x40000000]<br>             threshold = Integer.MAX_VALUE;<br>             return;<br>          }<br>         // 创建新数组，容量为指定的容量<br>         Entry[] newTable = new Entry[newCapacity];<br>         transfer(newTable);<br>         table = newTable;<br>         // 设置下一次需要调整数组大小的界限<br>         threshold = (int)(newCapacity * loadFactor);<br>     }<br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 结合上面给出的注释，调整数组容量的内容仅剩下将原<span class=\"keyword\">table</span>中的内容复制到newTable中并将newTable赋值给给<span class=\"keyword\">table</span>变量。即上面代码中的“transfer(newTable);<span class=\"keyword\">table</span> <span class=\"comment\">= newTable</span>;”。</div><div class=\"line\">来看transfer(Entry[] newTable)方法。</div></pre></td></tr></table></figure></p>\n<p>  void transfer(Entry[] newTable) {<br>          // 保留原数组的引用到src中，<br>          Entry[] src = table;<br>          // 新容量使新数组的长度<br>          int newCapacity = newTable.length;<br>          // 遍历原数组<br>         for (int j = 0; j &lt; src.length; j++) {<br>              // 获取元素e （此处的e是单链表的头结点）<br>              Entry<K,V> e = src[j];<br>             if (e != null) {<br>                 // 将原数组中的元素置为null<br>                 src[j] = null;<br>                 // 遍历原数组中j位置指向的链表<br>                 do {<br>                     Entry<K,V> next = e.next;<br>                     // 根据新的容量计算e在新数组中的位置<br>                     int i = indexFor(e.hash, newCapacity);<br>                     // 将e插入到newTable[i]指向的链表的头部<br>                     e.next = newTable[i];<br>                     newTable[i] = e;<br>                    e = next;<br>                 } while (e != null);<br>             }<br>         }<br>     }<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这样处理效果 原来的 单链表如果 顺序是  （头） <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> c d e  （尾）通过  transfer方法之后的顺序是  (头)  e  d c  <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">a</span> （尾）  因为后插入的在 链表的头部。从上面的代码可以看出，HashMap之所以不能保持元素的顺序有以下几点原因：</div><div class=\"line\"></div><div class=\"line\">    第一，插入元素的时候对元素进行哈希处理，不同元素分配到table的不同位置；</div><div class=\"line\">    第二，容量拓展的时候又进行了hash处理；</div><div class=\"line\">    第三，复制原表内容的时候链表被倒置。</div><div class=\"line\"></div><div class=\"line\">一个put方法带出了这么多内容，接着看看putAll吧。</div></pre></td></tr></table></figure></p>\n<p>  public void putAll(Map&lt;? extends K, ? extends V&gt; m) {<br>          int numKeysToBeAdded = m.size();<br>          if (numKeysToBeAdded == 0)<br>              return;<br>          // 为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+table.length)&gt;threshold???<br>         if (numKeysToBeAdded &gt; threshold) {<br>              int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);<br>              if (targetCapacity &gt; MAXIMUM_CAPACITY)<br>                 targetCapacity = MAXIMUM_CAPACITY;<br>             int newCapacity = table.length;<br>             while (newCapacity &lt; targetCapacity)<br>                 newCapacity &lt;&lt;= 1;<br>             if (newCapacity &gt; table.length)<br>                 resize(newCapacity);<br>         }</p>\n<pre><code>    for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {\n       Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();\n        put(e.getKey(), e.getValue());\n    }\n}\n</code></pre><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">先回答上面的问题：为什么判断条件是numKeysToBeAdded，不是(numKeysToBeAdded+<span class=\"keyword\">table</span>.length)&gt;threshold </div><div class=\"line\">这是一种保守的做法，明显地，我们应该在(numKeysToBeAdded+<span class=\"keyword\">table</span>.length)&gt;threshold的时候去拓展容量，但是考虑到将被添加的元素可能会有Key与原本存在的Key相同的情况，所以采用保守的做法，避免拓展到过大的容量。 接着是遍历m中的内容，然后调用put方法将元素添加到<span class=\"keyword\">table</span>数组中。遍历的时候涉及到了entrySet方法，这个方法定义在Map接口中，HashMap中也有实现，后面会解释HashMap的这个方法，其它Map的实现暂不解释。</div><div class=\"line\"></div><div class=\"line\">\t下面介绍在put方法中被调用到的putForNullKey方法。</div></pre></td></tr></table></figure>\n<p> private V putForNullKey(V value) {<br>         for (Entry<K,V> e = table[0]; e != null; e = e.next) {<br>             if (e.key == null) {<br>                 V oldValue = e.value;<br>                 e.value = value;<br>                 e.recordAccess(this);<br>                  return oldValue;<br>             }<br>         }<br>         modCount++;<br>         addEntry(0, null, value, 0); // null 的 hash值是0 。 索引位置 index也是 0<br>        return null;<br>     }<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这是一个私有方法，在<span class=\"built_in\">put</span>方法中被调用。它首先遍历table数组，如果找到key为<span class=\"literal\">null</span>的元素，则替换元素值并返回oldValue；否则通过addEntry方法添加元素，之后返回<span class=\"literal\">null</span>。还记得上面构造方法中调用到的putAllForCreate吗？一口气将<span class=\"built_in\">put</span>操作的方法看完吧。</div></pre></td></tr></table></figure></p>\n<p> private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {<br>         for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) {<br>             Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();<br>             putForCreate(e.getKey(), e.getValue());<br>         }<br>     }<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">先将遍历的过程放在一边，因为它同样涉及到了entrySet()方法。剩下的代码很简单，只是调用putForCreate方法逐个元素加入。</div></pre></td></tr></table></figure></p>\n<p> private void putForCreate(K key, V value) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          int i = indexFor(hash, table.length);<br>          for (Entry<K,V> e = table[i]; e != null; e = e.next) {<br>              Object k;<br>              if (e.hash == hash &amp;&amp;<br>                  ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {<br>                  e.value = value;<br>                  return;<br>             }<br>         }<br>         createEntry(hash, key, value, i);<br>     }<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">该方法先计算需要添加的元素的hash值和在table数组中的索引i。接着遍历table[i]的链表，若有元素的<span class=\"built_in\">key</span>值与传入<span class=\"built_in\">key</span>值相等，则替换<span class=\"built_in\">value</span>，       结束方法。若不存在<span class=\"built_in\">key</span>值相同的元素，则调用createEntry创建并添加元素。</div></pre></td></tr></table></figure></p>\n<p>void createEntry(int hash, K key, V value, int bucketIndex) {<br>          Entry<K,V> e = table[bucketIndex];<br>         table[bucketIndex] = new Entry<K,V>(hash, key, value, e);<br>         size++;<br>     }<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这个方法的内容就不解释了，上面都解释过。 至此所有<span class=\"keyword\">put</span>相关操作都解释完毕了。<span class=\"keyword\">put</span>之外，另一个常用的操作就是<span class=\"keyword\">get</span>，下面就来看<span class=\"keyword\">get</span>方法。</div></pre></td></tr></table></figure></p>\n<p> public V get(Object key) {<br>          if (key == null)<br>              return getForNullKey();<br>          int hash = hash(key.hashCode());<br>          for (Entry<K,V> e = table[indexFor(hash, table.length)];e != null; e = e.next) {<br>              Object k;<br>              if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br>                 return e.value;<br>         }<br>         return null;<br>     }<br> <figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">     </div><div class=\"line\"> 该方法分为<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>和不为<span class=\"keyword\">null</span>两块。先看不为<span class=\"keyword\">null</span>的情况。先获取<span class=\"built_in\">key</span>的hash值，之后通过hash值及table.length获取<span class=\"built_in\">key</span>对应的table数组的索引，遍历索引的链表，所找到<span class=\"built_in\">key</span>相同的元素，则返回元素的value，否者返回<span class=\"keyword\">null</span>。不为<span class=\"keyword\">null</span>的情况调用了getForNullKey()方法。</div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">private</span> V getForNullKey() &#123;</div><div class=\"line\"><span class=\"number\">2</span>         <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</div><div class=\"line\"><span class=\"number\">3</span>             <span class=\"keyword\">if</span> (e.<span class=\"built_in\">key</span> == <span class=\"keyword\">null</span>)</div><div class=\"line\"><span class=\"number\">4</span>                 <span class=\"keyword\">return</span> e.value;</div><div class=\"line\"><span class=\"number\">5</span>         &#125;</div><div class=\"line\"><span class=\"number\">6</span>         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">7</span>     &#125;</div><div class=\"line\">    这是一个私有方法，只在<span class=\"built_in\">get</span>中被调用。该方法判断table[<span class=\"number\">0</span>]中的链表是否包含<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>的元素，包含则返回value，不包含则返回<span class=\"keyword\">null</span>。为什么是遍历table[<span class=\"number\">0</span>]的链表？因为<span class=\"built_in\">key</span>为<span class=\"keyword\">null</span>的时候获得的hash值都是<span class=\"number\">0</span>。</div><div class=\"line\">添加（put）和获取（<span class=\"built_in\">get</span>）都结束了，接着看如何判断一个元素是否存在。</div><div class=\"line\"><span class=\"keyword\">HashMap</span>没有提供判断元素是否存在的方法，只提供了判断Key是否存在及Value是否存在的方法，分别是containsKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)、containsValue(<span class=\"keyword\">Object</span> value)。</div><div class=\"line\">containsKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)方法很简单，只是判断getEntry(<span class=\"built_in\">key</span>)的结果是否为<span class=\"keyword\">null</span>，是则返回<span class=\"keyword\">false</span>，否返回<span class=\"keyword\">true</span>。</div></pre></td></tr></table></figure></p>\n<p> public boolean containsKey(Object key) {<br>          return getEntry(key) != null;<br>      }<br>  final Entry<K,V> getEntry(Object key) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) {<br>              Object k;<br>             if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                 return e;<br>         }<br>         return null;<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">getEntry(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)也没什么内容，只是根据<span class=\"built_in\">key</span>对应的hash值计算在table数组中的索引位置，然后遍历该链表判断是否存在相同的<span class=\"built_in\">key</span>值。</div></pre></td></tr></table></figure></p>\n<p>  public boolean containsValue(Object value) {<br>      if (value == null)<br>              return containsNullValue();</p>\n<pre><code> Entry[] tab = table;\n     for (int i = 0; i &lt; tab.length ; i++)\n         for (Entry e = tab[i] ; e != null ; e = e.next)\n             if (value.equals(e.value))\n                 return true;\nreturn false;\n}\n</code></pre><p> private boolean containsNullValue() {<br>     Entry[] tab = table;<br>         for (int i = 0; i &lt; tab.length ; i++)<br>             for (Entry e = tab[i] ; e != null ; e = e.next)<br>                 if (e.value == null)<br>                     return true;<br>     return false;<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">判断一个value是否存在比判断<span class=\"built_in\">key</span>是否存在还要简单，就是遍历所有元素判断是否有相等的值。这里分为两种情况处理，value为<span class=\"keyword\">null</span>何不为<span class=\"keyword\">null</span>的情况，但内容差不多，只是判断相等的方式不同。这个判断是否存在必须遍历所有元素，是一个双重循环的过程，因此是比较耗时的操作。接着看<span class=\"keyword\">HashMap</span>中“删除”相关的操作，有remove(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)和<span class=\"built_in\">clear</span>()两个方法。</div><div class=\"line\"></div><div class=\"line\">    remove(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)</div></pre></td></tr></table></figure></p>\n<p>public V remove(Object key) {<br>         Entry<K,V> e = removeEntryForKey(key);<br>         return (e == null ? null : e.value);<br>     }<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">看这个方法，removeEntryKey(<span class=\"built_in\">key</span>)的返回结果应该是被移除的元素，如果不存在这个元素则返回为<span class=\"keyword\">null</span>。remove方法根据removeEntryKey返回的结果e是否为<span class=\"keyword\">null</span>返回<span class=\"keyword\">null</span>或e.value。</div><div class=\"line\"></div><div class=\"line\">    removeEntryForKey(<span class=\"keyword\">Object</span> <span class=\"built_in\">key</span>)</div></pre></td></tr></table></figure></p>\n<p>  final Entry<K,V> removeEntryForKey(Object key) {<br>          int hash = (key == null) ? 0 : hash(key.hashCode());<br>          int i = indexFor(hash, table.length);<br>          Entry<K,V> prev = table[i];<br>          Entry<K,V> e = prev;</p>\n<pre><code>     while (e != null) {\n         Entry&lt;K,V&gt; next = e.next;\n         Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {\n            modCount++;\n            size--;\n            if (prev == e)\n                table[i] = next;\n            else\n                prev.next = next;\n            e.recordRemoval(this);\n            return e;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return e;\n}\n</code></pre><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    上面的这个过程就是先找到<span class=\"built_in\">table</span>数组中对应的索引，接着就类似于一般的链表的删除操作，而且是单向链表删除节点，很简单。在C语言中就是修改指针，这个例子中就是将要删除节点的前一节点的<span class=\"built_in\">next</span>指向删除被删除节点的<span class=\"built_in\">next</span>即可。</div><div class=\"line\"></div><div class=\"line\">clear()</div></pre></td></tr></table></figure>\n<p> public void clear() {<br>         modCount++;<br>         Entry[] tab = table;<br>         for (int i = 0; i &lt; tab.length; i++)<br>             tab[i] = null;<br>         size = 0;<br>    }<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">clear</span><span class=\"params\">()</span></span>方法删除HashMap中所有的元素，这里就不用一个个删除节点了，而是直接将table数组内容都置空，这样所有的链表都已经无法访问，Java的垃圾回收机制会去处理这些链表。table数组置空后修改size为<span class=\"number\">0</span>。这里为什么不直接操作table而是通过tab呢？希望有知道的大侠指点一二。主要方法看的差不多了，接着看一个上面提到了好几次但是都搁在一边没有分析的方法：entrySet()。 </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">entrySet</span><span class=\"params\">()</span></span></div></pre></td></tr></table></figure></p>\n<pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {\n return entrySet0();\n</code></pre><p>   }</p>\n<pre><code>private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() {\n     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;\n     return es != null ? es : (entrySet = new EntrySet());\n}\n</code></pre><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">为什么会有这样的方法，只是调用了一下entrySet0，而且entrySet0的名称看着就很奇怪。再看entrySet0方法中为什么不直接<span class=\"keyword\">return</span> entrySet!=<span class=\"literal\">null</span>?entrySet:(entrySet = <span class=\"keyword\">new</span> EntrySet)呢？上面的疑问还没解开，但是先看entrySet这个属性吧，在文章开头的属性定义中并没有给出这个属性，下面先看一下它的定义：</div></pre></td></tr></table></figure>\n<p>private transient Set<Map.Entry<K,V>&gt; entrySet = null;</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">它是一个内容为<span class=\"keyword\">Map</span>.Entry&lt;<span class=\"keyword\">K</span>,V&gt;的<span class=\"keyword\">Set</span>。看看在哪些地方往里面添加了元素。 为什么上面的那句话我要把它标成红色？因为这是一个陷阱，在看代码的时候我就陷进去了。仔细看EntrySet这个类。</div></pre></td></tr></table></figure>\n<p>private final class EntrySet extends AbstractSet<Map.Entry<K,V>&gt; {<br>         public Iterator<Map.Entry<K,V>&gt; iterator() {<br>             return new EntryIterator();<br>         }<br>         public boolean contains(Object o) {<br>            if (!(o instanceof Map.Entry))<br>                 return false;<br>             Map.Entry<K,V> e = (Map.Entry<K,V>) o;<br>             Entry<K,V> candidate = getEntry(e.getKey());<br>             return candidate != null &amp;&amp; candidate.equals(e);<br>         }<br>         public boolean remove(Object o) {<br>             return removeMapping(o) != null;<br>         }<br>         public int size() {<br>             return size;<br>         }<br>         public void clear() {<br>             HashMap.this.clear();<br>         }<br> }</p>\n<p>```<br>看到了什么？这个类根本就没属性，它只是个代理。因为它内部类，可以访问外部类的内容，debug的时候能看到的属性都是继承或者外部类的属性，输出的时候其实也是调用到了父类的toString方法将HashMap中的内容输出了。</p>\n<pre><code>keySet()\n</code></pre><p>1 public Set<K> keySet() {<br>2         Set<K> ks = keySet;<br>3         return (ks != null ? ks : (keySet = new KeySet()));<br>4     }<br>    是不是和entrySet0()方法很像！</p>\n<p> 1 private final class KeySet extends AbstractSet<K> {<br> 2         public Iterator<K> iterator() {<br> 3             return newKeyIterator();<br> 4         }<br> 5         public int size() {<br> 6             return size;<br> 7         }<br> 8         public boolean contains(Object o) {<br> 9             return containsKey(o);<br>10         }<br>11         public boolean remove(Object o) {<br>12             return HashMap.this.removeEntryForKey(o) != null;<br>13         }<br>14         public void clear() {<br>15             HashMap.this.clear();<br>16         }<br>17     }<br>复制代码<br>    同样是个代理类，contains、remove、clear方法都是调用的HashMap的方法。 </p>\n<pre><code>values()\n</code></pre><p> 1 public Collection<V> values() {<br> 2         Collection<V> vs = values;<br> 3         return (vs != null ? vs : (values = new Values()));<br> 4     }<br> 5<br> 6     private final class Values extends AbstractCollection<V> {<br> 7         public Iterator<V> iterator() {<br> 8             return newValueIterator();<br> 9         }<br>10         public int size() {<br>11             return size;<br>12         }<br>13         public boolean contains(Object o) {<br>14             return containsValue(o);<br>15         }<br>16         public void clear() {<br>17             HashMap.this.clear();<br>18         }<br>19     }<br>    values()方法也一样是代理。只是Values类继承自AbstractCollention类，而不是AbstractSet。</p>\n<hr>\n<ol>\n<li>HashMap概述：</li>\n</ol>\n<p>　　HashMap是基于哈希表的Map接口的非同步实现（Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>\n<ol>\n<li>HashMap的数据结构：</li>\n</ol>\n<p>　　在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。</p>\n<p>　　从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。源码如下：</p>\n<p>/**</p>\n<ul>\n<li>The table, resized as necessary. Length MUST Always be a power of two.<br>*/<br>transient Entry[] table;</li>\n</ul>\n<p>static class Entry<K,V> implements Map.Entry<K,V> {<br>    final K key;<br>    V value;<br>    Entry<K,V> next;<br>    final int hash;<br>    ……<br>}<br>　　可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>\n<ol>\n<li><p>HashMap的存取实现：</p>\n<p>1) 存储：</p>\n</li>\n</ol>\n<p>public V put(K key, V value) {<br>    // HashMap允许存放null键和null值。<br>    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。<br>    if (key == null)<br>        return putForNullKey(value);<br>    // 根据key的hashCode重新计算hash值。<br>    int hash = hash(key.hashCode());<br>    // 搜索指定hash值所对应table中的索引。<br>    int i = indexFor(hash, table.length);<br>    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。<br>    for (Entry<K,V> e = table[i]; e != null; e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(this);<br>            return oldValue;<br>        }<br>    }<br>    // 如果i索引处的Entry为null，表明此处还没有Entry。<br>    // modCount记录HashMap中修改结构的次数<br>    modCount++;<br>    // 将key、value添加到i索引处。<br>    addEntry(hash, key, value, i);<br>    return null;<br>}<br>　　从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>\n<p>　　addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的 i 索引处。addEntry 是HashMap 提供的一个包访问权限的方法（就是没有public，protected，private这三个访问权限修饰词修饰，为默认的访问权限，用default表示，但在代码中没有这个default），代码如下：</p>\n<p>void addEntry(int hash, K key, V value, int bucketIndex) {<br>    // 获取指定 bucketIndex 索引处的 Entry<br>    Entry<K,V> e = table[bucketIndex];<br>    // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry<br>    table[bucketIndex] = new Entry<K,V>(hash, key, value, e);<br>    // 如果 Map 中的 key-value 对的数量超过了极限<br>    if (size++ &gt;= threshold)<br>    // 把 table 对象的长度扩充到原来的2倍。<br>        resize(2 * table.length);<br>}<br>　　当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>\n<p>　　hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p>\n<p>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>　　我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>\n<p>　　对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：</p>\n<p>static int indexFor(int h, int length) {<br>    return h &amp; (length-1);<br>}<br>　　这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：</p>\n<p>int capacity = 1;<br>    while (capacity &lt; initialCapacity)<br>        capacity &lt;&lt;= 1;<br>　　这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。</p>\n<p>　　当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>\n<p>　　这看上去很简单，其实比较有玄机的，我们举个例子来说明：</p>\n<p>　　假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：</p>\n<pre><code> h &amp; (table.length-1)                     hash                             table.length-1\n\n 8 &amp; (15-1)：                                 0100                   &amp;              1110                   =                0100\n\n 9 &amp; (15-1)：                                 0101                   &amp;              1110                   =                0100\n\n-----------------------------------------------------------------------------------------------------------------------\n\n 8 &amp; (16-1)：                                 0100                   &amp;              1111                   =                0100\n\n 9 &amp; (16-1)：                                 0101                   &amp;              1111                   =                0101\n\n-----------------------------------------------------------------------------------------------------------------------\n</code></pre><p>　　从上面的例子中可以看出：当8、9两个数和(15-1)2=(1110)进行“与运算&amp;”的时候，产生了相同的结果，都为0100，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与(15-1)2=(1110)进行“与运算&amp;”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！</p>\n<p>　　而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1（比如(24-1)2=1111），这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>\n<p>　　所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>\n<p>　　根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>\n<p>  2) 读取：</p>\n<p>public V get(Object key) {<br>    if (key == null)<br>        return getForNullKey();<br>    int hash = hash(key.hashCode());<br>    for (Entry<K,V> e = table[indexFor(hash, table.length)];<br>        e != null;<br>        e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))<br>            return e.value;<br>    }<br>    return null;<br>}<br>　　有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>\n<p>  3) 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>\n<ol>\n<li>HashMap的resize（rehash）：</li>\n</ol>\n<p>　　当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>\n<p>　　那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>\n<p>HashMap扩容的代码如下所示：</p>\n<p>//HashMap数组扩容<br>          void resize(int newCapacity) {<br>                Entry[] oldTable = table;<br>                int oldCapacity = oldTable.length;<br>                //如果当前的数组长度已经达到最大值，则不在进行调整<br>                if (oldCapacity == MAXIMUM_CAPACITY) {<br>                    threshold = Integer.MAX_VALUE;<br>                    return;<br>                }<br>                //根据传入参数的长度定义新的数组<br>                Entry[] newTable = new Entry[newCapacity];<br>                //按照新的规则，将旧数组中的元素转移到新数组中<br>                transfer(newTable);<br>                table = newTable;<br>                //更新临界值<br>                threshold = (int)(newCapacity * loadFactor);<br>            }</p>\n<pre><code>//旧数组中元素往新数组中迁移\n  void transfer(Entry[] newTable) {\n      //旧数组\n      Entry[] src = table;\n      //新数组长度\n      int newCapacity = newTable.length;\n      //遍历旧数组\n      for (int j = 0; j &lt; src.length; j++) {\n          Entry&lt;K,V&gt; e = src[j];\n          if (e != null) {\n              src[j] = null;\n              do {\n                  Entry&lt;K,V&gt; next = e.next;\n                  int i = indexFor(e.hash, newCapacity);\n                  e.next = newTable[i];\n                  newTable[i] = e;\n                  e = next;\n              } while (e != null);\n          }\n      }\n  }\n</code></pre><p>5.HashMap的性能参数：</p>\n<p>HashMap 包含如下几个构造器：</p>\n<p>   HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。<br>   HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。<br>   HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。    initialCapacity：HashMap的最大容量，即为底层数组的长度。 loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。<br>　　负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。</p>\n<p>　　HashMap的实现中，通过threshold字段来判断HashMap的最大容量：</p>\n<p>threshold = (int)(capacity * loadFactor);<br>　　结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子（也就是说虽然数组长度是capacity，但其扩容的临界值确是threshold）。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：</p>\n<p>if (size++ &gt;= threshold)<br>    resize(2 * table.length);<br>6.Fail-Fast机制：</p>\n<p>　　我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。（这个在core java这本书中也有提到。）</p>\n<p>　　这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>\n<p>HashIterator() {<br>    expectedModCount = modCount;<br>    if (size &gt; 0) { // advance to first entry<br>    Entry[] t = table;<br>    while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)<br>        ;<br>    }<br>}<br>　　在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>\n<p>　　注意到modCount声明为volatile，保证线程之间修改的可见性。</p>\n<pre><code>（volatile之所以线程安全是因为被volatile修饰的变量不保存缓存，直接在内存中修改，因此能够保证线程之间修改的可见性）。\n</code></pre><p>final Entry<K,V> nextEntry() {<br>    if (modCount != expectedModCount)<br>        throw new ConcurrentModificationException();<br>在HashMap的API中指出：</p>\n<p>　　由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不保证在将来不确定的时间发生任意不确定行为的风险。</p>\n<p>　　注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>\n"},{"title":"Java源码分析(二)-ArrayList","date":"2016-09-02T08:58:00.000Z","_content":"\n\n# 123\newrwrwrwer\n## 123\nwerwerwer\n## 2131312\nwerwerw\n### 123123\nwerwerw\n### 12312\n\n# 12323\n\n# 1232\n\n","source":"_posts/Java源码分析-二-ArrayList.md","raw":"---\ntitle: Java源码分析(二)-ArrayList\ndate: 2016-09-02 16:58:00\ntags:\n    - Java\n    - ArrayList\n---\n\n\n# 123\newrwrwrwer\n## 123\nwerwerwer\n## 2131312\nwerwerw\n### 123123\nwerwerw\n### 12312\n\n# 12323\n\n# 1232\n\n","slug":"Java源码分析-二-ArrayList","published":1,"updated":"2016-09-02T09:02:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlx000907fy0doqit3s","content":"<h1 id=\"123\"><a href=\"#123\" class=\"headerlink\" title=\"123\"></a>123</h1><p>ewrwrwrwer</p>\n<h2 id=\"123-1\"><a href=\"#123-1\" class=\"headerlink\" title=\"123\"></a>123</h2><p>werwerwer</p>\n<h2 id=\"2131312\"><a href=\"#2131312\" class=\"headerlink\" title=\"2131312\"></a>2131312</h2><p>werwerw</p>\n<h3 id=\"123123\"><a href=\"#123123\" class=\"headerlink\" title=\"123123\"></a>123123</h3><p>werwerw</p>\n<h3 id=\"12312\"><a href=\"#12312\" class=\"headerlink\" title=\"12312\"></a>12312</h3><h1 id=\"12323\"><a href=\"#12323\" class=\"headerlink\" title=\"12323\"></a>12323</h1><h1 id=\"1232\"><a href=\"#1232\" class=\"headerlink\" title=\"1232\"></a>1232</h1>","excerpt":"","more":"<h1 id=\"123\"><a href=\"#123\" class=\"headerlink\" title=\"123\"></a>123</h1><p>ewrwrwrwer</p>\n<h2 id=\"123-1\"><a href=\"#123-1\" class=\"headerlink\" title=\"123\"></a>123</h2><p>werwerwer</p>\n<h2 id=\"2131312\"><a href=\"#2131312\" class=\"headerlink\" title=\"2131312\"></a>2131312</h2><p>werwerw</p>\n<h3 id=\"123123\"><a href=\"#123123\" class=\"headerlink\" title=\"123123\"></a>123123</h3><p>werwerw</p>\n<h3 id=\"12312\"><a href=\"#12312\" class=\"headerlink\" title=\"12312\"></a>12312</h3><h1 id=\"12323\"><a href=\"#12323\" class=\"headerlink\" title=\"12323\"></a>12323</h1><h1 id=\"1232\"><a href=\"#1232\" class=\"headerlink\" title=\"1232\"></a>1232</h1>"},{"title":"iOS图片视频播放","date":"2015-09-13T01:51:46.000Z","_content":"","source":"_posts/iOS图片视频播放.md","raw":"title: iOS图片视频播放\ndate: 2015-09-13 09:51:46\ntags:\n---\n","slug":"iOS图片视频播放","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimlz000c07fywx2yqdvh","content":"","excerpt":"","more":""},{"title":"Java源码分析(三)-HashSet","date":"2016-09-02T09:03:49.000Z","subtitle":"Keynote: JavaScript Modularization Journey","header-img":"/img/home-bg-o.jpg","_content":"\n\n\n@(示例笔记本)[马克飞象|帮助|Markdown]\n\n**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：\n \n- **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；\n- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；\n- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。\n","source":"_posts/Java源码分析-三-HashSet.md","raw":"---\n \ntitle: Java源码分析(三)-HashSet\ndate: 2016-09-02 17:03:49\nsubtitle:   \"Keynote: JavaScript Modularization Journey\"\nheader-img: \"/img/home-bg-o.jpg\"\ntags:\n - HashSet\n - ArrayList\n\n---\n\n\n\n@(示例笔记本)[马克飞象|帮助|Markdown]\n\n**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：\n \n- **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；\n- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；\n- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。\n","slug":"Java源码分析-三-HashSet","published":1,"updated":"2016-09-09T06:02:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimm1000d07fy5uvew00v","content":"<p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>\n<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>\n<ul>\n<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>\n<li><strong>得心应手</strong> ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；</li>\n<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>\n</ul>\n","excerpt":"","more":"<p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>\n<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>\n<ul>\n<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>\n<li><strong>得心应手</strong> ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；</li>\n<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>\n</ul>\n"},{"title":"iOS（iOS7+）开发中的常用的Tips","date":"2015-09-01T14:55:25.000Z","_content":"\n##### 0.设置状态栏颜色反转\n\n```bash\n    [self.navigationBar setBarStyle:UIBarStyleBlack];\n```\n\n##### 1.将导航栏的背景设为透明（默认是半透明状态）\n\n```java\n  [self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault];\n```\n##### 2.xcode6配置pch文件\n\n   ![](/img/iOS/pch.png)\n","source":"_posts/iOS（iOS7-）开发中的常用的Tips.md","raw":"title: iOS（iOS7+）开发中的常用的Tips\ndate: 2015-09-01 22:55:25\ntags: iOS\n---\n\n##### 0.设置状态栏颜色反转\n\n```bash\n    [self.navigationBar setBarStyle:UIBarStyleBlack];\n```\n\n##### 1.将导航栏的背景设为透明（默认是半透明状态）\n\n```java\n  [self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault];\n```\n##### 2.xcode6配置pch文件\n\n   ![](/img/iOS/pch.png)\n","slug":"iOS（iOS7-）开发中的常用的Tips","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimm4000f07fy65s7lg0f","content":"<h5 id=\"0-设置状态栏颜色反转\"><a href=\"#0-设置状态栏颜色反转\" class=\"headerlink\" title=\"0.设置状态栏颜色反转\"></a>0.设置状态栏颜色反转</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.navigationBar <span class=\"built_in\">set</span>BarStyle:UIBarStyleBlack];</div></pre></td></tr></table></figure>\n<h5 id=\"1-将导航栏的背景设为透明（默认是半透明状态）\"><a href=\"#1-将导航栏的背景设为透明（默认是半透明状态）\" class=\"headerlink\" title=\"1.将导航栏的背景设为透明（默认是半透明状态）\"></a>1.将导航栏的背景设为透明（默认是半透明状态）</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault];</div></pre></td></tr></table></figure>\n<h5 id=\"2-xcode6配置pch文件\"><a href=\"#2-xcode6配置pch文件\" class=\"headerlink\" title=\"2.xcode6配置pch文件\"></a>2.xcode6配置pch文件</h5><p>   <img src=\"/img/iOS/pch.png\" alt=\"\"></p>\n","excerpt":"","more":"<h5 id=\"0-设置状态栏颜色反转\"><a href=\"#0-设置状态栏颜色反转\" class=\"headerlink\" title=\"0.设置状态栏颜色反转\"></a>0.设置状态栏颜色反转</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.navigationBar <span class=\"built_in\">set</span>BarStyle:UIBarStyleBlack];</div></pre></td></tr></table></figure>\n<h5 id=\"1-将导航栏的背景设为透明（默认是半透明状态）\"><a href=\"#1-将导航栏的背景设为透明（默认是半透明状态）\" class=\"headerlink\" title=\"1.将导航栏的背景设为透明（默认是半透明状态）\"></a>1.将导航栏的背景设为透明（默认是半透明状态）</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc]init] forBarMetrics:UIBarMetricsDefault];</div></pre></td></tr></table></figure>\n<h5 id=\"2-xcode6配置pch文件\"><a href=\"#2-xcode6配置pch文件\" class=\"headerlink\" title=\"2.xcode6配置pch文件\"></a>2.xcode6配置pch文件</h5><p>   <img src=\"/img/iOS/pch.png\" alt=\"\"></p>\n"},{"title":"iOS开发的代码结构","date":"2015-09-02T14:51:52.000Z","_content":"\n#### 0.iOS页面frame与数据\n\n  说到MVC，对于iOS开发者来说再熟悉不过了。MVC的程序开发模式，让开发变的更有条理，感谢那些为程序设计做出贡献的牛人\n\n  MVC在这里就不深入说了，我想说说别的，例如在开发中我们会发现，有的程序在没有网络的情况下是一片白色的页面什么都看不到（数据从网络获取），而有的程序则不同，虽然没有网络，但是会有页面的结构和占位图片等，\n\n  对于用户来说，肯定第二种的更友好一些。而这样的结构在开发时应该是让数据作为页面的一个属性，在数据属性值没有值时，构造页面，在这个属性有值的时候去重构界面，或者值改变的时候去重构界面，\n\n  说道这里我们会想到两个常用的方法\n\n``` bash\n  - (void)layoutSubviews\n```\n\n``` bash\n  - (void)setNeedsLayout\n```\n  我们来看看官方文档怎么解释这两个方法。\n\n  ![](/img/iOS/layoutSubviews.png)\n\n  红框里的话的意思是，“你不能直接调用这个方法。假如你想强制更新布局，需要调用setNeedLayout而不是去画页面更新，假如你想立即更新你的视图，可以调用layoutIfNeed\"\n\n  ![](/img/iOS/setlayout.png)\n\n#### 1.怎样创建一个数据与frame分离的view\n\n  好多同学在刚开始开发时，所有的代码都在viewDidLoad()方法中里，好些的将不同的view的初始化分成几个方法，不过仅仅这样还是远不够的，安装MVC的思想，我们可以分成controller，view，model但是view的创建往往会写的很混乱。\n\n  controller是管理一个页面的控制器，view就是这个控制器里所有被显示的东西。\n  例如我们创建一个view，假设这个view里只有一个简单的UIImageView,（数据多的话同理）我们需要从网络获取一个url而显示这张图片。如果网络没有数据我们也要现实这个imageView的结构，并且显示一个默认的图片。\n\n  1.创建一个名为TestView的view，然后创建一个UIImageView上需要显示图像的url\n\n  2.我们应该怎么创建Test，通常我们会重写他的init(或者initWithFrame:)方法\n","source":"_posts/iOS开发的代码结构.md","raw":"title: iOS开发的代码结构\ndate: 2015-09-02 22:51:52\ntags:\n---\n\n#### 0.iOS页面frame与数据\n\n  说到MVC，对于iOS开发者来说再熟悉不过了。MVC的程序开发模式，让开发变的更有条理，感谢那些为程序设计做出贡献的牛人\n\n  MVC在这里就不深入说了，我想说说别的，例如在开发中我们会发现，有的程序在没有网络的情况下是一片白色的页面什么都看不到（数据从网络获取），而有的程序则不同，虽然没有网络，但是会有页面的结构和占位图片等，\n\n  对于用户来说，肯定第二种的更友好一些。而这样的结构在开发时应该是让数据作为页面的一个属性，在数据属性值没有值时，构造页面，在这个属性有值的时候去重构界面，或者值改变的时候去重构界面，\n\n  说道这里我们会想到两个常用的方法\n\n``` bash\n  - (void)layoutSubviews\n```\n\n``` bash\n  - (void)setNeedsLayout\n```\n  我们来看看官方文档怎么解释这两个方法。\n\n  ![](/img/iOS/layoutSubviews.png)\n\n  红框里的话的意思是，“你不能直接调用这个方法。假如你想强制更新布局，需要调用setNeedLayout而不是去画页面更新，假如你想立即更新你的视图，可以调用layoutIfNeed\"\n\n  ![](/img/iOS/setlayout.png)\n\n#### 1.怎样创建一个数据与frame分离的view\n\n  好多同学在刚开始开发时，所有的代码都在viewDidLoad()方法中里，好些的将不同的view的初始化分成几个方法，不过仅仅这样还是远不够的，安装MVC的思想，我们可以分成controller，view，model但是view的创建往往会写的很混乱。\n\n  controller是管理一个页面的控制器，view就是这个控制器里所有被显示的东西。\n  例如我们创建一个view，假设这个view里只有一个简单的UIImageView,（数据多的话同理）我们需要从网络获取一个url而显示这张图片。如果网络没有数据我们也要现实这个imageView的结构，并且显示一个默认的图片。\n\n  1.创建一个名为TestView的view，然后创建一个UIImageView上需要显示图像的url\n\n  2.我们应该怎么创建Test，通常我们会重写他的init(或者initWithFrame:)方法\n","slug":"iOS开发的代码结构","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimm6000h07fyihzil5od","content":"<h4 id=\"0-iOS页面frame与数据\"><a href=\"#0-iOS页面frame与数据\" class=\"headerlink\" title=\"0.iOS页面frame与数据\"></a>0.iOS页面frame与数据</h4><p>  说到MVC，对于iOS开发者来说再熟悉不过了。MVC的程序开发模式，让开发变的更有条理，感谢那些为程序设计做出贡献的牛人</p>\n<p>  MVC在这里就不深入说了，我想说说别的，例如在开发中我们会发现，有的程序在没有网络的情况下是一片白色的页面什么都看不到（数据从网络获取），而有的程序则不同，虽然没有网络，但是会有页面的结构和占位图片等，</p>\n<p>  对于用户来说，肯定第二种的更友好一些。而这样的结构在开发时应该是让数据作为页面的一个属性，在数据属性值没有值时，构造页面，在这个属性有值的时候去重构界面，或者值改变的时候去重构界面，</p>\n<p>  说道这里我们会想到两个常用的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)layoutSubviews</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)<span class=\"built_in\">set</span>NeedsLayout</div></pre></td></tr></table></figure>\n<p>  我们来看看官方文档怎么解释这两个方法。</p>\n<p>  <img src=\"/img/iOS/layoutSubviews.png\" alt=\"\"></p>\n<p>  红框里的话的意思是，“你不能直接调用这个方法。假如你想强制更新布局，需要调用setNeedLayout而不是去画页面更新，假如你想立即更新你的视图，可以调用layoutIfNeed”</p>\n<p>  <img src=\"/img/iOS/setlayout.png\" alt=\"\"></p>\n<h4 id=\"1-怎样创建一个数据与frame分离的view\"><a href=\"#1-怎样创建一个数据与frame分离的view\" class=\"headerlink\" title=\"1.怎样创建一个数据与frame分离的view\"></a>1.怎样创建一个数据与frame分离的view</h4><p>  好多同学在刚开始开发时，所有的代码都在viewDidLoad()方法中里，好些的将不同的view的初始化分成几个方法，不过仅仅这样还是远不够的，安装MVC的思想，我们可以分成controller，view，model但是view的创建往往会写的很混乱。</p>\n<p>  controller是管理一个页面的控制器，view就是这个控制器里所有被显示的东西。<br>  例如我们创建一个view，假设这个view里只有一个简单的UIImageView,（数据多的话同理）我们需要从网络获取一个url而显示这张图片。如果网络没有数据我们也要现实这个imageView的结构，并且显示一个默认的图片。</p>\n<p>  1.创建一个名为TestView的view，然后创建一个UIImageView上需要显示图像的url</p>\n<p>  2.我们应该怎么创建Test，通常我们会重写他的init(或者initWithFrame:)方法</p>\n","excerpt":"","more":"<h4 id=\"0-iOS页面frame与数据\"><a href=\"#0-iOS页面frame与数据\" class=\"headerlink\" title=\"0.iOS页面frame与数据\"></a>0.iOS页面frame与数据</h4><p>  说到MVC，对于iOS开发者来说再熟悉不过了。MVC的程序开发模式，让开发变的更有条理，感谢那些为程序设计做出贡献的牛人</p>\n<p>  MVC在这里就不深入说了，我想说说别的，例如在开发中我们会发现，有的程序在没有网络的情况下是一片白色的页面什么都看不到（数据从网络获取），而有的程序则不同，虽然没有网络，但是会有页面的结构和占位图片等，</p>\n<p>  对于用户来说，肯定第二种的更友好一些。而这样的结构在开发时应该是让数据作为页面的一个属性，在数据属性值没有值时，构造页面，在这个属性有值的时候去重构界面，或者值改变的时候去重构界面，</p>\n<p>  说道这里我们会想到两个常用的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)layoutSubviews</div></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)<span class=\"built_in\">set</span>NeedsLayout</div></pre></td></tr></table></figure>\n<p>  我们来看看官方文档怎么解释这两个方法。</p>\n<p>  <img src=\"/img/iOS/layoutSubviews.png\" alt=\"\"></p>\n<p>  红框里的话的意思是，“你不能直接调用这个方法。假如你想强制更新布局，需要调用setNeedLayout而不是去画页面更新，假如你想立即更新你的视图，可以调用layoutIfNeed”</p>\n<p>  <img src=\"/img/iOS/setlayout.png\" alt=\"\"></p>\n<h4 id=\"1-怎样创建一个数据与frame分离的view\"><a href=\"#1-怎样创建一个数据与frame分离的view\" class=\"headerlink\" title=\"1.怎样创建一个数据与frame分离的view\"></a>1.怎样创建一个数据与frame分离的view</h4><p>  好多同学在刚开始开发时，所有的代码都在viewDidLoad()方法中里，好些的将不同的view的初始化分成几个方法，不过仅仅这样还是远不够的，安装MVC的思想，我们可以分成controller，view，model但是view的创建往往会写的很混乱。</p>\n<p>  controller是管理一个页面的控制器，view就是这个控制器里所有被显示的东西。<br>  例如我们创建一个view，假设这个view里只有一个简单的UIImageView,（数据多的话同理）我们需要从网络获取一个url而显示这张图片。如果网络没有数据我们也要现实这个imageView的结构，并且显示一个默认的图片。</p>\n<p>  1.创建一个名为TestView的view，然后创建一个UIImageView上需要显示图像的url</p>\n<p>  2.我们应该怎么创建Test，通常我们会重写他的init(或者initWithFrame:)方法</p>\n"},{"title":"Hello World","date":"2015-08-20T11:53:22.000Z","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-08-20 19:53:22\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-10-10T01:39:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimm9000k07fydsidem9r","content":"<p>Welcome to <a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"http://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"http://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"http://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"http://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"http://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"http://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"使用lombok简化Java代码","date":"2016-10-09T11:53:34.000Z","_content":"\n### 0. 简介：\n\tlombok是优化Java代码的一个小工具，特别是对Java Bean中的代码。\n\n#### [val](https://projectlombok.org/features/val.html) \n\t声明一个final的变量 可以做简单类型推导可参考 \n\n#### [@NonNull](https://projectlombok.org/features/NonNull.html) \n\t修饰属性时会生成一个包含对应参数的构造函数，修饰方法参数时会校验参数不能为空，为空时可抛出空指针异常\n\n使用lombok注解的代码\n\n```\npublic NonNullExample(@NonNull Person person) {\n     super(\"Hello\");\n     this.name = person.getName();\n}\n```\n\n实际生成的代码\n\n```\npublic NonNullExample(@NonNull Person person) {\n    super(\"Hello\");\n    if (person == null) {\n      throw new NullPointerException(\"person\");\n    }\n    this.name = person.getName();\n}\n```\n\n#### [@Cleanup](https://projectlombok.org/features/Cleanup.html) \n\t清理释放资源代码,会在使用资源的代码中自动添加释放资源的代码\n\n使用lombok注解的代码\n\n```\npublic class CleanupExample {\n   public static void main(String[] args) throws IOException {\n     @Cleanup InputStream in = new FileInputStream(args[0]);\n     @Cleanup OutputStream out = new FileOutputStream(args[1]);\n     byte[] b = new byte[10000];\n     while (true) {\n       int r = in.read(b);\n       if (r == -1) break;\n       out.write(b, 0, r);\n     }\n   }\n }\n```\n\n实际生成的代码\n\n```\n public static void main(String[] args) throws IOException {\n     InputStream in = new FileInputStream(args[0]);\n     try {\n       OutputStream out = new FileOutputStream(args[1]);\n       try {\n         byte[] b = new byte[10000];\n         while (true) {\n           int r = in.read(b);\n           if (r == -1) break;\n           out.write(b, 0, r);\n         }\n       } finally {\n         if (out != null) {\n           out.close();\n         }\n       }\n     } finally {\n       if (in != null) {\n         in.close();\n       }\n     }\n   }\n```\n\n\n#### [@Getter / @Setter](https://projectlombok.org/features/GetterSetter.html) \n\t生成getter/setter代码,会是JavaBean中的代码减少2/3\n\n如图所示，可以修饰属性，\n![](/img/lombok/lombok_01.png)\n\n也可以修饰类\n![](/img/lombok/lombok_02.png)\n\n#### [@ToString](https://projectlombok.org/features/ToString.html)\n\t 生成tostring代码 @ToString(xxx=xxx)可以加参数，具体参考官方文档\n\n#### [@EqualsAndHashCode](https://projectlombok.org/features/EqualsAndHashCode.html)\n\t 生成equals方法和hashCode方法\n\n#### [@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor](https://projectlombok.org/features/Constructor.html) \n\t生产构造函数的注解（无参数，必须的构造函数(可以自定义构造函数的名称),全部参数的构造函数）\n\n#### [@Data](https://projectlombok.org/features/Data.html) \n\t生成全部 ToString EqualsAndHashCode, Getter Setter 无参构造函数\n\n#### [@Value](https://projectlombok.org/features/Value.html)\n\t类似@Data 但是不用，详情见文档\n#### [@Builder](https://projectlombok.org/features/Builder.html)\n\t生成建造者模式\n#### [@SneakyThrows](https://projectlombok.org/features/SneakyThrows.html)\n\t生成抛出异常的代码\n#### [@Synchronized](https://projectlombok.org/features/Synchronized.html) \n\t同步代码块，锁为当前对象\n#### [@Getter(lazy=true)](https://projectlombok.org/features/GetterLazy.html)\n\t 第一次调用时生成一次，之后会被缓存起来，代码中已加锁。\n#### [@Log](https://projectlombok.org/features/Log.html)\n\t 生成日志代码。各种日志的配置\n\n### 1. [lombok官网](https://projectlombok.org/index.html)\n### 2. [lombok Github 地址](https://github.com/rzwitserloot/lombok)\n### 3. [maven gradle等依赖地址](https://projectlombok.org/mavenrepo/index.html)\n#### 3.1 maven\n\n```\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.projectlombok</groupId>\n\t\t<artifactId>lombok</artifactId>\n\t\t<version>1.16.10</version>\n\t\t<scope>provided</scope>\n\t</dependency>\n</dependencies>\n```\n#### 3.2 Gradle配置\n\nIf your gradle version is >= 2.12 you can use lombok by adding the following to your build.gradle in the dependencies block:\n\t\n```\ncompileOnly \"org.projectlombok:lombok:1.16.10\"\n```\nIf you use an older version you can still use the following:\n\n```\nprovided \"org.projectlombok:lombok:1.16.10\"\n```\n\t","source":"_posts/使用lombok简化Java代码.md","raw":"---\ntitle: 使用lombok简化Java代码\ndate: 2016-10-09 19:53:34\ntags:\n\t- java\n\t- lombok\n\t- 代码优化\n---\n\n### 0. 简介：\n\tlombok是优化Java代码的一个小工具，特别是对Java Bean中的代码。\n\n#### [val](https://projectlombok.org/features/val.html) \n\t声明一个final的变量 可以做简单类型推导可参考 \n\n#### [@NonNull](https://projectlombok.org/features/NonNull.html) \n\t修饰属性时会生成一个包含对应参数的构造函数，修饰方法参数时会校验参数不能为空，为空时可抛出空指针异常\n\n使用lombok注解的代码\n\n```\npublic NonNullExample(@NonNull Person person) {\n     super(\"Hello\");\n     this.name = person.getName();\n}\n```\n\n实际生成的代码\n\n```\npublic NonNullExample(@NonNull Person person) {\n    super(\"Hello\");\n    if (person == null) {\n      throw new NullPointerException(\"person\");\n    }\n    this.name = person.getName();\n}\n```\n\n#### [@Cleanup](https://projectlombok.org/features/Cleanup.html) \n\t清理释放资源代码,会在使用资源的代码中自动添加释放资源的代码\n\n使用lombok注解的代码\n\n```\npublic class CleanupExample {\n   public static void main(String[] args) throws IOException {\n     @Cleanup InputStream in = new FileInputStream(args[0]);\n     @Cleanup OutputStream out = new FileOutputStream(args[1]);\n     byte[] b = new byte[10000];\n     while (true) {\n       int r = in.read(b);\n       if (r == -1) break;\n       out.write(b, 0, r);\n     }\n   }\n }\n```\n\n实际生成的代码\n\n```\n public static void main(String[] args) throws IOException {\n     InputStream in = new FileInputStream(args[0]);\n     try {\n       OutputStream out = new FileOutputStream(args[1]);\n       try {\n         byte[] b = new byte[10000];\n         while (true) {\n           int r = in.read(b);\n           if (r == -1) break;\n           out.write(b, 0, r);\n         }\n       } finally {\n         if (out != null) {\n           out.close();\n         }\n       }\n     } finally {\n       if (in != null) {\n         in.close();\n       }\n     }\n   }\n```\n\n\n#### [@Getter / @Setter](https://projectlombok.org/features/GetterSetter.html) \n\t生成getter/setter代码,会是JavaBean中的代码减少2/3\n\n如图所示，可以修饰属性，\n![](/img/lombok/lombok_01.png)\n\n也可以修饰类\n![](/img/lombok/lombok_02.png)\n\n#### [@ToString](https://projectlombok.org/features/ToString.html)\n\t 生成tostring代码 @ToString(xxx=xxx)可以加参数，具体参考官方文档\n\n#### [@EqualsAndHashCode](https://projectlombok.org/features/EqualsAndHashCode.html)\n\t 生成equals方法和hashCode方法\n\n#### [@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor](https://projectlombok.org/features/Constructor.html) \n\t生产构造函数的注解（无参数，必须的构造函数(可以自定义构造函数的名称),全部参数的构造函数）\n\n#### [@Data](https://projectlombok.org/features/Data.html) \n\t生成全部 ToString EqualsAndHashCode, Getter Setter 无参构造函数\n\n#### [@Value](https://projectlombok.org/features/Value.html)\n\t类似@Data 但是不用，详情见文档\n#### [@Builder](https://projectlombok.org/features/Builder.html)\n\t生成建造者模式\n#### [@SneakyThrows](https://projectlombok.org/features/SneakyThrows.html)\n\t生成抛出异常的代码\n#### [@Synchronized](https://projectlombok.org/features/Synchronized.html) \n\t同步代码块，锁为当前对象\n#### [@Getter(lazy=true)](https://projectlombok.org/features/GetterLazy.html)\n\t 第一次调用时生成一次，之后会被缓存起来，代码中已加锁。\n#### [@Log](https://projectlombok.org/features/Log.html)\n\t 生成日志代码。各种日志的配置\n\n### 1. [lombok官网](https://projectlombok.org/index.html)\n### 2. [lombok Github 地址](https://github.com/rzwitserloot/lombok)\n### 3. [maven gradle等依赖地址](https://projectlombok.org/mavenrepo/index.html)\n#### 3.1 maven\n\n```\n<dependencies>\n\t<dependency>\n\t\t<groupId>org.projectlombok</groupId>\n\t\t<artifactId>lombok</artifactId>\n\t\t<version>1.16.10</version>\n\t\t<scope>provided</scope>\n\t</dependency>\n</dependencies>\n```\n#### 3.2 Gradle配置\n\nIf your gradle version is >= 2.12 you can use lombok by adding the following to your build.gradle in the dependencies block:\n\t\n```\ncompileOnly \"org.projectlombok:lombok:1.16.10\"\n```\nIf you use an older version you can still use the following:\n\n```\nprovided \"org.projectlombok:lombok:1.16.10\"\n```\n\t","slug":"使用lombok简化Java代码","published":1,"updated":"2016-10-11T03:46:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimma000l07fyad7chv1r","content":"<h3 id=\"0-简介：\"><a href=\"#0-简介：\" class=\"headerlink\" title=\"0. 简介：\"></a>0. 简介：</h3><pre><code>lombok是优化Java代码的一个小工具，特别是对Java Bean中的代码。\n</code></pre><h4 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val\"></a><a href=\"https://projectlombok.org/features/val.html\" target=\"_blank\" rel=\"external\">val</a></h4><pre><code>声明一个final的变量 可以做简单类型推导可参考 \n</code></pre><h4 id=\"NonNull\"><a href=\"#NonNull\" class=\"headerlink\" title=\"@NonNull\"></a><a href=\"https://projectlombok.org/features/NonNull.html\" target=\"_blank\" rel=\"external\">@NonNull</a></h4><pre><code>修饰属性时会生成一个包含对应参数的构造函数，修饰方法参数时会校验参数不能为空，为空时可抛出空指针异常\n</code></pre><p>使用lombok注解的代码</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> NonNullExample(<span class=\"meta\">@NonNull</span> Person person) &#123;</div><div class=\"line\">     <span class=\"keyword\">super</span>(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">     <span class=\"keyword\">this</span>.name = person.getName();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际生成的代码</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NonNullExample</span><span class=\"params\">(@NonNull Person person)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (person == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"person\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = person.getName();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Cleanup\"><a href=\"#Cleanup\" class=\"headerlink\" title=\"@Cleanup\"></a><a href=\"https://projectlombok.org/features/Cleanup.html\" target=\"_blank\" rel=\"external\">@Cleanup</a></h4><pre><code>清理释放资源代码,会在使用资源的代码中自动添加释放资源的代码\n</code></pre><p>使用lombok注解的代码</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CleanupExample</span> &#123;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws IOException </span>&#123;</div><div class=\"line\">     @Cleanup InputStream <span class=\"keyword\">in</span> = <span class=\"keyword\">new</span> FileInputStream(args[<span class=\"number\">0</span>]);</div><div class=\"line\">     @Cleanup OutputStream <span class=\"keyword\">out</span> = <span class=\"keyword\">new</span> FileOutputStream(args[<span class=\"number\">1</span>]);</div><div class=\"line\">     <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>];</div><div class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> r = <span class=\"keyword\">in</span>.read(b);</div><div class=\"line\">       <span class=\"keyword\">if</span> (r == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">       <span class=\"keyword\">out</span>.write(b, <span class=\"number\">0</span>, r);</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>实际生成的代码</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws IOException </span>&#123;</div><div class=\"line\">    InputStream <span class=\"keyword\">in</span> = <span class=\"keyword\">new</span> FileInputStream(args[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      OutputStream <span class=\"keyword\">out</span> = <span class=\"keyword\">new</span> FileOutputStream(args[<span class=\"number\">1</span>]);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>];</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">int</span> r = <span class=\"keyword\">in</span>.read(b);</div><div class=\"line\">          <span class=\"keyword\">if</span> (r == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">out</span>.write(b, <span class=\"number\">0</span>, r);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">out</span> != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">out</span>.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">in</span> != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">in</span>.close();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Getter-Setter\"><a href=\"#Getter-Setter\" class=\"headerlink\" title=\"@Getter / @Setter\"></a><a href=\"https://projectlombok.org/features/GetterSetter.html\" target=\"_blank\" rel=\"external\">@Getter / @Setter</a></h4><pre><code>生成getter/setter代码,会是JavaBean中的代码减少2/3\n</code></pre><p>如图所示，可以修饰属性，<br><img src=\"/img/lombok/lombok_01.png\" alt=\"\"></p>\n<p>也可以修饰类<br><img src=\"/img/lombok/lombok_02.png\" alt=\"\"></p>\n<h4 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"@ToString\"></a><a href=\"https://projectlombok.org/features/ToString.html\" target=\"_blank\" rel=\"external\">@ToString</a></h4><pre><code>生成tostring代码 @ToString(xxx=xxx)可以加参数，具体参考官方文档\n</code></pre><h4 id=\"EqualsAndHashCode\"><a href=\"#EqualsAndHashCode\" class=\"headerlink\" title=\"@EqualsAndHashCode\"></a><a href=\"https://projectlombok.org/features/EqualsAndHashCode.html\" target=\"_blank\" rel=\"external\">@EqualsAndHashCode</a></h4><pre><code>生成equals方法和hashCode方法\n</code></pre><h4 id=\"NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor\"><a href=\"#NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor\"></a><a href=\"https://projectlombok.org/features/Constructor.html\" target=\"_blank\" rel=\"external\">@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</a></h4><pre><code>生产构造函数的注解（无参数，必须的构造函数(可以自定义构造函数的名称),全部参数的构造函数）\n</code></pre><h4 id=\"Data\"><a href=\"#Data\" class=\"headerlink\" title=\"@Data\"></a><a href=\"https://projectlombok.org/features/Data.html\" target=\"_blank\" rel=\"external\">@Data</a></h4><pre><code>生成全部 ToString EqualsAndHashCode, Getter Setter 无参构造函数\n</code></pre><h4 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a><a href=\"https://projectlombok.org/features/Value.html\" target=\"_blank\" rel=\"external\">@Value</a></h4><pre><code>类似@Data 但是不用，详情见文档\n</code></pre><h4 id=\"Builder\"><a href=\"#Builder\" class=\"headerlink\" title=\"@Builder\"></a><a href=\"https://projectlombok.org/features/Builder.html\" target=\"_blank\" rel=\"external\">@Builder</a></h4><pre><code>生成建造者模式\n</code></pre><h4 id=\"SneakyThrows\"><a href=\"#SneakyThrows\" class=\"headerlink\" title=\"@SneakyThrows\"></a><a href=\"https://projectlombok.org/features/SneakyThrows.html\" target=\"_blank\" rel=\"external\">@SneakyThrows</a></h4><pre><code>生成抛出异常的代码\n</code></pre><h4 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"@Synchronized\"></a><a href=\"https://projectlombok.org/features/Synchronized.html\" target=\"_blank\" rel=\"external\">@Synchronized</a></h4><pre><code>同步代码块，锁为当前对象\n</code></pre><h4 id=\"Getter-lazy-true\"><a href=\"#Getter-lazy-true\" class=\"headerlink\" title=\"@Getter(lazy=true)\"></a><a href=\"https://projectlombok.org/features/GetterLazy.html\" target=\"_blank\" rel=\"external\">@Getter(lazy=true)</a></h4><pre><code>第一次调用时生成一次，之后会被缓存起来，代码中已加锁。\n</code></pre><h4 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"@Log\"></a><a href=\"https://projectlombok.org/features/Log.html\" target=\"_blank\" rel=\"external\">@Log</a></h4><pre><code>生成日志代码。各种日志的配置\n</code></pre><h3 id=\"1-lombok官网\"><a href=\"#1-lombok官网\" class=\"headerlink\" title=\"1. lombok官网\"></a>1. <a href=\"https://projectlombok.org/index.html\" target=\"_blank\" rel=\"external\">lombok官网</a></h3><h3 id=\"2-lombok-Github-地址\"><a href=\"#2-lombok-Github-地址\" class=\"headerlink\" title=\"2. lombok Github 地址\"></a>2. <a href=\"https://github.com/rzwitserloot/lombok\" target=\"_blank\" rel=\"external\">lombok Github 地址</a></h3><h3 id=\"3-maven-gradle等依赖地址\"><a href=\"#3-maven-gradle等依赖地址\" class=\"headerlink\" title=\"3. maven gradle等依赖地址\"></a>3. <a href=\"https://projectlombok.org/mavenrepo/index.html\" target=\"_blank\" rel=\"external\">maven gradle等依赖地址</a></h3><h4 id=\"3-1-maven\"><a href=\"#3-1-maven\" class=\"headerlink\" title=\"3.1 maven\"></a>3.1 maven</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.16.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"3-2-Gradle配置\"><a href=\"#3-2-Gradle配置\" class=\"headerlink\" title=\"3.2 Gradle配置\"></a>3.2 Gradle配置</h4><p>If your gradle version is &gt;= 2.12 you can use lombok by adding the following to your build.gradle in the dependencies block:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">compileOnly</span> \"<span class=\"selector-tag\">org</span><span class=\"selector-class\">.projectlombok</span><span class=\"selector-pseudo\">:lombok</span><span class=\"selector-pseudo\">:1.16.10\"</span></div></pre></td></tr></table></figure>\n<p>If you use an older version you can still use the following:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">provided</span> \"<span class=\"selector-tag\">org</span><span class=\"selector-class\">.projectlombok</span><span class=\"selector-pseudo\">:lombok</span><span class=\"selector-pseudo\">:1.16.10\"</span></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"0-简介：\"><a href=\"#0-简介：\" class=\"headerlink\" title=\"0. 简介：\"></a>0. 简介：</h3><pre><code>lombok是优化Java代码的一个小工具，特别是对Java Bean中的代码。\n</code></pre><h4 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val\"></a><a href=\"https://projectlombok.org/features/val.html\">val</a></h4><pre><code>声明一个final的变量 可以做简单类型推导可参考 \n</code></pre><h4 id=\"NonNull\"><a href=\"#NonNull\" class=\"headerlink\" title=\"@NonNull\"></a><a href=\"https://projectlombok.org/features/NonNull.html\">@NonNull</a></h4><pre><code>修饰属性时会生成一个包含对应参数的构造函数，修饰方法参数时会校验参数不能为空，为空时可抛出空指针异常\n</code></pre><p>使用lombok注解的代码</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> NonNullExample(<span class=\"meta\">@NonNull</span> Person person) &#123;</div><div class=\"line\">     <span class=\"keyword\">super</span>(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">     <span class=\"keyword\">this</span>.name = person.getName();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际生成的代码</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NonNullExample</span><span class=\"params\">(@NonNull Person person)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (person == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"person\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = person.getName();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Cleanup\"><a href=\"#Cleanup\" class=\"headerlink\" title=\"@Cleanup\"></a><a href=\"https://projectlombok.org/features/Cleanup.html\">@Cleanup</a></h4><pre><code>清理释放资源代码,会在使用资源的代码中自动添加释放资源的代码\n</code></pre><p>使用lombok注解的代码</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CleanupExample</span> &#123;</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws IOException </span>&#123;</div><div class=\"line\">     @Cleanup InputStream <span class=\"keyword\">in</span> = <span class=\"keyword\">new</span> FileInputStream(args[<span class=\"number\">0</span>]);</div><div class=\"line\">     @Cleanup OutputStream <span class=\"keyword\">out</span> = <span class=\"keyword\">new</span> FileOutputStream(args[<span class=\"number\">1</span>]);</div><div class=\"line\">     <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>];</div><div class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">int</span> r = <span class=\"keyword\">in</span>.read(b);</div><div class=\"line\">       <span class=\"keyword\">if</span> (r == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">       <span class=\"keyword\">out</span>.write(b, <span class=\"number\">0</span>, r);</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>实际生成的代码</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>) throws IOException </span>&#123;</div><div class=\"line\">    InputStream <span class=\"keyword\">in</span> = <span class=\"keyword\">new</span> FileInputStream(args[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      OutputStream <span class=\"keyword\">out</span> = <span class=\"keyword\">new</span> FileOutputStream(args[<span class=\"number\">1</span>]);</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10000</span>];</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">int</span> r = <span class=\"keyword\">in</span>.read(b);</div><div class=\"line\">          <span class=\"keyword\">if</span> (r == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">          <span class=\"keyword\">out</span>.write(b, <span class=\"number\">0</span>, r);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">out</span> != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">out</span>.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">in</span> != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">in</span>.close();</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Getter-Setter\"><a href=\"#Getter-Setter\" class=\"headerlink\" title=\"@Getter / @Setter\"></a><a href=\"https://projectlombok.org/features/GetterSetter.html\">@Getter / @Setter</a></h4><pre><code>生成getter/setter代码,会是JavaBean中的代码减少2/3\n</code></pre><p>如图所示，可以修饰属性，<br><img src=\"/img/lombok/lombok_01.png\" alt=\"\"></p>\n<p>也可以修饰类<br><img src=\"/img/lombok/lombok_02.png\" alt=\"\"></p>\n<h4 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"@ToString\"></a><a href=\"https://projectlombok.org/features/ToString.html\">@ToString</a></h4><pre><code>生成tostring代码 @ToString(xxx=xxx)可以加参数，具体参考官方文档\n</code></pre><h4 id=\"EqualsAndHashCode\"><a href=\"#EqualsAndHashCode\" class=\"headerlink\" title=\"@EqualsAndHashCode\"></a><a href=\"https://projectlombok.org/features/EqualsAndHashCode.html\">@EqualsAndHashCode</a></h4><pre><code>生成equals方法和hashCode方法\n</code></pre><h4 id=\"NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor\"><a href=\"#NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor\" class=\"headerlink\" title=\"@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor\"></a><a href=\"https://projectlombok.org/features/Constructor.html\">@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</a></h4><pre><code>生产构造函数的注解（无参数，必须的构造函数(可以自定义构造函数的名称),全部参数的构造函数）\n</code></pre><h4 id=\"Data\"><a href=\"#Data\" class=\"headerlink\" title=\"@Data\"></a><a href=\"https://projectlombok.org/features/Data.html\">@Data</a></h4><pre><code>生成全部 ToString EqualsAndHashCode, Getter Setter 无参构造函数\n</code></pre><h4 id=\"Value\"><a href=\"#Value\" class=\"headerlink\" title=\"@Value\"></a><a href=\"https://projectlombok.org/features/Value.html\">@Value</a></h4><pre><code>类似@Data 但是不用，详情见文档\n</code></pre><h4 id=\"Builder\"><a href=\"#Builder\" class=\"headerlink\" title=\"@Builder\"></a><a href=\"https://projectlombok.org/features/Builder.html\">@Builder</a></h4><pre><code>生成建造者模式\n</code></pre><h4 id=\"SneakyThrows\"><a href=\"#SneakyThrows\" class=\"headerlink\" title=\"@SneakyThrows\"></a><a href=\"https://projectlombok.org/features/SneakyThrows.html\">@SneakyThrows</a></h4><pre><code>生成抛出异常的代码\n</code></pre><h4 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"@Synchronized\"></a><a href=\"https://projectlombok.org/features/Synchronized.html\">@Synchronized</a></h4><pre><code>同步代码块，锁为当前对象\n</code></pre><h4 id=\"Getter-lazy-true\"><a href=\"#Getter-lazy-true\" class=\"headerlink\" title=\"@Getter(lazy=true)\"></a><a href=\"https://projectlombok.org/features/GetterLazy.html\">@Getter(lazy=true)</a></h4><pre><code>第一次调用时生成一次，之后会被缓存起来，代码中已加锁。\n</code></pre><h4 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"@Log\"></a><a href=\"https://projectlombok.org/features/Log.html\">@Log</a></h4><pre><code>生成日志代码。各种日志的配置\n</code></pre><h3 id=\"1-lombok官网\"><a href=\"#1-lombok官网\" class=\"headerlink\" title=\"1. lombok官网\"></a>1. <a href=\"https://projectlombok.org/index.html\">lombok官网</a></h3><h3 id=\"2-lombok-Github-地址\"><a href=\"#2-lombok-Github-地址\" class=\"headerlink\" title=\"2. lombok Github 地址\"></a>2. <a href=\"https://github.com/rzwitserloot/lombok\">lombok Github 地址</a></h3><h3 id=\"3-maven-gradle等依赖地址\"><a href=\"#3-maven-gradle等依赖地址\" class=\"headerlink\" title=\"3. maven gradle等依赖地址\"></a>3. <a href=\"https://projectlombok.org/mavenrepo/index.html\">maven gradle等依赖地址</a></h3><h4 id=\"3-1-maven\"><a href=\"#3-1-maven\" class=\"headerlink\" title=\"3.1 maven\"></a>3.1 maven</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.projectlombok<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>lombok<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.16.10<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"3-2-Gradle配置\"><a href=\"#3-2-Gradle配置\" class=\"headerlink\" title=\"3.2 Gradle配置\"></a>3.2 Gradle配置</h4><p>If your gradle version is &gt;= 2.12 you can use lombok by adding the following to your build.gradle in the dependencies block:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">compileOnly</span> \"<span class=\"selector-tag\">org</span><span class=\"selector-class\">.projectlombok</span><span class=\"selector-pseudo\">:lombok</span><span class=\"selector-pseudo\">:1.16.10\"</span></div></pre></td></tr></table></figure>\n<p>If you use an older version you can still use the following:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">provided</span> \"<span class=\"selector-tag\">org</span><span class=\"selector-class\">.projectlombok</span><span class=\"selector-pseudo\">:lombok</span><span class=\"selector-pseudo\">:1.16.10\"</span></div></pre></td></tr></table></figure>\n"},{"title":"《深入理解Java虚拟机》读书笔记-(一)","date":"2016-09-25T10:53:22.000Z","_content":"\n### 0.Java内存区域\n#### 一、运行时数据区域\n\nJava虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区\n\n##### 1.1 程序计数器\n\n程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域\n\n##### 1.2 Java虚拟机栈\n\n虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分\n\n局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）\n\n其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。\n\nJava虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常\n\n##### 1.3 本地方法栈\n\n本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务\n\n本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常\n\n##### 1.4 Java堆\n\n堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配\n\nJava堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代\n\n不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存\n\nJava堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常\n\n##### 1.5 方法区\n\n方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n\n除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载\n\n当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常\n\n##### 1.6 运行时常量池\n\n它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放\n\nJava语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法\n\n当常量池无法再申请到内存时会抛出OutOfMemoryError异常","source":"_posts/《深入理解Java虚拟机》读书笔记-一.md","raw":"---\ntitle: 《深入理解Java虚拟机》读书笔记-(一)\ndate: 2016-09-25 18:53:22\ntags:\n\t- Java\n\t- 深入理解Java虚拟机\n---\n\n### 0.Java内存区域\n#### 一、运行时数据区域\n\nJava虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区\n\n##### 1.1 程序计数器\n\n程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域\n\n##### 1.2 Java虚拟机栈\n\n虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分\n\n局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）\n\n其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。\n\nJava虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常\n\n##### 1.3 本地方法栈\n\n本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务\n\n本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常\n\n##### 1.4 Java堆\n\n堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配\n\nJava堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代\n\n不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存\n\nJava堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常\n\n##### 1.5 方法区\n\n方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据\n\n除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载\n\n当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常\n\n##### 1.6 运行时常量池\n\n它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放\n\nJava语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法\n\n当常量池无法再申请到内存时会抛出OutOfMemoryError异常","slug":"《深入理解Java虚拟机》读书笔记-一","published":1,"updated":"2016-11-16T08:04:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmb000n07fy3idpicos","content":"<h3 id=\"0-Java内存区域\"><a href=\"#0-Java内存区域\" class=\"headerlink\" title=\"0.Java内存区域\"></a>0.Java内存区域</h3><h4 id=\"一、运行时数据区域\"><a href=\"#一、运行时数据区域\" class=\"headerlink\" title=\"一、运行时数据区域\"></a>一、运行时数据区域</h4><p>Java虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区</p>\n<h5 id=\"1-1-程序计数器\"><a href=\"#1-1-程序计数器\" class=\"headerlink\" title=\"1.1 程序计数器\"></a>1.1 程序计数器</h5><p>程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域</p>\n<h5 id=\"1-2-Java虚拟机栈\"><a href=\"#1-2-Java虚拟机栈\" class=\"headerlink\" title=\"1.2 Java虚拟机栈\"></a>1.2 Java虚拟机栈</h5><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p>栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分</p>\n<p>局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）</p>\n<p>其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。</p>\n<p>Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常</p>\n<h5 id=\"1-3-本地方法栈\"><a href=\"#1-3-本地方法栈\" class=\"headerlink\" title=\"1.3 本地方法栈\"></a>1.3 本地方法栈</h5><p>本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</p>\n<p>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常</p>\n<h5 id=\"1-4-Java堆\"><a href=\"#1-4-Java堆\" class=\"headerlink\" title=\"1.4 Java堆\"></a>1.4 Java堆</h5><p>堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配</p>\n<p>Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代</p>\n<p>不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存</p>\n<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常</p>\n<h5 id=\"1-5-方法区\"><a href=\"#1-5-方法区\" class=\"headerlink\" title=\"1.5 方法区\"></a>1.5 方法区</h5><p>方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>\n<p>除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载</p>\n<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常</p>\n<h5 id=\"1-6-运行时常量池\"><a href=\"#1-6-运行时常量池\" class=\"headerlink\" title=\"1.6 运行时常量池\"></a>1.6 运行时常量池</h5><p>它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p>\n<p>Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法</p>\n<p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常</p>\n","excerpt":"","more":"<h3 id=\"0-Java内存区域\"><a href=\"#0-Java内存区域\" class=\"headerlink\" title=\"0.Java内存区域\"></a>0.Java内存区域</h3><h4 id=\"一、运行时数据区域\"><a href=\"#一、运行时数据区域\" class=\"headerlink\" title=\"一、运行时数据区域\"></a>一、运行时数据区域</h4><p>Java虚拟机管理的内存包括几个运行时数据内存：方法区、虚拟机栈、本地方法栈、堆、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区</p>\n<h5 id=\"1-1-程序计数器\"><a href=\"#1-1-程序计数器\" class=\"headerlink\" title=\"1.1 程序计数器\"></a>1.1 程序计数器</h5><p>程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域</p>\n<h5 id=\"1-2-Java虚拟机栈\"><a href=\"#1-2-Java虚拟机栈\" class=\"headerlink\" title=\"1.2 Java虚拟机栈\"></a>1.2 Java虚拟机栈</h5><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p>栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分</p>\n<p>局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）</p>\n<p>其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。</p>\n<p>Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常</p>\n<h5 id=\"1-3-本地方法栈\"><a href=\"#1-3-本地方法栈\" class=\"headerlink\" title=\"1.3 本地方法栈\"></a>1.3 本地方法栈</h5><p>本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务</p>\n<p>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常</p>\n<h5 id=\"1-4-Java堆\"><a href=\"#1-4-Java堆\" class=\"headerlink\" title=\"1.4 Java堆\"></a>1.4 Java堆</h5><p>堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都在堆上分配</p>\n<p>Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代</p>\n<p>不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存</p>\n<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常</p>\n<h5 id=\"1-5-方法区\"><a href=\"#1-5-方法区\" class=\"headerlink\" title=\"1.5 方法区\"></a>1.5 方法区</h5><p>方法区它用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>\n<p>除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载</p>\n<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常</p>\n<h5 id=\"1-6-运行时常量池\"><a href=\"#1-6-运行时常量池\" class=\"headerlink\" title=\"1.6 运行时常量池\"></a>1.6 运行时常量池</h5><p>它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编辑期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p>\n<p>Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法</p>\n<p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常</p>\n"},{"title":"使用一台Nginx对多台Tomcat实现负载均衡","date":"2016-10-28T06:00:38.000Z","_content":"\n### 0. 简介\n\n使用一台Nginx服务器通过配置多台tomcat实现访问负载均衡。其实网上有很多例子。之前也配置过。不过为了加强记忆。写篇文章记录要点。(实现环境为mac pro)\n\n### 1.安装tomcat(本例安装2台)\n直接去[Apache tomcat](http://tomcat.apache.org/download-70.cgi)下载zip包，![](/img/nginx/nginx_01.png)\n找个文件夹解压并且复制一份（可复制多个）如图\n![](/img/nginx/nginx_02.png)\n### 2.修改tomcat的端口号\n对于搞Java web的小伙伴这就不详细说了。\n如图所示修改server.xml文件\n![](/img/nginx/nginx_03.png)\n端口号可随意修改（建议改的大一点）。只要不冲突就OK\n看过server.xml文件的小伙伴都知道里面有三个端口号:\n\t\n\t8005，8080，8009\n\n这三个端口号分别代表什么意思暂且不说。\n第一台tomcat不做修改。第二台改成如图所示。当然可以改成你想要的端口号\n\n![](/img/nginx/nginx_04.png)\n\n![](/img/nginx/nginx_05.png)\n\n![](/img/nginx/nginx_06.png)\n\n### 3.启动tomcat\nmac中zip包解压后默认bin中的命令是不可以执行的。如图\n![](/img/nginx/nginx_07.png)\n修改bin中的命令的执行权限然后启动tomcat\n（使用该命令必须在当前tomcat的bin目录下）\n```\n\tchmod 777 *.sh\n```\n![](/img/nginx/nginx_08.png)\n\n分别在tomcat的bin目录下执行\n\n```\n\tsh startup.sh\n\t//sh shutdown.sh --停止tomcat\n```\n\n在两个tomcat的webapps目录下新建一个文件夹名为test.在test中新建文件test.html\n作为测试tomcat启动后的测试页面。\n\n![](/img/nginx/nginx_12.png)\n\n\t分别在body中输入<h2>this is tomcat 1</h2> 和 <h2>this is tomcat 2</h2>\n\n如图所示\n![](/img/nginx/nginx_13.png)\n\n在浏览器中分别输入 ：\nhttp://localhost:8080/test/test.html\nhttp://localhost:8081/test/test.html\n\n出现如下图时。tomcat安装成功。\n\n![](/img/nginx/nginx_09.png)\n![](/img/nginx/nginx_10.png)\n\n\n### 4.安装nginx\n\n在mac上安装nginx非常简单 使用brew安装即可\n\n```\nbrew install nginx\n```\nOK nginx 安装成功\n### 5.启动nginx\n启动命令：\n\n```\n\tnginx\n```\n停止命名：\n\n```\n nginx -s stop\n```\n默认nginx监听80端口。\n启动后在浏览器输入：http://localhost\n出现如图择nginx 启动成功\n![](/img/nginx/nginx_11.png)\n\n### 6.配置负载（也是本blog最重要的点）\n\n找到nginx的配置文件:nginx.conf\nbrew安装后默认的配置文件路径为：/usr/local/etc/nginx\n修改nginx.conf文件如图所示\n\n![](/img/nginx/nginx_14.png)\n\n```\n\t upstream myTomcat {\n   \t \tserver 127.0.0.1:8080 weight=5;\n   \t \tserver 127.0.0.1:8081 weight=5;\n    }\n    server {\n        listen       8888;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            #root   html;\n            #index  index.html index.htm;\n       \tproxy_pass http://myTomcat;\n\n        }\n        ...其余代码省略\n```\n\n### 7.验证负载\n\n在浏览器中输入 [http://localhost:8888/test/test.html](http://localhost:8888/test/test.html)\n可打开多个tab也测试。会发现tomcat1 和tomcat2在切换。\n\n![](/img/nginx/nginx_15.png)\n\nOK。这样就实现了简单的负载均衡。\n\nPS: nginx的配置需继续研究。\n\n\n\n\n\n\n","source":"_posts/使用一台Nginx对多台Tomcat实现负载均衡.md","raw":"---\ntitle: 使用一台Nginx对多台Tomcat实现负载均衡\ndate: 2016-10-28 14:00:38\ntags:\n\t- Nginx\n\t- 负载均衡\n\t- Tomcat\n---\n\n### 0. 简介\n\n使用一台Nginx服务器通过配置多台tomcat实现访问负载均衡。其实网上有很多例子。之前也配置过。不过为了加强记忆。写篇文章记录要点。(实现环境为mac pro)\n\n### 1.安装tomcat(本例安装2台)\n直接去[Apache tomcat](http://tomcat.apache.org/download-70.cgi)下载zip包，![](/img/nginx/nginx_01.png)\n找个文件夹解压并且复制一份（可复制多个）如图\n![](/img/nginx/nginx_02.png)\n### 2.修改tomcat的端口号\n对于搞Java web的小伙伴这就不详细说了。\n如图所示修改server.xml文件\n![](/img/nginx/nginx_03.png)\n端口号可随意修改（建议改的大一点）。只要不冲突就OK\n看过server.xml文件的小伙伴都知道里面有三个端口号:\n\t\n\t8005，8080，8009\n\n这三个端口号分别代表什么意思暂且不说。\n第一台tomcat不做修改。第二台改成如图所示。当然可以改成你想要的端口号\n\n![](/img/nginx/nginx_04.png)\n\n![](/img/nginx/nginx_05.png)\n\n![](/img/nginx/nginx_06.png)\n\n### 3.启动tomcat\nmac中zip包解压后默认bin中的命令是不可以执行的。如图\n![](/img/nginx/nginx_07.png)\n修改bin中的命令的执行权限然后启动tomcat\n（使用该命令必须在当前tomcat的bin目录下）\n```\n\tchmod 777 *.sh\n```\n![](/img/nginx/nginx_08.png)\n\n分别在tomcat的bin目录下执行\n\n```\n\tsh startup.sh\n\t//sh shutdown.sh --停止tomcat\n```\n\n在两个tomcat的webapps目录下新建一个文件夹名为test.在test中新建文件test.html\n作为测试tomcat启动后的测试页面。\n\n![](/img/nginx/nginx_12.png)\n\n\t分别在body中输入<h2>this is tomcat 1</h2> 和 <h2>this is tomcat 2</h2>\n\n如图所示\n![](/img/nginx/nginx_13.png)\n\n在浏览器中分别输入 ：\nhttp://localhost:8080/test/test.html\nhttp://localhost:8081/test/test.html\n\n出现如下图时。tomcat安装成功。\n\n![](/img/nginx/nginx_09.png)\n![](/img/nginx/nginx_10.png)\n\n\n### 4.安装nginx\n\n在mac上安装nginx非常简单 使用brew安装即可\n\n```\nbrew install nginx\n```\nOK nginx 安装成功\n### 5.启动nginx\n启动命令：\n\n```\n\tnginx\n```\n停止命名：\n\n```\n nginx -s stop\n```\n默认nginx监听80端口。\n启动后在浏览器输入：http://localhost\n出现如图择nginx 启动成功\n![](/img/nginx/nginx_11.png)\n\n### 6.配置负载（也是本blog最重要的点）\n\n找到nginx的配置文件:nginx.conf\nbrew安装后默认的配置文件路径为：/usr/local/etc/nginx\n修改nginx.conf文件如图所示\n\n![](/img/nginx/nginx_14.png)\n\n```\n\t upstream myTomcat {\n   \t \tserver 127.0.0.1:8080 weight=5;\n   \t \tserver 127.0.0.1:8081 weight=5;\n    }\n    server {\n        listen       8888;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            #root   html;\n            #index  index.html index.htm;\n       \tproxy_pass http://myTomcat;\n\n        }\n        ...其余代码省略\n```\n\n### 7.验证负载\n\n在浏览器中输入 [http://localhost:8888/test/test.html](http://localhost:8888/test/test.html)\n可打开多个tab也测试。会发现tomcat1 和tomcat2在切换。\n\n![](/img/nginx/nginx_15.png)\n\nOK。这样就实现了简单的负载均衡。\n\nPS: nginx的配置需继续研究。\n\n\n\n\n\n\n","slug":"使用一台Nginx对多台Tomcat实现负载均衡","published":1,"updated":"2016-10-28T08:19:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmd000o07fyed9mvj2u","content":"<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>使用一台Nginx服务器通过配置多台tomcat实现访问负载均衡。其实网上有很多例子。之前也配置过。不过为了加强记忆。写篇文章记录要点。(实现环境为mac pro)</p>\n<h3 id=\"1-安装tomcat-本例安装2台\"><a href=\"#1-安装tomcat-本例安装2台\" class=\"headerlink\" title=\"1.安装tomcat(本例安装2台)\"></a>1.安装tomcat(本例安装2台)</h3><p>直接去<a href=\"http://tomcat.apache.org/download-70.cgi\" target=\"_blank\" rel=\"external\">Apache tomcat</a>下载zip包，<img src=\"/img/nginx/nginx_01.png\" alt=\"\"><br>找个文件夹解压并且复制一份（可复制多个）如图<br><img src=\"/img/nginx/nginx_02.png\" alt=\"\"></p>\n<h3 id=\"2-修改tomcat的端口号\"><a href=\"#2-修改tomcat的端口号\" class=\"headerlink\" title=\"2.修改tomcat的端口号\"></a>2.修改tomcat的端口号</h3><p>对于搞Java web的小伙伴这就不详细说了。<br>如图所示修改server.xml文件<br><img src=\"/img/nginx/nginx_03.png\" alt=\"\"><br>端口号可随意修改（建议改的大一点）。只要不冲突就OK<br>看过server.xml文件的小伙伴都知道里面有三个端口号:</p>\n<pre><code>8005，8080，8009\n</code></pre><p>这三个端口号分别代表什么意思暂且不说。<br>第一台tomcat不做修改。第二台改成如图所示。当然可以改成你想要的端口号</p>\n<p><img src=\"/img/nginx/nginx_04.png\" alt=\"\"></p>\n<p><img src=\"/img/nginx/nginx_05.png\" alt=\"\"></p>\n<p><img src=\"/img/nginx/nginx_06.png\" alt=\"\"></p>\n<h3 id=\"3-启动tomcat\"><a href=\"#3-启动tomcat\" class=\"headerlink\" title=\"3.启动tomcat\"></a>3.启动tomcat</h3><p>mac中zip包解压后默认bin中的命令是不可以执行的。如图<br><img src=\"/img/nginx/nginx_07.png\" alt=\"\"><br>修改bin中的命令的执行权限然后启动tomcat<br>（使用该命令必须在当前tomcat的bin目录下）<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">chmod</span> <span class=\"number\">777</span> <span class=\"regexp\">*.sh</span></div></pre></td></tr></table></figure></p>\n<p><img src=\"/img/nginx/nginx_08.png\" alt=\"\"></p>\n<p>分别在tomcat的bin目录下执行</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sh</span> startup.<span class=\"keyword\">sh</span></div><div class=\"line\">//<span class=\"keyword\">sh</span> shutdown.<span class=\"keyword\">sh</span> --停止tomcat</div></pre></td></tr></table></figure>\n<p>在两个tomcat的webapps目录下新建一个文件夹名为test.在test中新建文件test.html<br>作为测试tomcat启动后的测试页面。</p>\n<p><img src=\"/img/nginx/nginx_12.png\" alt=\"\"></p>\n<pre><code>分别在body中输入&lt;h2&gt;this is tomcat 1&lt;/h2&gt; 和 &lt;h2&gt;this is tomcat 2&lt;/h2&gt;\n</code></pre><p>如图所示<br><img src=\"/img/nginx/nginx_13.png\" alt=\"\"></p>\n<p>在浏览器中分别输入 ：<br><a href=\"http://localhost:8080/test/test.html\" target=\"_blank\" rel=\"external\">http://localhost:8080/test/test.html</a><br><a href=\"http://localhost:8081/test/test.html\" target=\"_blank\" rel=\"external\">http://localhost:8081/test/test.html</a></p>\n<p>出现如下图时。tomcat安装成功。</p>\n<p><img src=\"/img/nginx/nginx_09.png\" alt=\"\"><br><img src=\"/img/nginx/nginx_10.png\" alt=\"\"></p>\n<h3 id=\"4-安装nginx\"><a href=\"#4-安装nginx\" class=\"headerlink\" title=\"4.安装nginx\"></a>4.安装nginx</h3><p>在mac上安装nginx非常简单 使用brew安装即可</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">brew </span><span class=\"keyword\">install </span>nginx</div></pre></td></tr></table></figure>\n<p>OK nginx 安装成功</p>\n<h3 id=\"5-启动nginx\"><a href=\"#5-启动nginx\" class=\"headerlink\" title=\"5.启动nginx\"></a>5.启动nginx</h3><p>启动命令：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">nginx</span></div></pre></td></tr></table></figure>\n<p>停止命名：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nginx -s <span class=\"built_in\">stop</span></div></pre></td></tr></table></figure>\n<p>默认nginx监听80端口。<br>启动后在浏览器输入：<a href=\"http://localhost\" target=\"_blank\" rel=\"external\">http://localhost</a><br>出现如图择nginx 启动成功<br><img src=\"/img/nginx/nginx_11.png\" alt=\"\"></p>\n<h3 id=\"6-配置负载（也是本blog最重要的点）\"><a href=\"#6-配置负载（也是本blog最重要的点）\" class=\"headerlink\" title=\"6.配置负载（也是本blog最重要的点）\"></a>6.配置负载（也是本blog最重要的点）</h3><p>找到nginx的配置文件:nginx.conf<br>brew安装后默认的配置文件路径为：/usr/local/etc/nginx<br>修改nginx.conf文件如图所示</p>\n<p><img src=\"/img/nginx/nginx_14.png\" alt=\"\"></p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream myTomcat &#123;</div><div class=\"line\"> \t \t<span class=\"keyword\">server</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8080</span> weight=<span class=\"number\">5</span>;</div><div class=\"line\"> \t \t<span class=\"keyword\">server</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8081</span> weight=<span class=\"number\">5</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">server</span> &#123;</div><div class=\"line\">      listen       <span class=\"number\">8888</span>;</div><div class=\"line\">      server_name  localhost;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">#charset koi8-r;</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">#access_log  logs/host.access.log  main;</span></div><div class=\"line\"></div><div class=\"line\">      location / &#123;</div><div class=\"line\">          <span class=\"meta\">#root   html;</span></div><div class=\"line\">          <span class=\"meta\">#index  index.html index.htm;</span></div><div class=\"line\">     \tproxy_pass http:<span class=\"comment\">//myTomcat;</span></div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      ...其余代码省略</div></pre></td></tr></table></figure>\n<h3 id=\"7-验证负载\"><a href=\"#7-验证负载\" class=\"headerlink\" title=\"7.验证负载\"></a>7.验证负载</h3><p>在浏览器中输入 <a href=\"http://localhost:8888/test/test.html\" target=\"_blank\" rel=\"external\">http://localhost:8888/test/test.html</a><br>可打开多个tab也测试。会发现tomcat1 和tomcat2在切换。</p>\n<p><img src=\"/img/nginx/nginx_15.png\" alt=\"\"></p>\n<p>OK。这样就实现了简单的负载均衡。</p>\n<p>PS: nginx的配置需继续研究。</p>\n","excerpt":"","more":"<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0. 简介\"></a>0. 简介</h3><p>使用一台Nginx服务器通过配置多台tomcat实现访问负载均衡。其实网上有很多例子。之前也配置过。不过为了加强记忆。写篇文章记录要点。(实现环境为mac pro)</p>\n<h3 id=\"1-安装tomcat-本例安装2台\"><a href=\"#1-安装tomcat-本例安装2台\" class=\"headerlink\" title=\"1.安装tomcat(本例安装2台)\"></a>1.安装tomcat(本例安装2台)</h3><p>直接去<a href=\"http://tomcat.apache.org/download-70.cgi\">Apache tomcat</a>下载zip包，<img src=\"/img/nginx/nginx_01.png\" alt=\"\"><br>找个文件夹解压并且复制一份（可复制多个）如图<br><img src=\"/img/nginx/nginx_02.png\" alt=\"\"></p>\n<h3 id=\"2-修改tomcat的端口号\"><a href=\"#2-修改tomcat的端口号\" class=\"headerlink\" title=\"2.修改tomcat的端口号\"></a>2.修改tomcat的端口号</h3><p>对于搞Java web的小伙伴这就不详细说了。<br>如图所示修改server.xml文件<br><img src=\"/img/nginx/nginx_03.png\" alt=\"\"><br>端口号可随意修改（建议改的大一点）。只要不冲突就OK<br>看过server.xml文件的小伙伴都知道里面有三个端口号:</p>\n<pre><code>8005，8080，8009\n</code></pre><p>这三个端口号分别代表什么意思暂且不说。<br>第一台tomcat不做修改。第二台改成如图所示。当然可以改成你想要的端口号</p>\n<p><img src=\"/img/nginx/nginx_04.png\" alt=\"\"></p>\n<p><img src=\"/img/nginx/nginx_05.png\" alt=\"\"></p>\n<p><img src=\"/img/nginx/nginx_06.png\" alt=\"\"></p>\n<h3 id=\"3-启动tomcat\"><a href=\"#3-启动tomcat\" class=\"headerlink\" title=\"3.启动tomcat\"></a>3.启动tomcat</h3><p>mac中zip包解压后默认bin中的命令是不可以执行的。如图<br><img src=\"/img/nginx/nginx_07.png\" alt=\"\"><br>修改bin中的命令的执行权限然后启动tomcat<br>（使用该命令必须在当前tomcat的bin目录下）<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">chmod</span> <span class=\"number\">777</span> <span class=\"regexp\">*.sh</span></div></pre></td></tr></table></figure></p>\n<p><img src=\"/img/nginx/nginx_08.png\" alt=\"\"></p>\n<p>分别在tomcat的bin目录下执行</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">sh</span> startup.<span class=\"keyword\">sh</span></div><div class=\"line\">//<span class=\"keyword\">sh</span> shutdown.<span class=\"keyword\">sh</span> --停止tomcat</div></pre></td></tr></table></figure>\n<p>在两个tomcat的webapps目录下新建一个文件夹名为test.在test中新建文件test.html<br>作为测试tomcat启动后的测试页面。</p>\n<p><img src=\"/img/nginx/nginx_12.png\" alt=\"\"></p>\n<pre><code>分别在body中输入&lt;h2&gt;this is tomcat 1&lt;/h2&gt; 和 &lt;h2&gt;this is tomcat 2&lt;/h2&gt;\n</code></pre><p>如图所示<br><img src=\"/img/nginx/nginx_13.png\" alt=\"\"></p>\n<p>在浏览器中分别输入 ：<br><a href=\"http://localhost:8080/test/test.html\">http://localhost:8080/test/test.html</a><br><a href=\"http://localhost:8081/test/test.html\">http://localhost:8081/test/test.html</a></p>\n<p>出现如下图时。tomcat安装成功。</p>\n<p><img src=\"/img/nginx/nginx_09.png\" alt=\"\"><br><img src=\"/img/nginx/nginx_10.png\" alt=\"\"></p>\n<h3 id=\"4-安装nginx\"><a href=\"#4-安装nginx\" class=\"headerlink\" title=\"4.安装nginx\"></a>4.安装nginx</h3><p>在mac上安装nginx非常简单 使用brew安装即可</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">brew </span><span class=\"keyword\">install </span>nginx</div></pre></td></tr></table></figure>\n<p>OK nginx 安装成功</p>\n<h3 id=\"5-启动nginx\"><a href=\"#5-启动nginx\" class=\"headerlink\" title=\"5.启动nginx\"></a>5.启动nginx</h3><p>启动命令：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">nginx</span></div></pre></td></tr></table></figure>\n<p>停止命名：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nginx -s <span class=\"built_in\">stop</span></div></pre></td></tr></table></figure>\n<p>默认nginx监听80端口。<br>启动后在浏览器输入：<a href=\"http://localhost\">http://localhost</a><br>出现如图择nginx 启动成功<br><img src=\"/img/nginx/nginx_11.png\" alt=\"\"></p>\n<h3 id=\"6-配置负载（也是本blog最重要的点）\"><a href=\"#6-配置负载（也是本blog最重要的点）\" class=\"headerlink\" title=\"6.配置负载（也是本blog最重要的点）\"></a>6.配置负载（也是本blog最重要的点）</h3><p>找到nginx的配置文件:nginx.conf<br>brew安装后默认的配置文件路径为：/usr/local/etc/nginx<br>修改nginx.conf文件如图所示</p>\n<p><img src=\"/img/nginx/nginx_14.png\" alt=\"\"></p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream myTomcat &#123;</div><div class=\"line\"> \t \t<span class=\"keyword\">server</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8080</span> weight=<span class=\"number\">5</span>;</div><div class=\"line\"> \t \t<span class=\"keyword\">server</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8081</span> weight=<span class=\"number\">5</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">server</span> &#123;</div><div class=\"line\">      listen       <span class=\"number\">8888</span>;</div><div class=\"line\">      server_name  localhost;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">#charset koi8-r;</span></div><div class=\"line\"></div><div class=\"line\">      <span class=\"meta\">#access_log  logs/host.access.log  main;</span></div><div class=\"line\"></div><div class=\"line\">      location / &#123;</div><div class=\"line\">          <span class=\"meta\">#root   html;</span></div><div class=\"line\">          <span class=\"meta\">#index  index.html index.htm;</span></div><div class=\"line\">     \tproxy_pass http:<span class=\"comment\">//myTomcat;</span></div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      ...其余代码省略</div></pre></td></tr></table></figure>\n<h3 id=\"7-验证负载\"><a href=\"#7-验证负载\" class=\"headerlink\" title=\"7.验证负载\"></a>7.验证负载</h3><p>在浏览器中输入 <a href=\"http://localhost:8888/test/test.html\">http://localhost:8888/test/test.html</a><br>可打开多个tab也测试。会发现tomcat1 和tomcat2在切换。</p>\n<p><img src=\"/img/nginx/nginx_15.png\" alt=\"\"></p>\n<p>OK。这样就实现了简单的负载均衡。</p>\n<p>PS: nginx的配置需继续研究。</p>\n"},{"title":"《深入理解Java虚拟机》读书笔记（二）","date":"2016-09-26T08:07:56.000Z","_content":"\n### 0.垃圾回收\n\n程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了\n\n#### 1.判断对象存活\n\n#### 1.1.1 引用计数器法\n\n给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的\n\n#### 1.1.2 可达性分析算法\n\n通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的\n\nJava语言中GC Roots的对象包括下面几种：\n\n1.虚拟机栈（栈帧中的本地变量表）中引用的对象\n\n2.方法区中类静态属性引用的对象\n\n3.方法区中常量引用的对象\n\n4.本地方法栈JNI（Native方法）引用的对象\n\n### 2.引用\n\n强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象\n\n软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常\n\n弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象\n\n虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知\n\n### 3.Finalize方法\n\n任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了\n\n#### 3.1 回收方法区\n\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类\n\n废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池\n\n无用的类：\n\n1.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例\n\n2.加载该类的ClassLoader已经被回收\n\n3.该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法\n\n### 4.垃圾收集算法\n\n#### 4.1 标记—清除算法\n\n算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象、\n\n不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作\n\n#### 4.2 复制算法\n\n他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可\n\n不足：将内存缩小为了原来的一半\n\n实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor\n\n当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代\n\n#### 4.3 标记整理算法\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n\n#### 4.4 分代收集算法\n\n只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收\n\n### 5.垃圾收集器\n\na)Serial收集器：\n\n这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它手机结束\n\nb)ParNew 收集器：\n\nSerial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样\n\n并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态\n\n并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上\n\nc)Parallel Scavenge \n\n收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。\n\n吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）\n\nd)Serial Old 收集器：\n\n是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法\n\ne)Parallel Old 收集器：\n\nParallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法\n\nf)CMS收集器：\n\nCMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：\n\n1.初始标记2.并发标记3.重新标记4.并发清除\n\n优点：并发收集、低停顿\n\n缺点：\n\n1.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，\n\n2.CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生\n\n3.CMS是基于标记清除算法实现的\n\ng)G1收集器：\n\n它是一款面向服务器应用的垃圾收集器\n\n1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间\n\n2.分代收集\n\n3.空间整合：不会产生内存碎片\n\n4.可预测的停顿\n\n运作方式：初始标记，并发标记，最终标记，筛选回收\n\n### 6.内存分配与回收策略\n\n#### 6.1 对象优先在Eden分配：\n\n大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n\n#### 6.2 大对象直接进入老年代：\n\n所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制\n\n#### 6.3 长期存活的对象将进入老年代\n\n如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中\n\n#### 6.4 动态对象年龄判定\n\n为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄\n\n#### 6.5 空间分配担保：\n\n在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC\n","source":"_posts/《深入理解Java虚拟机》读书笔记（二）.md","raw":"---\ntitle: 《深入理解Java虚拟机》读书笔记（二）\ndate: 2016-09-26 16:07:56\ntags:\n\t- Java\n\t- Java虚拟机\n---\n\n### 0.垃圾回收\n\n程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了\n\n#### 1.判断对象存活\n\n#### 1.1.1 引用计数器法\n\n给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的\n\n#### 1.1.2 可达性分析算法\n\n通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的\n\nJava语言中GC Roots的对象包括下面几种：\n\n1.虚拟机栈（栈帧中的本地变量表）中引用的对象\n\n2.方法区中类静态属性引用的对象\n\n3.方法区中常量引用的对象\n\n4.本地方法栈JNI（Native方法）引用的对象\n\n### 2.引用\n\n强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象\n\n软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常\n\n弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象\n\n虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知\n\n### 3.Finalize方法\n\n任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了\n\n#### 3.1 回收方法区\n\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类\n\n废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池\n\n无用的类：\n\n1.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例\n\n2.加载该类的ClassLoader已经被回收\n\n3.该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法\n\n### 4.垃圾收集算法\n\n#### 4.1 标记—清除算法\n\n算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象、\n\n不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作\n\n#### 4.2 复制算法\n\n他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可\n\n不足：将内存缩小为了原来的一半\n\n实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor\n\n当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代\n\n#### 4.3 标记整理算法\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n\n#### 4.4 分代收集算法\n\n只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收\n\n### 5.垃圾收集器\n\na)Serial收集器：\n\n这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它手机结束\n\nb)ParNew 收集器：\n\nSerial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样\n\n并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态\n\n并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上\n\nc)Parallel Scavenge \n\n收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。\n\n吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）\n\nd)Serial Old 收集器：\n\n是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法\n\ne)Parallel Old 收集器：\n\nParallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法\n\nf)CMS收集器：\n\nCMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：\n\n1.初始标记2.并发标记3.重新标记4.并发清除\n\n优点：并发收集、低停顿\n\n缺点：\n\n1.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，\n\n2.CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生\n\n3.CMS是基于标记清除算法实现的\n\ng)G1收集器：\n\n它是一款面向服务器应用的垃圾收集器\n\n1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间\n\n2.分代收集\n\n3.空间整合：不会产生内存碎片\n\n4.可预测的停顿\n\n运作方式：初始标记，并发标记，最终标记，筛选回收\n\n### 6.内存分配与回收策略\n\n#### 6.1 对象优先在Eden分配：\n\n大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n\n#### 6.2 大对象直接进入老年代：\n\n所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制\n\n#### 6.3 长期存活的对象将进入老年代\n\n如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中\n\n#### 6.4 动态对象年龄判定\n\n为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄\n\n#### 6.5 空间分配担保：\n\n在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC\n","slug":"《深入理解Java虚拟机》读书笔记（二）","published":1,"updated":"2016-11-16T08:16:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmf000q07fyboiamfkk","content":"<h3 id=\"0-垃圾回收\"><a href=\"#0-垃圾回收\" class=\"headerlink\" title=\"0.垃圾回收\"></a>0.垃圾回收</h3><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</p>\n<h4 id=\"1-判断对象存活\"><a href=\"#1-判断对象存活\" class=\"headerlink\" title=\"1.判断对象存活\"></a>1.判断对象存活</h4><h4 id=\"1-1-1-引用计数器法\"><a href=\"#1-1-1-引用计数器法\" class=\"headerlink\" title=\"1.1.1 引用计数器法\"></a>1.1.1 引用计数器法</h4><p>给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>\n<h4 id=\"1-1-2-可达性分析算法\"><a href=\"#1-1-2-可达性分析算法\" class=\"headerlink\" title=\"1.1.2 可达性分析算法\"></a>1.1.2 可达性分析算法</h4><p>通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的</p>\n<p>Java语言中GC Roots的对象包括下面几种：</p>\n<p>1.虚拟机栈（栈帧中的本地变量表）中引用的对象</p>\n<p>2.方法区中类静态属性引用的对象</p>\n<p>3.方法区中常量引用的对象</p>\n<p>4.本地方法栈JNI（Native方法）引用的对象</p>\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h3><p>强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</p>\n<p>软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常</p>\n<p>弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象</p>\n<p>虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p>\n<h3 id=\"3-Finalize方法\"><a href=\"#3-Finalize方法\" class=\"headerlink\" title=\"3.Finalize方法\"></a>3.Finalize方法</h3><p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了</p>\n<h4 id=\"3-1-回收方法区\"><a href=\"#3-1-回收方法区\" class=\"headerlink\" title=\"3.1 回收方法区\"></a>3.1 回收方法区</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p>\n<p>废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池</p>\n<p>无用的类：</p>\n<p>1.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例</p>\n<p>2.加载该类的ClassLoader已经被回收</p>\n<p>3.该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法</p>\n<h3 id=\"4-垃圾收集算法\"><a href=\"#4-垃圾收集算法\" class=\"headerlink\" title=\"4.垃圾收集算法\"></a>4.垃圾收集算法</h3><h4 id=\"4-1-标记—清除算法\"><a href=\"#4-1-标记—清除算法\" class=\"headerlink\" title=\"4.1 标记—清除算法\"></a>4.1 标记—清除算法</h4><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象、</p>\n<p>不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>\n<h4 id=\"4-2-复制算法\"><a href=\"#4-2-复制算法\" class=\"headerlink\" title=\"4.2 复制算法\"></a>4.2 复制算法</h4><p>他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可</p>\n<p>不足：将内存缩小为了原来的一半</p>\n<p>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor</p>\n<p>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</p>\n<h4 id=\"4-3-标记整理算法\"><a href=\"#4-3-标记整理算法\" class=\"headerlink\" title=\"4.3 标记整理算法\"></a>4.3 标记整理算法</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>\n<h4 id=\"4-4-分代收集算法\"><a href=\"#4-4-分代收集算法\" class=\"headerlink\" title=\"4.4 分代收集算法\"></a>4.4 分代收集算法</h4><p>只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收</p>\n<h3 id=\"5-垃圾收集器\"><a href=\"#5-垃圾收集器\" class=\"headerlink\" title=\"5.垃圾收集器\"></a>5.垃圾收集器</h3><p>a)Serial收集器：</p>\n<p>这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它手机结束</p>\n<p>b)ParNew 收集器：</p>\n<p>Serial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样</p>\n<p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</p>\n<p>并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</p>\n<p>c)Parallel Scavenge </p>\n<p>收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。</p>\n<p>吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>\n<p>d)Serial Old 收集器：</p>\n<p>是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法</p>\n<p>e)Parallel Old 收集器：</p>\n<p>Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法</p>\n<p>f)CMS收集器：</p>\n<p>CMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：</p>\n<p>1.初始标记2.并发标记3.重新标记4.并发清除</p>\n<p>优点：并发收集、低停顿</p>\n<p>缺点：</p>\n<p>1.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</p>\n<p>2.CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生</p>\n<p>3.CMS是基于标记清除算法实现的</p>\n<p>g)G1收集器：</p>\n<p>它是一款面向服务器应用的垃圾收集器</p>\n<p>1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间</p>\n<p>2.分代收集</p>\n<p>3.空间整合：不会产生内存碎片</p>\n<p>4.可预测的停顿</p>\n<p>运作方式：初始标记，并发标记，最终标记，筛选回收</p>\n<h3 id=\"6-内存分配与回收策略\"><a href=\"#6-内存分配与回收策略\" class=\"headerlink\" title=\"6.内存分配与回收策略\"></a>6.内存分配与回收策略</h3><h4 id=\"6-1-对象优先在Eden分配：\"><a href=\"#6-1-对象优先在Eden分配：\" class=\"headerlink\" title=\"6.1 对象优先在Eden分配：\"></a>6.1 对象优先在Eden分配：</h4><p>大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p>\n<h4 id=\"6-2-大对象直接进入老年代：\"><a href=\"#6-2-大对象直接进入老年代：\" class=\"headerlink\" title=\"6.2 大对象直接进入老年代：\"></a>6.2 大对象直接进入老年代：</h4><p>所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制</p>\n<h4 id=\"6-3-长期存活的对象将进入老年代\"><a href=\"#6-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"6.3 长期存活的对象将进入老年代\"></a>6.3 长期存活的对象将进入老年代</h4><p>如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中</p>\n<h4 id=\"6-4-动态对象年龄判定\"><a href=\"#6-4-动态对象年龄判定\" class=\"headerlink\" title=\"6.4 动态对象年龄判定\"></a>6.4 动态对象年龄判定</h4><p>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄</p>\n<h4 id=\"6-5-空间分配担保：\"><a href=\"#6-5-空间分配担保：\" class=\"headerlink\" title=\"6.5 空间分配担保：\"></a>6.5 空间分配担保：</h4><p>在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</p>\n","excerpt":"","more":"<h3 id=\"0-垃圾回收\"><a href=\"#0-垃圾回收\" class=\"headerlink\" title=\"0.垃圾回收\"></a>0.垃圾回收</h3><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了</p>\n<h4 id=\"1-判断对象存活\"><a href=\"#1-判断对象存活\" class=\"headerlink\" title=\"1.判断对象存活\"></a>1.判断对象存活</h4><h4 id=\"1-1-1-引用计数器法\"><a href=\"#1-1-1-引用计数器法\" class=\"headerlink\" title=\"1.1.1 引用计数器法\"></a>1.1.1 引用计数器法</h4><p>给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的</p>\n<h4 id=\"1-1-2-可达性分析算法\"><a href=\"#1-1-2-可达性分析算法\" class=\"headerlink\" title=\"1.1.2 可达性分析算法\"></a>1.1.2 可达性分析算法</h4><p>通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的</p>\n<p>Java语言中GC Roots的对象包括下面几种：</p>\n<p>1.虚拟机栈（栈帧中的本地变量表）中引用的对象</p>\n<p>2.方法区中类静态属性引用的对象</p>\n<p>3.方法区中常量引用的对象</p>\n<p>4.本地方法栈JNI（Native方法）引用的对象</p>\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h3><p>强引用就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</p>\n<p>软引用用来描述一些还有用但并非必须的元素。对于它在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常</p>\n<p>弱引用用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象</p>\n<p>虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p>\n<h3 id=\"3-Finalize方法\"><a href=\"#3-Finalize方法\" class=\"headerlink\" title=\"3.Finalize方法\"></a>3.Finalize方法</h3><p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了</p>\n<h4 id=\"3-1-回收方法区\"><a href=\"#3-1-回收方法区\" class=\"headerlink\" title=\"3.1 回收方法区\"></a>3.1 回收方法区</h4><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类</p>\n<p>废弃常量：假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池</p>\n<p>无用的类：</p>\n<p>1.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例</p>\n<p>2.加载该类的ClassLoader已经被回收</p>\n<p>3.该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法</p>\n<h3 id=\"4-垃圾收集算法\"><a href=\"#4-垃圾收集算法\" class=\"headerlink\" title=\"4.垃圾收集算法\"></a>4.垃圾收集算法</h3><h4 id=\"4-1-标记—清除算法\"><a href=\"#4-1-标记—清除算法\" class=\"headerlink\" title=\"4.1 标记—清除算法\"></a>4.1 标记—清除算法</h4><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象、</p>\n<p>不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>\n<h4 id=\"4-2-复制算法\"><a href=\"#4-2-复制算法\" class=\"headerlink\" title=\"4.2 复制算法\"></a>4.2 复制算法</h4><p>他将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可</p>\n<p>不足：将内存缩小为了原来的一半</p>\n<p>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor</p>\n<p>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</p>\n<h4 id=\"4-3-标记整理算法\"><a href=\"#4-3-标记整理算法\" class=\"headerlink\" title=\"4.3 标记整理算法\"></a>4.3 标记整理算法</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>\n<h4 id=\"4-4-分代收集算法\"><a href=\"#4-4-分代收集算法\" class=\"headerlink\" title=\"4.4 分代收集算法\"></a>4.4 分代收集算法</h4><p>只是根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收</p>\n<h3 id=\"5-垃圾收集器\"><a href=\"#5-垃圾收集器\" class=\"headerlink\" title=\"5.垃圾收集器\"></a>5.垃圾收集器</h3><p>a)Serial收集器：</p>\n<p>这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个COU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它手机结束</p>\n<p>b)ParNew 收集器：</p>\n<p>Serial收集器的多线程版本，除了使用了多线程进行收集之外，其余行为和Serial收集器一样</p>\n<p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</p>\n<p>并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</p>\n<p>c)Parallel Scavenge </p>\n<p>收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器。</p>\n<p>吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>\n<p>d)Serial Old 收集器：</p>\n<p>是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法</p>\n<p>e)Parallel Old 收集器：</p>\n<p>Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法</p>\n<p>f)CMS收集器：</p>\n<p>CMS收集器是基于标记清除算法实现的，整个过程分为4个步骤：</p>\n<p>1.初始标记2.并发标记3.重新标记4.并发清除</p>\n<p>优点：并发收集、低停顿</p>\n<p>缺点：</p>\n<p>1.CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</p>\n<p>2.CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full G场地产生</p>\n<p>3.CMS是基于标记清除算法实现的</p>\n<p>g)G1收集器：</p>\n<p>它是一款面向服务器应用的垃圾收集器</p>\n<p>1.并行与并发：利用多CPU缩短STOP-The-World停顿的时间</p>\n<p>2.分代收集</p>\n<p>3.空间整合：不会产生内存碎片</p>\n<p>4.可预测的停顿</p>\n<p>运作方式：初始标记，并发标记，最终标记，筛选回收</p>\n<h3 id=\"6-内存分配与回收策略\"><a href=\"#6-内存分配与回收策略\" class=\"headerlink\" title=\"6.内存分配与回收策略\"></a>6.内存分配与回收策略</h3><h4 id=\"6-1-对象优先在Eden分配：\"><a href=\"#6-1-对象优先在Eden分配：\" class=\"headerlink\" title=\"6.1 对象优先在Eden分配：\"></a>6.1 对象优先在Eden分配：</h4><p>大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p>\n<h4 id=\"6-2-大对象直接进入老年代：\"><a href=\"#6-2-大对象直接进入老年代：\" class=\"headerlink\" title=\"6.2 大对象直接进入老年代：\"></a>6.2 大对象直接进入老年代：</h4><p>所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制</p>\n<h4 id=\"6-3-长期存活的对象将进入老年代\"><a href=\"#6-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"6.3 长期存活的对象将进入老年代\"></a>6.3 长期存活的对象将进入老年代</h4><p>如果对象在Eden区出生并且尽力过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1.对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中</p>\n<h4 id=\"6-4-动态对象年龄判定\"><a href=\"#6-4-动态对象年龄判定\" class=\"headerlink\" title=\"6.4 动态对象年龄判定\"></a>6.4 动态对象年龄判定</h4><p>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄</p>\n<h4 id=\"6-5-空间分配担保：\"><a href=\"#6-5-空间分配担保：\" class=\"headerlink\" title=\"6.5 空间分配担保：\"></a>6.5 空间分配担保：</h4><p>在发生Minor GC 之前，虚拟机会检查老年代最大可 用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</p>\n"},{"title":"学吉他","date":"2015-09-05T12:04:10.000Z","_content":"\n舍友买了把吉他，没事的时候自己也学学，怎么说呢，感觉很有意思，音乐确实是个比较有趣的东西。\n","source":"_posts/学吉他.md","raw":"title: 学吉他\ndate: 2015-09-05 20:04:10\ntags:\n---\n\n舍友买了把吉他，没事的时候自己也学学，怎么说呢，感觉很有意思，音乐确实是个比较有趣的东西。\n","slug":"学吉他","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmg000s07fyhkr3omn9","content":"<p>舍友买了把吉他，没事的时候自己也学学，怎么说呢，感觉很有意思，音乐确实是个比较有趣的东西。</p>\n","excerpt":"","more":"<p>舍友买了把吉他，没事的时候自己也学学，怎么说呢，感觉很有意思，音乐确实是个比较有趣的东西。</p>\n"},{"title":"我的iOS开发之路","date":"2015-08-23T14:20:38.000Z","_content":"######谨以此文记录我的学习之路\n###0.入门\n    我iOS入门基本是靠自学，看官网的文档和实例代码，看过网上的视频教程，看外国的网站，也看别人写的代码。\n    我是14年开始学的这在近两年的学习和开发过程中收获和很多，\n\n####下面是我常去的一些网站\n","source":"_posts/测试文章.md","raw":"title: 我的iOS开发之路\n\ndate: 2015-08-23 22:20:38\ntags: iOS\n---\n######谨以此文记录我的学习之路\n###0.入门\n    我iOS入门基本是靠自学，看官网的文档和实例代码，看过网上的视频教程，看外国的网站，也看别人写的代码。\n    我是14年开始学的这在近两年的学习和开发过程中收获和很多，\n\n####下面是我常去的一些网站\n","slug":"测试文章","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmh000u07fy0llat3i7","content":"<p>######谨以此文记录我的学习之路</p>\n<p>###0.入门<br>    我iOS入门基本是靠自学，看官网的文档和实例代码，看过网上的视频教程，看外国的网站，也看别人写的代码。<br>    我是14年开始学的这在近两年的学习和开发过程中收获和很多，</p>\n<p>####下面是我常去的一些网站</p>\n","excerpt":"","more":"<p>######谨以此文记录我的学习之路</p>\n<p>###0.入门<br>    我iOS入门基本是靠自学，看官网的文档和实例代码，看过网上的视频教程，看外国的网站，也看别人写的代码。<br>    我是14年开始学的这在近两年的学习和开发过程中收获和很多，</p>\n<p>####下面是我常去的一些网站</p>\n"},{"title":"博客说明","date":"2016-09-01T05:44:13.000Z","_content":"\n上大学时在CSDN上写过几遍总计性质的博客，后来工作了用基本没有写，许多东西总结在了印象笔记里（感觉还不错，有忘记了的代码段或者其他就去印象笔记里翻翻）,最近时间比较充裕，把之前自己总结的东西写出来分享给大家，如有问题请留言或者评论或者微博私信（联系方式见首页）。也希望能和各路小伙伴成为好朋友，共同进步。\n","source":"_posts/博客说明.md","raw":"---\ntitle: 博客说明\ndate: 2016-09-01 13:44:13\ntags:\n\n---\n\n上大学时在CSDN上写过几遍总计性质的博客，后来工作了用基本没有写，许多东西总结在了印象笔记里（感觉还不错，有忘记了的代码段或者其他就去印象笔记里翻翻）,最近时间比较充裕，把之前自己总结的东西写出来分享给大家，如有问题请留言或者评论或者微博私信（联系方式见首页）。也希望能和各路小伙伴成为好朋友，共同进步。\n","slug":"博客说明","published":1,"updated":"2016-09-09T06:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmi000x07fymsqla11v","content":"<p>上大学时在CSDN上写过几遍总计性质的博客，后来工作了用基本没有写，许多东西总结在了印象笔记里（感觉还不错，有忘记了的代码段或者其他就去印象笔记里翻翻）,最近时间比较充裕，把之前自己总结的东西写出来分享给大家，如有问题请留言或者评论或者微博私信（联系方式见首页）。也希望能和各路小伙伴成为好朋友，共同进步。</p>\n","excerpt":"","more":"<p>上大学时在CSDN上写过几遍总计性质的博客，后来工作了用基本没有写，许多东西总结在了印象笔记里（感觉还不错，有忘记了的代码段或者其他就去印象笔记里翻翻）,最近时间比较充裕，把之前自己总结的东西写出来分享给大家，如有问题请留言或者评论或者微博私信（联系方式见首页）。也希望能和各路小伙伴成为好朋友，共同进步。</p>\n"},{"title":"算法(一):Stack(栈)的实现","date":"2016-09-10T06:52:55.000Z","_content":"### 0.简介\n阅读过Java Stack源码的同学都只知道，Stack(栈)是继承自Vector(通常称为向量)而Vector是基于数组实现的，所以Stack也是是基于数组实现的。\n### 1.特点\nStack(栈)作为一种简单的数据结构,其特点就是先进后出即First In Last Out(FILO)。其与另外一中数据结构Queue(队列)相反。队列是先进先出的。举个例子：栈比作一根一头封闭的管道，数据比作一个个小球，小球进入管道后先进去的在最里。而后进管道的小球在最外。先把所有的小球都拿出来的时候，其出来的顺序与进入的顺序是相反的。（队列下一片文章介绍）\n ![](/img/stack/stack.jpg)\n### 2.基本方法\n```\npush() //压栈\npop()\t//出栈\npeek() //或的栈顶元素\nisEmpty() //栈是否为空\n\t\n```\n### 3.代码实现(java 实现)\n先上代码再分析\n\n```\nimport java.util.Arrays;\n\npublic class MyStack<T> {\n\t//数据\n\t Object[] data;\n\t//大小\n\tprivate int size;\n\t//默认容量\n\tprivate int capacity;\n\t//构造函数\n\tpublic MyStack() {\n\t\tthis.size = 0;\n\t\tthis.capacity = 10;\n\t\tthis.data = new Object[capacity];\n\t}\n\t//扩容方法\n\tprivate void ensureCapacity(){\n\t\tcapacity = capacity * 2;\n\t\tdata = Arrays.copyOf(data, capacity);\n\t}\n\t//push\n\tpublic void push(T element){\n\t\t//是否需要扩容\n\t\tif (size < capacity) {\n\t\t\tdata[size++] = element;\n\t\t}else{\n\t\t\tensureCapacity();\n\t\t\tdata[size++] = element;\n\t\t}\n\t}\n\t//pop\n\tpublic T pop(){\n\t\tif (size > 0) {\n\t\t\tObject obj = data[size-1];\n\t\t\tdata[--size] = null;\n\t\t\treturn (T) obj;\n\t\t}else{\n\t\t\tSystem.out.println(\"stack empty\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t//isEmpty\n\tpublic boolean isEmpty(){\n\t\treturn size == 0;\n\t}\n\t//栈顶元素\n\tpublic T peek(){\n\t\tif (size > 0) {\n\t\t\treturn (T) data[size - 1];\n\t\t}\n\t\treturn null;\n\t}\n\t//测试方法\n\tpublic static void main(String[] args) {\n\t\tMyStack<String> myStack = new MyStack<String>();\n\t\t\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tString string = \"stack--\"+i;\n\t\t\tmyStack.push(string);\n\t\t\tSystem.out.println(\"push---\"+string);\n\t\t}\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tSystem.out.println(\"pop---\"+myStack.pop());\n\n\t\t\tSystem.out.println(\"peek---\"+myStack.peek());\n\t\t\t\n\t\t}\n\t\tSystem.out.println(\"peek---\"+myStack.peek());\n\t\tSystem.out.println(myStack.isEmpty());\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tSystem.out.println(\"pop---\"+myStack.pop());\n\t\t}\n\t\t\tSystem.out.println(myStack.isEmpty());\n\t\t\n\t}\n\n}\n\n```\n\n本代码只是简单实现一个栈的基本功能（不完善）感兴趣的同学可以参考Java Util包下的Stack和Vector具体实现方式。看了Java源码才发现自己代码与源码的差距简直是差太多了。不够可以发现Stack和Vector都是县城安全的（pop peek等方法都有synchronized关键字修饰）。栈的代码实现比较简单不做过多的分析了。之后可以一起阅读Stack和Vector的源码。\n\n","source":"_posts/算法-一-Stack-栈-的实现.md","raw":"---\ntitle: '算法(一):Stack(栈)的实现'\ndate: 2016-09-10 14:52:55\ntags:\n\t- 算法\n\t- Stack\n\t- 栈\n---\n### 0.简介\n阅读过Java Stack源码的同学都只知道，Stack(栈)是继承自Vector(通常称为向量)而Vector是基于数组实现的，所以Stack也是是基于数组实现的。\n### 1.特点\nStack(栈)作为一种简单的数据结构,其特点就是先进后出即First In Last Out(FILO)。其与另外一中数据结构Queue(队列)相反。队列是先进先出的。举个例子：栈比作一根一头封闭的管道，数据比作一个个小球，小球进入管道后先进去的在最里。而后进管道的小球在最外。先把所有的小球都拿出来的时候，其出来的顺序与进入的顺序是相反的。（队列下一片文章介绍）\n ![](/img/stack/stack.jpg)\n### 2.基本方法\n```\npush() //压栈\npop()\t//出栈\npeek() //或的栈顶元素\nisEmpty() //栈是否为空\n\t\n```\n### 3.代码实现(java 实现)\n先上代码再分析\n\n```\nimport java.util.Arrays;\n\npublic class MyStack<T> {\n\t//数据\n\t Object[] data;\n\t//大小\n\tprivate int size;\n\t//默认容量\n\tprivate int capacity;\n\t//构造函数\n\tpublic MyStack() {\n\t\tthis.size = 0;\n\t\tthis.capacity = 10;\n\t\tthis.data = new Object[capacity];\n\t}\n\t//扩容方法\n\tprivate void ensureCapacity(){\n\t\tcapacity = capacity * 2;\n\t\tdata = Arrays.copyOf(data, capacity);\n\t}\n\t//push\n\tpublic void push(T element){\n\t\t//是否需要扩容\n\t\tif (size < capacity) {\n\t\t\tdata[size++] = element;\n\t\t}else{\n\t\t\tensureCapacity();\n\t\t\tdata[size++] = element;\n\t\t}\n\t}\n\t//pop\n\tpublic T pop(){\n\t\tif (size > 0) {\n\t\t\tObject obj = data[size-1];\n\t\t\tdata[--size] = null;\n\t\t\treturn (T) obj;\n\t\t}else{\n\t\t\tSystem.out.println(\"stack empty\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t//isEmpty\n\tpublic boolean isEmpty(){\n\t\treturn size == 0;\n\t}\n\t//栈顶元素\n\tpublic T peek(){\n\t\tif (size > 0) {\n\t\t\treturn (T) data[size - 1];\n\t\t}\n\t\treturn null;\n\t}\n\t//测试方法\n\tpublic static void main(String[] args) {\n\t\tMyStack<String> myStack = new MyStack<String>();\n\t\t\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tString string = \"stack--\"+i;\n\t\t\tmyStack.push(string);\n\t\t\tSystem.out.println(\"push---\"+string);\n\t\t}\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tSystem.out.println(\"pop---\"+myStack.pop());\n\n\t\t\tSystem.out.println(\"peek---\"+myStack.peek());\n\t\t\t\n\t\t}\n\t\tSystem.out.println(\"peek---\"+myStack.peek());\n\t\tSystem.out.println(myStack.isEmpty());\n\t\tfor (int i = 0; i < 6; i++) {\n\t\t\tSystem.out.println(\"pop---\"+myStack.pop());\n\t\t}\n\t\t\tSystem.out.println(myStack.isEmpty());\n\t\t\n\t}\n\n}\n\n```\n\n本代码只是简单实现一个栈的基本功能（不完善）感兴趣的同学可以参考Java Util包下的Stack和Vector具体实现方式。看了Java源码才发现自己代码与源码的差距简直是差太多了。不够可以发现Stack和Vector都是县城安全的（pop peek等方法都有synchronized关键字修饰）。栈的代码实现比较简单不做过多的分析了。之后可以一起阅读Stack和Vector的源码。\n\n","slug":"算法-一-Stack-栈-的实现","published":1,"updated":"2016-09-23T01:35:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmk000z07fy7numomm9","content":"<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0.简介\"></a>0.简介</h3><p>阅读过Java Stack源码的同学都只知道，Stack(栈)是继承自Vector(通常称为向量)而Vector是基于数组实现的，所以Stack也是是基于数组实现的。</p>\n<h3 id=\"1-特点\"><a href=\"#1-特点\" class=\"headerlink\" title=\"1.特点\"></a>1.特点</h3><p>Stack(栈)作为一种简单的数据结构,其特点就是先进后出即First In Last Out(FILO)。其与另外一中数据结构Queue(队列)相反。队列是先进先出的。举个例子：栈比作一根一头封闭的管道，数据比作一个个小球，小球进入管道后先进去的在最里。而后进管道的小球在最外。先把所有的小球都拿出来的时候，其出来的顺序与进入的顺序是相反的。（队列下一片文章介绍）<br> <img src=\"/img/stack/stack.jpg\" alt=\"\"></p>\n<h3 id=\"2-基本方法\"><a href=\"#2-基本方法\" class=\"headerlink\" title=\"2.基本方法\"></a>2.基本方法</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">push</span><span class=\"params\">()</span></span> <span class=\"comment\">//压栈</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">pop</span><span class=\"params\">()</span></span>\t<span class=\"comment\">//出栈</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">peek</span><span class=\"params\">()</span></span> <span class=\"comment\">//或的栈顶元素</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">isEmpty</span><span class=\"params\">()</span></span> <span class=\"comment\">//栈是否为空</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-代码实现-java-实现\"><a href=\"#3-代码实现-java-实现\" class=\"headerlink\" title=\"3.代码实现(java 实现)\"></a>3.代码实现(java 实现)</h3><p>先上代码再分析</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> MyStack&lt;T&gt; &#123;</div><div class=\"line\">\t<span class=\"comment\">//数据</span></div><div class=\"line\">\t Object[] data;</div><div class=\"line\">\t<span class=\"comment\">//大小</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"built_in\">size</span>;</div><div class=\"line\">\t<span class=\"comment\">//默认容量</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\">\t<span class=\"comment\">//构造函数</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> MyStack() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"built_in\">size</span> = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.capacity = <span class=\"number\">10</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.data = <span class=\"keyword\">new</span> Object[capacity];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//扩容方法</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">void</span> ensureCapacity()&#123;</div><div class=\"line\">\t\tcapacity = capacity * <span class=\"number\">2</span>;</div><div class=\"line\">\t\tdata = Arrays.copyOf(data, capacity);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//push</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> push(T element)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//是否需要扩容</span></div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &lt; capacity) &#123;</div><div class=\"line\">\t\t\tdata[<span class=\"built_in\">size</span>++] = element;</div><div class=\"line\">\t\t&#125;<span class=\"built_in\">else</span>&#123;</div><div class=\"line\">\t\t\tensureCapacity();</div><div class=\"line\">\t\t\tdata[<span class=\"built_in\">size</span>++] = element;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//pop</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> T pop()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\tObject obj = data[<span class=\"built_in\">size</span><span class=\"number\">-1</span>];</div><div class=\"line\">\t\t\tdata[--<span class=\"built_in\">size</span>] = null;</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> (T) obj;</div><div class=\"line\">\t\t&#125;<span class=\"built_in\">else</span>&#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"stack empty\"</span>);</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> null;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//isEmpty</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> isEmpty()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> <span class=\"built_in\">size</span> == <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//栈顶元素</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> T <span class=\"built_in\">peek</span>()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> (T) data[<span class=\"built_in\">size</span> - <span class=\"number\">1</span>];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> null;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//测试方法</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">\t\tMyStack&lt;<span class=\"keyword\">String</span>&gt; myStack = <span class=\"keyword\">new</span> MyStack&lt;<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">String</span> <span class=\"keyword\">string</span> = <span class=\"string\">\"stack--\"</span>+i;</div><div class=\"line\">\t\t\tmyStack.push(<span class=\"keyword\">string</span>);</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"push---\"</span>+<span class=\"keyword\">string</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"pop---\"</span>+myStack.pop());</div><div class=\"line\"></div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek---\"</span>+myStack.<span class=\"built_in\">peek</span>());</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek---\"</span>+myStack.<span class=\"built_in\">peek</span>());</div><div class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(myStack.isEmpty());</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"pop---\"</span>+myStack.pop());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(myStack.isEmpty());</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本代码只是简单实现一个栈的基本功能（不完善）感兴趣的同学可以参考Java Util包下的Stack和Vector具体实现方式。看了Java源码才发现自己代码与源码的差距简直是差太多了。不够可以发现Stack和Vector都是县城安全的（pop peek等方法都有synchronized关键字修饰）。栈的代码实现比较简单不做过多的分析了。之后可以一起阅读Stack和Vector的源码。</p>\n","excerpt":"","more":"<h3 id=\"0-简介\"><a href=\"#0-简介\" class=\"headerlink\" title=\"0.简介\"></a>0.简介</h3><p>阅读过Java Stack源码的同学都只知道，Stack(栈)是继承自Vector(通常称为向量)而Vector是基于数组实现的，所以Stack也是是基于数组实现的。</p>\n<h3 id=\"1-特点\"><a href=\"#1-特点\" class=\"headerlink\" title=\"1.特点\"></a>1.特点</h3><p>Stack(栈)作为一种简单的数据结构,其特点就是先进后出即First In Last Out(FILO)。其与另外一中数据结构Queue(队列)相反。队列是先进先出的。举个例子：栈比作一根一头封闭的管道，数据比作一个个小球，小球进入管道后先进去的在最里。而后进管道的小球在最外。先把所有的小球都拿出来的时候，其出来的顺序与进入的顺序是相反的。（队列下一片文章介绍）<br> <img src=\"/img/stack/stack.jpg\" alt=\"\"></p>\n<h3 id=\"2-基本方法\"><a href=\"#2-基本方法\" class=\"headerlink\" title=\"2.基本方法\"></a>2.基本方法</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">push</span><span class=\"params\">()</span></span> <span class=\"comment\">//压栈</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">pop</span><span class=\"params\">()</span></span>\t<span class=\"comment\">//出栈</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">peek</span><span class=\"params\">()</span></span> <span class=\"comment\">//或的栈顶元素</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">isEmpty</span><span class=\"params\">()</span></span> <span class=\"comment\">//栈是否为空</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-代码实现-java-实现\"><a href=\"#3-代码实现-java-实现\" class=\"headerlink\" title=\"3.代码实现(java 实现)\"></a>3.代码实现(java 实现)</h3><p>先上代码再分析</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> MyStack&lt;T&gt; &#123;</div><div class=\"line\">\t<span class=\"comment\">//数据</span></div><div class=\"line\">\t Object[] data;</div><div class=\"line\">\t<span class=\"comment\">//大小</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"built_in\">size</span>;</div><div class=\"line\">\t<span class=\"comment\">//默认容量</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</div><div class=\"line\">\t<span class=\"comment\">//构造函数</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> MyStack() &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"built_in\">size</span> = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.capacity = <span class=\"number\">10</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.data = <span class=\"keyword\">new</span> Object[capacity];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//扩容方法</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">void</span> ensureCapacity()&#123;</div><div class=\"line\">\t\tcapacity = capacity * <span class=\"number\">2</span>;</div><div class=\"line\">\t\tdata = Arrays.copyOf(data, capacity);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//push</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> push(T element)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">//是否需要扩容</span></div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &lt; capacity) &#123;</div><div class=\"line\">\t\t\tdata[<span class=\"built_in\">size</span>++] = element;</div><div class=\"line\">\t\t&#125;<span class=\"built_in\">else</span>&#123;</div><div class=\"line\">\t\t\tensureCapacity();</div><div class=\"line\">\t\t\tdata[<span class=\"built_in\">size</span>++] = element;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//pop</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> T pop()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\tObject obj = data[<span class=\"built_in\">size</span><span class=\"number\">-1</span>];</div><div class=\"line\">\t\t\tdata[--<span class=\"built_in\">size</span>] = null;</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> (T) obj;</div><div class=\"line\">\t\t&#125;<span class=\"built_in\">else</span>&#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"stack empty\"</span>);</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> null;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//isEmpty</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> isEmpty()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> <span class=\"built_in\">size</span> == <span class=\"number\">0</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//栈顶元素</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> T <span class=\"built_in\">peek</span>()&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">if</span> (<span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">return</span> (T) data[<span class=\"built_in\">size</span> - <span class=\"number\">1</span>];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> null;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">//测试方法</span></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span>[] args) &#123;</div><div class=\"line\">\t\tMyStack&lt;<span class=\"keyword\">String</span>&gt; myStack = <span class=\"keyword\">new</span> MyStack&lt;<span class=\"keyword\">String</span>&gt;();</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">String</span> <span class=\"keyword\">string</span> = <span class=\"string\">\"stack--\"</span>+i;</div><div class=\"line\">\t\t\tmyStack.push(<span class=\"keyword\">string</span>);</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"push---\"</span>+<span class=\"keyword\">string</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"pop---\"</span>+myStack.pop());</div><div class=\"line\"></div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek---\"</span>+myStack.<span class=\"built_in\">peek</span>());</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"peek---\"</span>+myStack.<span class=\"built_in\">peek</span>());</div><div class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(myStack.isEmpty());</div><div class=\"line\">\t\t<span class=\"built_in\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"pop---\"</span>+myStack.pop());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t\tSystem.out.<span class=\"built_in\">println</span>(myStack.isEmpty());</div><div class=\"line\">\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>本代码只是简单实现一个栈的基本功能（不完善）感兴趣的同学可以参考Java Util包下的Stack和Vector具体实现方式。看了Java源码才发现自己代码与源码的差距简直是差太多了。不够可以发现Stack和Vector都是县城安全的（pop peek等方法都有synchronized关键字修饰）。栈的代码实现比较简单不做过多的分析了。之后可以一起阅读Stack和Vector的源码。</p>\n"},{"title":"算法(三)-常用数据结构的定义","subtitle":"java实现","date":"2016-09-12T11:47:51.000Z","_content":"\n\t说明：文章的数据结构是基于Java总结的,java中使用的数据结构就是数组和引用（就是指针）\n\n常用的数据结构有栈，队列，链表，树，图等的数据结构的定义。\n个人觉得了解一种数据结构必须了解它的定义，明白了定义我们就知道如何去扩展。\n\n### 栈 -->本质是数组\njava中Stack类继承自Vector，而Vector的实现是基于数组的\n\n### 队列 -->本质也是数组\nJava中常用的队列就是PriorityQueue 其实现是基于数据的\n\n### 链表一般会分为单链表,循环链表,双向链表\n链表，链表顾名思义就是要连起来么，即当前数据应该了下一个数据是有关联的。\n单链表的基本结构的定义\n\n```\npublic class LinkList<T>{\n\tT data;\n\tLinkList<T> next;\n\tpublic LinkList(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n循环链表的数据结构和单链表相同，只是最后一个元素和第一个元素相连，单链表的最一个元素是null,\n\n双向链表：从字面上理解可知道元素之间的关联是双向的，当前元素不仅和下一个有联系，应该和上一个元素也有关系。我们便可以在单链表的基础上修改成双链表，结构如下\n\n```\npublic class LinkList<T>{\n\tT data;\n\tLinkList<T> next;\n\tLinkList<T> pre;\n\tpublic LinkList(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n### 树 \n树中最重要的莫过于二叉树了，二叉树树的数据结构和链表是类似的(树的一种比较极端的例子就是一棵树只有左子树或者只有右子树，那么其就够就是链表，其本质是相同的区别就在于怎么连)。至于其它树的结构在二叉树的基础上扩展即可，不再详细赘述。\n\n```\npublic class Tree<T>{\n\tT data;\n\tTree<T> left;\n\tTree<T> right;\n\tpublic Tree(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n### 图\ns\n\n","source":"_posts/算法-三-常用数据结构的定义.md","raw":"---\ntitle: 算法(三)-常用数据结构的定义\nsubtitle:   \"java实现\"\ndate: 2016-09-12 19:47:51\ntags:\n\t- 算法\n\t- Java\n\t- 数据结构\n---\n\n\t说明：文章的数据结构是基于Java总结的,java中使用的数据结构就是数组和引用（就是指针）\n\n常用的数据结构有栈，队列，链表，树，图等的数据结构的定义。\n个人觉得了解一种数据结构必须了解它的定义，明白了定义我们就知道如何去扩展。\n\n### 栈 -->本质是数组\njava中Stack类继承自Vector，而Vector的实现是基于数组的\n\n### 队列 -->本质也是数组\nJava中常用的队列就是PriorityQueue 其实现是基于数据的\n\n### 链表一般会分为单链表,循环链表,双向链表\n链表，链表顾名思义就是要连起来么，即当前数据应该了下一个数据是有关联的。\n单链表的基本结构的定义\n\n```\npublic class LinkList<T>{\n\tT data;\n\tLinkList<T> next;\n\tpublic LinkList(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n循环链表的数据结构和单链表相同，只是最后一个元素和第一个元素相连，单链表的最一个元素是null,\n\n双向链表：从字面上理解可知道元素之间的关联是双向的，当前元素不仅和下一个有联系，应该和上一个元素也有关系。我们便可以在单链表的基础上修改成双链表，结构如下\n\n```\npublic class LinkList<T>{\n\tT data;\n\tLinkList<T> next;\n\tLinkList<T> pre;\n\tpublic LinkList(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n### 树 \n树中最重要的莫过于二叉树了，二叉树树的数据结构和链表是类似的(树的一种比较极端的例子就是一棵树只有左子树或者只有右子树，那么其就够就是链表，其本质是相同的区别就在于怎么连)。至于其它树的结构在二叉树的基础上扩展即可，不再详细赘述。\n\n```\npublic class Tree<T>{\n\tT data;\n\tTree<T> left;\n\tTree<T> right;\n\tpublic Tree(T value){\n\t\tthis.data = value;\n\t}\t\n}\n```\n\n### 图\ns\n\n","slug":"算法-三-常用数据结构的定义","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimml001207fyg66sp21g","content":"<pre><code>说明：文章的数据结构是基于Java总结的,java中使用的数据结构就是数组和引用（就是指针）\n</code></pre><p>常用的数据结构有栈，队列，链表，树，图等的数据结构的定义。<br>个人觉得了解一种数据结构必须了解它的定义，明白了定义我们就知道如何去扩展。</p>\n<h3 id=\"栈-–-gt-本质是数组\"><a href=\"#栈-–-gt-本质是数组\" class=\"headerlink\" title=\"栈 –&gt;本质是数组\"></a>栈 –&gt;本质是数组</h3><p>java中Stack类继承自Vector，而Vector的实现是基于数组的</p>\n<h3 id=\"队列-–-gt-本质也是数组\"><a href=\"#队列-–-gt-本质也是数组\" class=\"headerlink\" title=\"队列 –&gt;本质也是数组\"></a>队列 –&gt;本质也是数组</h3><p>Java中常用的队列就是PriorityQueue 其实现是基于数据的</p>\n<h3 id=\"链表一般会分为单链表-循环链表-双向链表\"><a href=\"#链表一般会分为单链表-循环链表-双向链表\" class=\"headerlink\" title=\"链表一般会分为单链表,循环链表,双向链表\"></a>链表一般会分为单链表,循环链表,双向链表</h3><p>链表，链表顾名思义就是要连起来么，即当前数据应该了下一个数据是有关联的。<br>单链表的基本结构的定义</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span>&lt;<span class=\"type\">T</span>&gt;</span>&#123;</div><div class=\"line\">\tT <span class=\"keyword\">data</span>;</div><div class=\"line\">\tLinkList&lt;T&gt; next;</div><div class=\"line\">\t<span class=\"keyword\">public</span> LinkList(T value)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = value;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>循环链表的数据结构和单链表相同，只是最后一个元素和第一个元素相连，单链表的最一个元素是null,</p>\n<p>双向链表：从字面上理解可知道元素之间的关联是双向的，当前元素不仅和下一个有联系，应该和上一个元素也有关系。我们便可以在单链表的基础上修改成双链表，结构如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span>&lt;<span class=\"type\">T</span>&gt;</span>&#123;</div><div class=\"line\">\tT <span class=\"keyword\">data</span>;</div><div class=\"line\">\tLinkList&lt;T&gt; next;</div><div class=\"line\">\tLinkList&lt;T&gt; pre;</div><div class=\"line\">\t<span class=\"keyword\">public</span> LinkList(T value)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = value;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树中最重要的莫过于二叉树了，二叉树树的数据结构和链表是类似的(树的一种比较极端的例子就是一棵树只有左子树或者只有右子树，那么其就够就是链表，其本质是相同的区别就在于怎么连)。至于其它树的结构在二叉树的基础上扩展即可，不再详细赘述。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Tree&lt;<span class=\"built_in\">T</span>&gt;&#123;</div><div class=\"line\">\t<span class=\"built_in\">T</span> data;</div><div class=\"line\">\tTree&lt;<span class=\"built_in\">T</span>&gt; <span class=\"built_in\">left</span>;</div><div class=\"line\">\tTree&lt;<span class=\"built_in\">T</span>&gt; <span class=\"built_in\">right</span>;</div><div class=\"line\">\tpublic Tree(<span class=\"built_in\">T</span> <span class=\"built_in\">value</span>)&#123;</div><div class=\"line\">\t\tthis.data = <span class=\"built_in\">value</span>;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>s</p>\n","excerpt":"","more":"<pre><code>说明：文章的数据结构是基于Java总结的,java中使用的数据结构就是数组和引用（就是指针）\n</code></pre><p>常用的数据结构有栈，队列，链表，树，图等的数据结构的定义。<br>个人觉得了解一种数据结构必须了解它的定义，明白了定义我们就知道如何去扩展。</p>\n<h3 id=\"栈-–-gt-本质是数组\"><a href=\"#栈-–-gt-本质是数组\" class=\"headerlink\" title=\"栈 –&gt;本质是数组\"></a>栈 –&gt;本质是数组</h3><p>java中Stack类继承自Vector，而Vector的实现是基于数组的</p>\n<h3 id=\"队列-–-gt-本质也是数组\"><a href=\"#队列-–-gt-本质也是数组\" class=\"headerlink\" title=\"队列 –&gt;本质也是数组\"></a>队列 –&gt;本质也是数组</h3><p>Java中常用的队列就是PriorityQueue 其实现是基于数据的</p>\n<h3 id=\"链表一般会分为单链表-循环链表-双向链表\"><a href=\"#链表一般会分为单链表-循环链表-双向链表\" class=\"headerlink\" title=\"链表一般会分为单链表,循环链表,双向链表\"></a>链表一般会分为单链表,循环链表,双向链表</h3><p>链表，链表顾名思义就是要连起来么，即当前数据应该了下一个数据是有关联的。<br>单链表的基本结构的定义</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span>&lt;<span class=\"type\">T</span>&gt;</span>&#123;</div><div class=\"line\">\tT <span class=\"keyword\">data</span>;</div><div class=\"line\">\tLinkList&lt;T&gt; next;</div><div class=\"line\">\t<span class=\"keyword\">public</span> LinkList(T value)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = value;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>循环链表的数据结构和单链表相同，只是最后一个元素和第一个元素相连，单链表的最一个元素是null,</p>\n<p>双向链表：从字面上理解可知道元素之间的关联是双向的，当前元素不仅和下一个有联系，应该和上一个元素也有关系。我们便可以在单链表的基础上修改成双链表，结构如下</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkList</span>&lt;<span class=\"type\">T</span>&gt;</span>&#123;</div><div class=\"line\">\tT <span class=\"keyword\">data</span>;</div><div class=\"line\">\tLinkList&lt;T&gt; next;</div><div class=\"line\">\tLinkList&lt;T&gt; pre;</div><div class=\"line\">\t<span class=\"keyword\">public</span> LinkList(T value)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = value;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树中最重要的莫过于二叉树了，二叉树树的数据结构和链表是类似的(树的一种比较极端的例子就是一棵树只有左子树或者只有右子树，那么其就够就是链表，其本质是相同的区别就在于怎么连)。至于其它树的结构在二叉树的基础上扩展即可，不再详细赘述。</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Tree&lt;<span class=\"built_in\">T</span>&gt;&#123;</div><div class=\"line\">\t<span class=\"built_in\">T</span> data;</div><div class=\"line\">\tTree&lt;<span class=\"built_in\">T</span>&gt; <span class=\"built_in\">left</span>;</div><div class=\"line\">\tTree&lt;<span class=\"built_in\">T</span>&gt; <span class=\"built_in\">right</span>;</div><div class=\"line\">\tpublic Tree(<span class=\"built_in\">T</span> <span class=\"built_in\">value</span>)&#123;</div><div class=\"line\">\t\tthis.data = <span class=\"built_in\">value</span>;</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>s</p>\n"},{"title":"深入理解Java虚拟机(二)","date":"2016-11-16T08:07:22.000Z","_content":"","source":"_posts/深入理解Java虚拟机-二.md","raw":"---\ntitle: 深入理解Java虚拟机(二)\ndate: 2016-11-16 16:07:22\ntags:\n---\n","slug":"深入理解Java虚拟机-二","published":1,"updated":"2016-11-16T08:07:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmn001407fyn7jbrffl","content":"","excerpt":"","more":""},{"title":"读书","date":"2015-09-05T12:03:57.000Z","_content":"","source":"_posts/读书 2.md","raw":"title: 读书\ndate: 2015-09-05 20:03:57\ntags:\n---\n","slug":"读书 2","published":1,"updated":"2016-10-10T01:35:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmp001707fy0r2ciamx","content":"","excerpt":"","more":""},{"title":"算法(二):实现一个getMin功能的栈","date":"2016-09-10T07:59:55.000Z","_content":"\n> 题目:\n> 在Stack的基础上实现一个可以获得Stack的最小元素的方法（getMin）,要求pop,push,getMin操作的时间复杂度是o(1)\n> \n\n题目来源《程序员代码面试指南》作者：左程云\n\n### 0.分析\n题目要求时间复杂度为o(1),即可以直接获得Stack的最小元素，我们可以使用两个栈，一个栈（StackData）存储全部元素，一个栈(StackMin)来存储最小元素（其实不是一个最小元素，应该是比第一个压入StackData栈的小的所有元素），getMin即获得StackMin栈的栈顶元素，需要注意的就是在push和pop时都需要和StackMin栈的栈顶做比较,如果出栈的数据与StackMin栈顶元素相同那么StackMin也需要pop数据。\n如图\n![](/img/stack/getMinStack.png)\n\n### 1.代码\n\n```\n\nimport java.util.Stack;\n\npublic class MinSatck {\n\t\n\tprivate Stack<Integer> stackData;\n\tprivate Stack<Integer> stackMin;\n\t\n\tpublic MinSatck() {\n\n\t\tthis.stackData = new Stack<>();\n\t\tthis.stackMin = new Stack<>();\n\t}\n\tpublic void push(int item){\n\t\t\n\t\tif (stackMin.isEmpty()) {\n\t\t\tstackMin.push(item);\n\t\t}else if (item <= getMin()) {\n\t\t\tstackMin.push(item);\n\t\t}\t\n\t\t\n\t\tstackData.push(item);\n\t}\n\t\n\tpublic int pop(){\n\t\tif (stackData.isEmpty()) {\n\t\t\tthrow new RuntimeException(\"stack is empty\");\n\t\t}else{\n\t\t\tint value = stackData.pop();\n\t\t\tif (value == getMin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\t\n\tpublic int getMin(){\n\t\tif (stackMin.isEmpty()) {\n\t\t\tthrow new RuntimeException(\"stack is empty\");\n\t\t}\n\t\treturn stackMin.peek();\n\t}\n\t\n}\n```\n\n\n\n","source":"_posts/算法-二-实现一个getMin功能的栈.md","raw":"---\ntitle: '算法(二):实现一个getMin功能的栈'\ndate: 2016-09-10 15:59:55\ntags:\n\t- 算法\n\t- Stack\n\t- 栈\n---\n\n> 题目:\n> 在Stack的基础上实现一个可以获得Stack的最小元素的方法（getMin）,要求pop,push,getMin操作的时间复杂度是o(1)\n> \n\n题目来源《程序员代码面试指南》作者：左程云\n\n### 0.分析\n题目要求时间复杂度为o(1),即可以直接获得Stack的最小元素，我们可以使用两个栈，一个栈（StackData）存储全部元素，一个栈(StackMin)来存储最小元素（其实不是一个最小元素，应该是比第一个压入StackData栈的小的所有元素），getMin即获得StackMin栈的栈顶元素，需要注意的就是在push和pop时都需要和StackMin栈的栈顶做比较,如果出栈的数据与StackMin栈顶元素相同那么StackMin也需要pop数据。\n如图\n![](/img/stack/getMinStack.png)\n\n### 1.代码\n\n```\n\nimport java.util.Stack;\n\npublic class MinSatck {\n\t\n\tprivate Stack<Integer> stackData;\n\tprivate Stack<Integer> stackMin;\n\t\n\tpublic MinSatck() {\n\n\t\tthis.stackData = new Stack<>();\n\t\tthis.stackMin = new Stack<>();\n\t}\n\tpublic void push(int item){\n\t\t\n\t\tif (stackMin.isEmpty()) {\n\t\t\tstackMin.push(item);\n\t\t}else if (item <= getMin()) {\n\t\t\tstackMin.push(item);\n\t\t}\t\n\t\t\n\t\tstackData.push(item);\n\t}\n\t\n\tpublic int pop(){\n\t\tif (stackData.isEmpty()) {\n\t\t\tthrow new RuntimeException(\"stack is empty\");\n\t\t}else{\n\t\t\tint value = stackData.pop();\n\t\t\tif (value == getMin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\t\n\tpublic int getMin(){\n\t\tif (stackMin.isEmpty()) {\n\t\t\tthrow new RuntimeException(\"stack is empty\");\n\t\t}\n\t\treturn stackMin.peek();\n\t}\n\t\n}\n```\n\n\n\n","slug":"算法-二-实现一个getMin功能的栈","published":1,"updated":"2016-09-23T01:35:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmr001807fyb30bgiwb","content":"<blockquote>\n<p>题目:<br>在Stack的基础上实现一个可以获得Stack的最小元素的方法（getMin）,要求pop,push,getMin操作的时间复杂度是o(1)</p>\n</blockquote>\n<p>题目来源《程序员代码面试指南》作者：左程云</p>\n<h3 id=\"0-分析\"><a href=\"#0-分析\" class=\"headerlink\" title=\"0.分析\"></a>0.分析</h3><p>题目要求时间复杂度为o(1),即可以直接获得Stack的最小元素，我们可以使用两个栈，一个栈（StackData）存储全部元素，一个栈(StackMin)来存储最小元素（其实不是一个最小元素，应该是比第一个压入StackData栈的小的所有元素），getMin即获得StackMin栈的栈顶元素，需要注意的就是在push和pop时都需要和StackMin栈的栈顶做比较,如果出栈的数据与StackMin栈顶元素相同那么StackMin也需要pop数据。<br>如图<br><img src=\"/img/stack/getMinStack.png\" alt=\"\"></p>\n<h3 id=\"1-代码\"><a href=\"#1-代码\" class=\"headerlink\" title=\"1.代码\"></a>1.代码</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import java.util.Stack;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MinSatck</span> &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinSatck</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span>(<span class=\"params\"><span class=\"keyword\">int</span> item</span>)</span>&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackMin.isEmpty()) &#123;</div><div class=\"line\">\t\t\tstackMin.push(item);</div><div class=\"line\">\t\t&#125;<span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> (<span class=\"params\">item &lt;= getMin(</span>)) </span>&#123;</div><div class=\"line\">\t\t\tstackMin.push(item);</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tstackData.push(item);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackData.isEmpty()) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> <span class=\"keyword\">value</span> = stackData.pop();</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> == getMin()) &#123;</div><div class=\"line\">\t\t\t\tstackMin.pop();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackMin.isEmpty()) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> stackMin.peek();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>题目:<br>在Stack的基础上实现一个可以获得Stack的最小元素的方法（getMin）,要求pop,push,getMin操作的时间复杂度是o(1)</p>\n</blockquote>\n<p>题目来源《程序员代码面试指南》作者：左程云</p>\n<h3 id=\"0-分析\"><a href=\"#0-分析\" class=\"headerlink\" title=\"0.分析\"></a>0.分析</h3><p>题目要求时间复杂度为o(1),即可以直接获得Stack的最小元素，我们可以使用两个栈，一个栈（StackData）存储全部元素，一个栈(StackMin)来存储最小元素（其实不是一个最小元素，应该是比第一个压入StackData栈的小的所有元素），getMin即获得StackMin栈的栈顶元素，需要注意的就是在push和pop时都需要和StackMin栈的栈顶做比较,如果出栈的数据与StackMin栈顶元素相同那么StackMin也需要pop数据。<br>如图<br><img src=\"/img/stack/getMinStack.png\" alt=\"\"></p>\n<h3 id=\"1-代码\"><a href=\"#1-代码\" class=\"headerlink\" title=\"1.代码\"></a>1.代码</h3><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">import java.util.Stack;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">MinSatck</span> &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackData;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Stack&lt;Integer&gt; stackMin;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinSatck</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stackData = <span class=\"keyword\">new</span> Stack&lt;&gt;();</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.stackMin = <span class=\"keyword\">new</span> Stack&lt;&gt;();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span>(<span class=\"params\"><span class=\"keyword\">int</span> item</span>)</span>&#123;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackMin.isEmpty()) &#123;</div><div class=\"line\">\t\t\tstackMin.push(item);</div><div class=\"line\">\t\t&#125;<span class=\"function\"><span class=\"keyword\">else</span> <span class=\"title\">if</span> (<span class=\"params\">item &lt;= getMin(</span>)) </span>&#123;</div><div class=\"line\">\t\t\tstackMin.push(item);</div><div class=\"line\">\t\t&#125;\t</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tstackData.push(item);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackData.isEmpty()) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> <span class=\"keyword\">value</span> = stackData.pop();</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">value</span> == getMin()) &#123;</div><div class=\"line\">\t\t\t\tstackMin.pop();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (stackMin.isEmpty()) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"stack is empty\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> stackMin.peek();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"读书","date":"2016-09-01T06:32:21.000Z","_content":"\n从小有个习惯，就是爱买书，但是买的书基本不看，工作以后买的就更多了。\n这就是我从学编程到现在买的书（不是全部）,基本都是技术书籍，大部分只是概括的看了看。也有仔细研究过的书籍，完后有时间再一一列举\n\n ![](/img/bookImg/allbooks.jpeg)\n\n","source":"_posts/读书.md","raw":"---\ntitle: 读书\ndate: 2016-09-01 14:32:21\ntags:\n    - 读书\n    - 编程书籍\n---\n\n从小有个习惯，就是爱买书，但是买的书基本不看，工作以后买的就更多了。\n这就是我从学编程到现在买的书（不是全部）,基本都是技术书籍，大部分只是概括的看了看。也有仔细研究过的书籍，完后有时间再一一列举\n\n ![](/img/bookImg/allbooks.jpeg)\n\n","slug":"读书","published":1,"updated":"2016-09-09T06:43:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civubimmt001a07fy92d8ws3w","content":"<p>从小有个习惯，就是爱买书，但是买的书基本不看，工作以后买的就更多了。<br>这就是我从学编程到现在买的书（不是全部）,基本都是技术书籍，大部分只是概括的看了看。也有仔细研究过的书籍，完后有时间再一一列举</p>\n<p> <img src=\"/img/bookImg/allbooks.jpeg\" alt=\"\"></p>\n","excerpt":"","more":"<p>从小有个习惯，就是爱买书，但是买的书基本不看，工作以后买的就更多了。<br>这就是我从学编程到现在买的书（不是全部）,基本都是技术书籍，大部分只是概括的看了看。也有仔细研究过的书籍，完后有时间再一一列举</p>\n<p> <img src=\"/img/bookImg/allbooks.jpeg\" alt=\"\"></p>\n"}],"PostAsset":[{"_id":"source/_posts/Java内部类详解/innerclass01.png","post":"civubimlh000107fy7lj7j2of","slug":"innerclass01.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"civubimlv000807fykofdtazn","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimlz000b07fyc2597ks8"},{"post_id":"civubimlh000107fy7lj7j2of","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimm5000g07fy9cz2ewpl"},{"post_id":"civubimlh000107fy7lj7j2of","tag_id":"civubimly000a07fyhstfw24z","_id":"civubimm7000i07fyexi8jtzv"},{"post_id":"civubimlm000307fy61firte0","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimmg000r07fyhlhzkjkr"},{"post_id":"civubimlm000307fy61firte0","tag_id":"civubimm8000j07fyuk9msfqj","_id":"civubimmh000t07fym5shd7pe"},{"post_id":"civubimlm000307fy61firte0","tag_id":"civubimmb000m07fyf0p74cyn","_id":"civubimmi000w07fyuep54ses"},{"post_id":"civubimlt000607fy4kg2ewvg","tag_id":"civubimme000p07fy3sfkrpcd","_id":"civubimmj000y07fyjppkx0fs"},{"post_id":"civubimmh000u07fy0llat3i7","tag_id":"civubimme000p07fy3sfkrpcd","_id":"civubimmk001107fy8qcpsisv"},{"post_id":"civubimlx000907fy0doqit3s","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimmm001307fypmrnls1m"},{"post_id":"civubimlx000907fy0doqit3s","tag_id":"civubimmi000v07fyz96epug2","_id":"civubimmp001607fytmtfxh05"},{"post_id":"civubimm1000d07fy5uvew00v","tag_id":"civubimmk001007fy14939iky","_id":"civubimmu001b07fy3o05c3gt"},{"post_id":"civubimm1000d07fy5uvew00v","tag_id":"civubimmi000v07fyz96epug2","_id":"civubimmu001c07fyead14xe4"},{"post_id":"civubimm4000f07fy65s7lg0f","tag_id":"civubimme000p07fy3sfkrpcd","_id":"civubimmv001e07fyehscn28x"},{"post_id":"civubimma000l07fyad7chv1r","tag_id":"civubimmu001d07fy3foox18j","_id":"civubimmv001i07fyklufh8pz"},{"post_id":"civubimma000l07fyad7chv1r","tag_id":"civubimmv001f07fy417gvpyx","_id":"civubimmv001j07fy3k7fitj1"},{"post_id":"civubimma000l07fyad7chv1r","tag_id":"civubimmv001g07fy64u6r4g2","_id":"civubimmw001l07fy6ivb77n6"},{"post_id":"civubimmb000n07fy3idpicos","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimmw001m07fyt7wd0e28"},{"post_id":"civubimmb000n07fy3idpicos","tag_id":"civubimmv001h07fy6d0v7lnn","_id":"civubimmw001o07fy9p5i2cke"},{"post_id":"civubimmd000o07fyed9mvj2u","tag_id":"civubimmv001k07fy0b572ckj","_id":"civubimmx001r07fy81th2nde"},{"post_id":"civubimmd000o07fyed9mvj2u","tag_id":"civubimmw001n07fyf8iy7p19","_id":"civubimmx001s07fyqznk93h9"},{"post_id":"civubimmd000o07fyed9mvj2u","tag_id":"civubimmw001p07fy00ph9wbf","_id":"civubimmx001u07fyrh82fads"},{"post_id":"civubimmf000q07fyboiamfkk","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimmx001v07fy5jukladi"},{"post_id":"civubimmf000q07fyboiamfkk","tag_id":"civubimmw001q07fylnwlsgky","_id":"civubimmy001x07fyj5f3ffia"},{"post_id":"civubimmk000z07fy7numomm9","tag_id":"civubimmx001t07fyd3jp086v","_id":"civubimmz002007fyr3p7p452"},{"post_id":"civubimmk000z07fy7numomm9","tag_id":"civubimmx001w07fym77ng5f2","_id":"civubimmz002107fyo47t9g08"},{"post_id":"civubimmk000z07fy7numomm9","tag_id":"civubimmy001y07fyqzixjea5","_id":"civubimmz002307fymbzekx22"},{"post_id":"civubimml001207fyg66sp21g","tag_id":"civubimmx001t07fyd3jp086v","_id":"civubimmz002507fy1yqdoeqn"},{"post_id":"civubimml001207fyg66sp21g","tag_id":"civubimlr000507fyfmpgh7i0","_id":"civubimmz002607fybk3vgb2y"},{"post_id":"civubimml001207fyg66sp21g","tag_id":"civubimmz002207fy4m4z4ha3","_id":"civubimn0002807fy8athiyvf"},{"post_id":"civubimmr001807fyb30bgiwb","tag_id":"civubimmx001t07fyd3jp086v","_id":"civubimn1002b07fyki0rfwqm"},{"post_id":"civubimmr001807fyb30bgiwb","tag_id":"civubimmx001w07fym77ng5f2","_id":"civubimn1002c07fyejo5h8tb"},{"post_id":"civubimmr001807fyb30bgiwb","tag_id":"civubimmy001y07fyqzixjea5","_id":"civubimn2002e07fyik2cngrc"},{"post_id":"civubimmt001a07fy92d8ws3w","tag_id":"civubimn0002a07fyazfswfi7","_id":"civubimn2002f07fy920bwvny"},{"post_id":"civubimmt001a07fy92d8ws3w","tag_id":"civubimn1002d07fy1v573e45","_id":"civubimn2002g07fy75zkzw55"}],"Tag":[{"name":"Java","_id":"civubimlr000507fyfmpgh7i0"},{"name":"Java内部类","_id":"civubimly000a07fyhstfw24z"},{"name":"注解","_id":"civubimm8000j07fyuk9msfqj"},{"name":"interface","_id":"civubimmb000m07fyf0p74cyn"},{"name":"iOS","_id":"civubimme000p07fy3sfkrpcd"},{"name":"ArrayList","_id":"civubimmi000v07fyz96epug2"},{"name":"HashSet","_id":"civubimmk001007fy14939iky"},{"name":"java","_id":"civubimmu001d07fy3foox18j"},{"name":"lombok","_id":"civubimmv001f07fy417gvpyx"},{"name":"代码优化","_id":"civubimmv001g07fy64u6r4g2"},{"name":"深入理解Java虚拟机","_id":"civubimmv001h07fy6d0v7lnn"},{"name":"Nginx","_id":"civubimmv001k07fy0b572ckj"},{"name":"负载均衡","_id":"civubimmw001n07fyf8iy7p19"},{"name":"Tomcat","_id":"civubimmw001p07fy00ph9wbf"},{"name":"Java虚拟机","_id":"civubimmw001q07fylnwlsgky"},{"name":"算法","_id":"civubimmx001t07fyd3jp086v"},{"name":"Stack","_id":"civubimmx001w07fym77ng5f2"},{"name":"栈","_id":"civubimmy001y07fyqzixjea5"},{"name":"数据结构","_id":"civubimmz002207fy4m4z4ha3"},{"name":"读书","_id":"civubimn0002a07fyazfswfi7"},{"name":"编程书籍","_id":"civubimn1002d07fy1v573e45"}]}}